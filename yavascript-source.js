(function(global) {

function factory() {
var modules = {
/* --- src/index.ts --- */
"src/index.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _printError = _interopRequireDefault(_kame_require_("src/print-error.ts"));
_kame_require_("src/primordials.ts");
var _eval = _interopRequireDefault(_kame_require_("src/targets/eval.ts"));
var _help = _interopRequireDefault(_kame_require_("src/targets/help.ts"));
var _invalid = _interopRequireDefault(_kame_require_("src/targets/invalid.ts"));
var _license = _interopRequireDefault(_kame_require_("src/targets/license.ts"));
var _printSrc = _interopRequireDefault(_kame_require_("src/targets/print-src.ts"));
var _printTypes = _interopRequireDefault(_kame_require_("src/targets/print-types.ts"));
var _repl = _interopRequireDefault(_kame_require_("src/targets/repl/index.ts"));
var _runFile = _interopRequireDefault(_kame_require_("src/targets/run-file.ts"));
var _version = _interopRequireDefault(_kame_require_("src/targets/version.ts"));
var _determineTarget = _interopRequireDefault(_kame_require_("src/determine-target.ts"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function main() {
  const targetInfo = (0, _determineTarget.default)(scriptArgs);
  switch (targetInfo.target) {
    case "eval":
      {
        const {
          code,
          lang
        } = targetInfo;
        (0, _eval.default)(code, lang ?? "javascript");
        return;
      }
    case "help":
      {
        (0, _help.default)();
        return;
      }
    case "invalid":
      {
        const {
          message
        } = targetInfo;
        (0, _invalid.default)(message);
        std.exit(3);
        return;
      }
    case "license":
      {
        (0, _license.default)();
        return;
      }
    case "print-src":
      {
        (0, _printSrc.default)();
        return;
      }
    case "print-types":
      {
        (0, _printTypes.default)();
        return;
      }
    case "repl":
      {
        const {
          lang
        } = targetInfo;
        (0, _repl.default)(lang ?? "javascript");
        return;
      }
    case "run-file":
      {
        const {
          file,
          lang
        } = targetInfo;
        (0, _runFile.default)(file, lang);
        return;
      }
    case "version":
      {
        (0, _version.default)();
        return;
      }
    default:
      {
        const here = targetInfo;
        throw new Error(`Unhandled target: ${JSON.stringify(targetInfo)}`);
      }
  }
}
try {
  main();
} catch (err) {
  (0, _printError.default)(err, std.err);
  std.exit(1);
}
}),
/* --- node_modules/@babel/runtime/helpers/interopRequireDefault.js --- */
"node_modules/@babel/runtime/helpers/interopRequireDefault.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
/* --- external:std --- */
"external:std": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
if (typeof require === "function") {
	module.exports = require("std");
} else if (typeof std !== "undefined") {
	module.exports = std;
} else if (typeof Std !== "undefined") {
	module.exports = Std;
} else {
	if ("production" !== "production") {
		console.warn("Failed to load external " + "std" + ". An empty module will be used instead, but this might cause problems in your code. Consider using a custom resolver to shim this external.");
	}
	module.exports = {};
}
}),
/* --- src/print-error.ts --- */
"src/print-error.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = printError;
var os = _interopRequireWildcard(_kame_require_("external:os"));
var inspectOptions = _interopRequireWildcard(_kame_require_("src/inspect-options.ts"));
var _strings = _kame_require_("src/api/strings.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const normalProps = new Set(["name", "message", "stack"]);
function printError(error, file) {
  if (typeof error === "object" && error != null && typeof error.name === "string" && typeof error.message === "string" && typeof error.stack === "string") {
    file.puts(error.name);
    file.puts(": ");
    file.puts(error.message);
    file.puts("\n");
    file.puts(error.stack.split("\n").map(line => line.replace(/^\s+/, "  ")).join("\n").replace(/\s+$/, ""));
    let extraProps = [];
    try {
      extraProps = Object.getOwnPropertyNames(error).filter(name => !normalProps.has(name));
    } catch (err) {
      // ignored
    }
    if (extraProps.length > 0) {
      const propsObj = {};
      for (const key of extraProps) {
        propsObj[key] = error[key];
      }
      file.puts(" ");
      file.puts(inspect(propsObj, inspectOptions.forPrint));
    }
    file.puts("\n");
    try {
      const execPath = os.realpath(os.execPath());
      if (new RegExp(execPath).test(error.stack)) {
        file.puts((0, _strings.blue)(`To view the code inside ${JSON.stringify(execPath)} as referred to in the above stack trace, run '${execPath} --print-src > yavascript-source.js', then open the newly-created file 'yavascript-source.js.'\n`));
      }
    } catch (err) {
      // ignore
    }
  } else {
    file.puts("Non-error value was thrown: ");
    file.puts(inspect(error, inspectOptions.forPrint));
    file.puts("\n");
  }
}
}),
/* --- src/primordials.ts --- */
"src/primordials.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _installApi = _interopRequireDefault(_kame_require_("src/api/_installApi.ts"));
_kame_require_("src/extension-handlers/_load-all.ts");
// This file loads all the globals and etc

(0, _installApi.default)(globalThis);
}),
/* --- src/targets/eval.ts --- */
"src/targets/eval.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = evalTarget;
var _std = _interopRequireDefault(_kame_require_("external:std"));
var _os = _interopRequireDefault(_kame_require_("external:os"));
var esmToRequire = _interopRequireWildcard(_kame_require_("src/esm-to-require.ts"));
var _special = _kame_require_("src/targets/repl/special.ts");
var _langs = _kame_require_("src/langs.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function evalTarget(inputCode, lang) {
  // Make os and std available as globals
  Object.assign(globalThis, {
    os: _os.default,
    std: _std.default
  });
  let codeToRun = null;
  const compiler = (0, _langs.langToCompiler)(lang);
  codeToRun = compiler(inputCode, {
    expression: true
  });
  const transformedCode = esmToRequire.transform(codeToRun);
  const result = _std.default.evalScript(transformedCode, {
    backtraceBarrier: true
  });
  if (typeof result !== "undefined" && result !== _special.NOTHING) {
    console.log(result);
  }
}
}),
/* --- src/targets/help.ts --- */
"src/targets/help.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = helpTarget;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _VERSION_HARDCODEDEvalAtBuildTime = _interopRequireDefault(_kame_require_("src/targets/VERSION_HARDCODED.ts?evalAtBuildTime"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function helpTarget() {
  std.err.puts(`yavascript ${_VERSION_HARDCODEDEvalAtBuildTime.default}

Usage: One of these:
  yavascript
  yavascript --lang <some-language>
  yavascript <path/to/file-to-run.js>
  yavascript -e '<code-to-run>'
  yavascript --eval '<code-to-run>'
  yavascript -e '<code-to-run>' --lang <some-language>
  yavascript --eval '<code-to-run>' --lang <some-language>
  yavascript -v
  yavascript --version
  yavascript --license
  yavascript --print-types
  yavascript --print-src

Where <some-language> can be one of: "js", "javascript", "ts", "typescript",
"jsx", "tsx", "coffee", or "coffeescript".

YavaScript is a bash-like script runner which is distributed as a single
statically-linked binary. Scripts are written in JavaScript or CoffeeScript.
There are global APIs available for all the things you'd normally want to do in
a bash script, such as:

- Running programs
- Accessing environment variables
- Reading and writing file contents
- Checking if files/folders exist
- Removing files/folders
- Reading and changing the current working directory
- Using globs to get large lists of files
- Printing stylized text to the terminal

Additionally, since it's JavaScript, you get some other features that are
either not present in bash or are cumbersome to use in bash, namely:

- Arrays (lists) and Objects (key/value dictionaries)
- Working with path strings
- Working with JSON
- Cross-file import/export using ECMAScript Modules
- Splitting strings on delimeters
- Pretty-printing of objects
- Getting the path to the currently-running script (via import.meta.url or \`__filename\`)
- Getting the absolute path to the root folder of the current git/mercurial repo (repoRoot function)

To view the APIs, consult the file yavascript.d.ts which was distributed with
this program. If you don't have that file or don't know where it is, you can
run \`yavascript --print-types > yavascript.d.ts\` to regenerate it. If you
don't have YavaScript installed, you can view the file online at
https://github.com/suchipi/yavascript/blob/main/yavascript.d.ts.

yavascript.d.ts contains TypeScript type definitions which can be given to your IDE
to assist you when writing scripts.

YavaScript is powered by a fork of the QuickJS JavaScript Engine, originally
written by Fabrice Bellard. QuickJS is a small, fast JavaScript engine
supporting the ES2020 specification.

- Original QuickJS engine: https://bellard.org/quickjs/
- The fork we use: https://github.com/suchipi/quickjs/

YavaScript is written with <3 by Lily Skye.
`);
}
}),
/* --- src/targets/invalid.ts --- */
"src/targets/invalid.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = invalidTarget;
var std = _interopRequireWildcard(_kame_require_("external:std"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function invalidTarget(message) {
  std.err.puts(message + "\n");
  std.err.puts(`For more info, run '${scriptArgs[0]} --help'.\n`);
}
}),
/* --- src/targets/license.ts --- */
"src/targets/license.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = licenseTarget;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _licenseText = _interopRequireDefault(_kame_require_("src/license-text.ts"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function licenseTarget() {
  std.out.puts(_licenseText.default);
  std.exit(0);
}
}),
/* --- src/targets/print-src.ts --- */
"src/targets/print-src.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = printSrcTarget;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var os = _interopRequireWildcard(_kame_require_("external:os"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function printSrcTarget() {
  const qjsbootstrap_offset = globalThis.__qjsbootstrap_offset;
  if (qjsbootstrap_offset == null) {
    throw new Error("Was not able to find the offset where qjsbootstrap ends and yavascript begins");
  }
  const yavascriptBin = std.open(os.execPath(), "r");
  yavascriptBin.seek(qjsbootstrap_offset, std.SEEK_SET);
  const yavascriptSrc = yavascriptBin.readAsString();
  std.out.puts(yavascriptSrc);
}
}),
/* --- src/targets/print-types.ts --- */
"src/targets/print-types.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = printTypesTarget;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _yavascriptD = _interopRequireDefault(_kame_require_("dist/yavascript.d.ts?contentString"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
// @ts-ignore cannot find module

function printTypesTarget() {
  std.out.puts(_yavascriptD.default);
  std.exit(0);
}
}),
/* --- src/targets/repl/index.ts --- */
"src/targets/repl/index.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = replTarget;
function replTarget(lang) {
  _kame_require_("src/targets/repl/modified-qjs-repl.js").startRepl(lang);
}
}),
/* --- src/targets/run-file.ts --- */
"src/targets/run-file.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = runFileTarget;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _langs = _kame_require_("src/langs.ts");
var _extname = _kame_require_("src/api/commands/extname.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function runFileTarget(fileToRun, langOverride) {
  if (langOverride != null) {
    const compiler = (0, _langs.langToCompiler)(langOverride);
    const extension = (0, _extname.extname)(fileToRun);
    const existingExtensionHandler = Module.compilers[extension];
    Module.compilers[extension] = (filename, content) => {
      if (filename === fileToRun) {
        return compiler(content, {
          filename
        });
      } else if (existingExtensionHandler != null) {
        return existingExtensionHandler(filename, content);
      } else {
        return content;
      }
    };
  }
  std.importModule(fileToRun, "./<cwd>");
}
}),
/* --- src/targets/version.ts --- */
"src/targets/version.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = versionTarget;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _VERSION_HARDCODEDEvalAtBuildTime = _interopRequireDefault(_kame_require_("src/targets/VERSION_HARDCODED.ts?evalAtBuildTime"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function versionTarget() {
  std.out.puts(_VERSION_HARDCODEDEvalAtBuildTime.default);
  std.exit(0);
}
}),
/* --- src/determine-target.ts --- */
"src/determine-target.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = determineTarget;
var _langs = _kame_require_("src/langs.ts");
function determineTarget(argv) {
  const [_yavascriptBinary, ...rest] = argv;
  if (rest.length === 0) {
    // They ran the program with no args
    return {
      target: "repl",
      lang: null
    };
  }
  const arg1 = rest[0];
  if (rest.length === 1) {
    // Note that these flags *only* function when there are no other arguments.
    // This is done to minimize collisions between flags for user programs and
    // flags for yavascript itself. Namely, if a user wants to implement custom
    // behavior in their own CLI tool for '-h' or '-v', they should be able to
    // do so. In order to guarantee that, we must *NOT* run *our* behavior for
    // those flags unless we are certain we aren't about to execute a user
    // program.
    switch (arg1) {
      case "-h":
      case "--help":
        {
          return {
            target: "help"
          };
        }
      case "-v":
      case "--version":
      case "-version":
        {
          return {
            target: "version"
          };
        }
      case "--license":
        {
          return {
            target: "license"
          };
        }
      case "--print-types":
        {
          return {
            target: "print-types"
          };
        }
      case "--print-src":
        {
          return {
            target: "print-src"
          };
        }
      case "-e":
      case "--eval":
        {
          return {
            target: "invalid",
            message: `Please specify the code string to run. For example: yavascript -e 'echo("hi")'`
          };
        }
      case "--lang":
        {
          return {
            target: "invalid",
            message: "--lang requires an argument: The language to use."
          };
        }
      case "--":
        {
          // Act as if they ran the program with no args
          return {
            target: "repl",
            lang: null
          };
        }
      default:
        {
          return {
            target: "run-file",
            file: arg1,
            lang: null
          };
        }
    }
  }
  const info = {
    file: null,
    eval: null,
    lang: null
  };
  for (let i = 0; i < rest.length; i++) {
    const arg = rest[i];
    const nextArg = rest[i + 1] || null;
    if (arg === "--") {
      break;
    }
    if (arg === "-e" || arg === "--eval") {
      if (nextArg == null) {
        return {
          target: "invalid",
          message: `${arg} requires an argument: The code to eval.`
        };
      }
      info.eval = nextArg;
      i++;
    } else if (arg === "--lang") {
      if (nextArg == null) {
        return {
          target: "invalid",
          message: "--lang requires an argument: The language to use."
        };
      }
      if (!_langs.LANGS.has(nextArg)) {
        const validLangs = Array.from(_langs.LANGS);
        return {
          target: "invalid",
          message: `Invalid --lang: ${JSON.stringify(nextArg)}.\nValid values for --lang are ${validLangs.slice(0, -1).join(", ")} or ${validLangs[validLangs.length - 1]}.\n`
        };
      }
      info.lang = nextArg;
      i++;
    } else if (info.eval == null && info.file == null) {
      info.file = arg;
    }
  }
  if (info.eval != null) {
    return {
      target: "eval",
      code: info.eval,
      lang: info.lang
    };
  } else if (info.file != null) {
    return {
      target: "run-file",
      file: info.file,
      lang: info.lang
    };
  } else {
    return {
      target: "repl",
      lang: info.lang
    };
  }
}
}),
/* --- external:os --- */
"external:os": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
if (typeof require === "function") {
	module.exports = require("os");
} else if (typeof os !== "undefined") {
	module.exports = os;
} else if (typeof Os !== "undefined") {
	module.exports = Os;
} else {
	if ("production" !== "production") {
		console.warn("Failed to load external " + "os" + ". An empty module will be used instead, but this might cause problems in your code. Consider using a custom resolver to shim this external.");
	}
	module.exports = {};
}
}),
/* --- src/inspect-options.ts --- */
"src/inspect-options.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forPrint = exports.forError = void 0;
const forPrint = {
  maxDepth: 8,
  noAmp: true,
  colours: true,
  indent: "  "
};
exports.forPrint = forPrint;
const forError = {
  maxDepth: 1,
  noAmp: true,
  colours: false,
  indent: ""
};
exports.forError = forError;
}),
/* --- src/api/strings.ts --- */
"src/api/strings.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bold = exports.blue = exports.black = exports.bgYellow = exports.bgWhite = exports.bgRed = exports.bgMagenta = exports.bgGreen = exports.bgCyan = exports.bgBlue = exports.bgBlack = void 0;
exports.clear = clear;
exports.strikethrough = exports.reset = exports.red = exports.quote = exports.magenta = exports.italic = exports.inverse = exports.hidden = exports.grey = exports.green = exports.gray = exports.dim = exports.cyan = void 0;
Object.defineProperty(exports, "stripAnsi", {
  enumerable: true,
  get: function () {
    return _stripAnsi.default;
  }
});
exports.yellow = exports.white = exports.underline = void 0;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _kleur = _interopRequireDefault(_kame_require_("node_modules/kleur/index.js"));
var _special = _kame_require_("src/targets/repl/special.ts");
var _stripAnsi = _interopRequireDefault(_kame_require_("node_modules/strip-ansi/index.js"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
_kleur.default.enabled = true;
const quote = str => JSON.stringify(str);
exports.quote = quote;
function clear() {
  std.out.puts("\u001b[2J\u001b[0;0H"); // Clear screen
  std.out.puts("\u001b[3J"); // Clear scrollback
  return _special.NOTHING;
}
const {
  bgBlack,
  bgBlue,
  bgCyan,
  bgGreen,
  bgMagenta,
  bgRed,
  bgWhite,
  bgYellow,
  black,
  blue,
  bold,
  cyan,
  dim,
  gray,
  green,
  grey,
  hidden,
  inverse,
  italic,
  magenta,
  red,
  reset,
  strikethrough,
  underline,
  white,
  yellow
} = _kleur.default;
exports.yellow = yellow;
exports.white = white;
exports.underline = underline;
exports.strikethrough = strikethrough;
exports.reset = reset;
exports.red = red;
exports.magenta = magenta;
exports.italic = italic;
exports.inverse = inverse;
exports.hidden = hidden;
exports.grey = grey;
exports.green = green;
exports.gray = gray;
exports.dim = dim;
exports.cyan = cyan;
exports.bold = bold;
exports.blue = blue;
exports.black = black;
exports.bgYellow = bgYellow;
exports.bgWhite = bgWhite;
exports.bgRed = bgRed;
exports.bgMagenta = bgMagenta;
exports.bgGreen = bgGreen;
exports.bgCyan = bgCyan;
exports.bgBlue = bgBlue;
exports.bgBlack = bgBlack;
}),
/* --- src/api/_installApi.ts --- */
"src/api/_installApi.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = installApi;
var _all = _kame_require_("src/api/commands/_all.ts");
var stubs = _interopRequireWildcard(_kame_require_("src/api/commands/_stubs.ts"));
var _env = _kame_require_("src/api/env.ts");
var _exec = _kame_require_("src/api/exec/index.ts");
var _filesystem = _kame_require_("src/api/filesystem.ts");
var _paths = _kame_require_("src/api/paths.ts");
var _glob = _kame_require_("src/api/glob.ts");
var _is = _kame_require_("src/api/is.ts");
var _repo = _kame_require_("src/api/repo.ts");
var _strings = _kame_require_("src/api/strings.ts");
var _console = _kame_require_("src/api/console.ts");
var _pipe = _kame_require_("src/api/pipe.ts");
var _others = _kame_require_("src/api/others.ts");
var _jsx = _kame_require_("src/api/jsx.ts");
var _csv = _kame_require_("src/api/csv.ts");
var _yaml = _kame_require_("src/api/yaml.ts");
var _traceAll = _interopRequireDefault(_kame_require_("src/api/traceAll.ts"));
var _filenameAnd__dirname = _kame_require_("src/api/__filename-and-__dirname.ts");
var _parseScriptArgs = _interopRequireDefault(_kame_require_("src/api/parse-script-args.ts"));
var _startRepl = _kame_require_("src/api/start-repl.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
// This file has an underscore at the beginning of its name so that it is at
// the top of the list in the text editor's sidebar

function installApi(target) {
  Object.assign(target, {
    cat: _all.cat,
    echo: _all.echo,
    ls: _all.ls,
    readlink: _all.readlink,
    printf: _all.printf,
    env: _env.env,
    exec: _exec.exec,
    $: _exec.$,
    exists: _filesystem.exists,
    isDir: _filesystem.isDir,
    isLink: _filesystem.isLink,
    readFile: _filesystem.readFile,
    remove: _filesystem.remove,
    writeFile: _filesystem.writeFile,
    ensureDir: _filesystem.ensureDir,
    copy: _filesystem.copy,
    cd: _all.cd,
    pwd: _all.pwd,
    realpath: _all.realpath,
    dirname: _all.dirname,
    basename: _all.basename,
    extname: _all.extname,
    paths: _paths.paths,
    glob: _glob.glob,
    is: _is.is,
    isGitignored: _repo.isGitignored,
    repoRoot: _repo.repoRoot,
    quote: _strings.quote,
    clear: _strings.clear,
    stripAnsi: _strings.stripAnsi,
    bgBlack: _strings.bgBlack,
    bgBlue: _strings.bgBlue,
    bgCyan: _strings.bgCyan,
    bgGreen: _strings.bgGreen,
    bgMagenta: _strings.bgMagenta,
    bgRed: _strings.bgRed,
    bgWhite: _strings.bgWhite,
    bgYellow: _strings.bgYellow,
    black: _strings.black,
    blue: _strings.blue,
    bold: _strings.bold,
    cyan: _strings.cyan,
    dim: _strings.dim,
    gray: _strings.gray,
    green: _strings.green,
    grey: _strings.grey,
    hidden: _strings.hidden,
    inverse: _strings.inverse,
    italic: _strings.italic,
    magenta: _strings.magenta,
    red: _strings.red,
    reset: _strings.reset,
    strikethrough: _strings.strikethrough,
    underline: _strings.underline,
    white: _strings.white,
    yellow: _strings.yellow,
    console: _console.console,
    print: _console.print,
    pipe: _pipe.pipe,
    bigint: _others.bigint,
    boolean: _others.boolean,
    number: _others.number,
    string: _others.string,
    symbol: _others.symbol,
    JSX: _jsx.JSX,
    CSV: _csv.CSV,
    YAML: _yaml.YAML,
    traceAll: _traceAll.default,
    parseScriptArgs: _parseScriptArgs.default,
    startRepl: _startRepl.startRepl
  });
  Object.defineProperties(target, {
    __filename: {
      get() {
        return (0, _filenameAnd__dirname.get__filename)(2);
      }
    },
    __dirname: {
      get() {
        return (0, _filenameAnd__dirname.get__dirname)(2);
      }
    }
  });
  for (const [name, stub] of Object.entries(stubs)) {
    Object.defineProperty(target, name, {
      enumerable: false,
      configurable: true,
      get() {
        return stub();
      }
    });
  }
}
}),
/* --- src/extension-handlers/_load-all.ts --- */
"src/extension-handlers/_load-all.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

_kame_require_("src/extension-handlers/coffee.ts");
_kame_require_("src/extension-handlers/empty.ts");
_kame_require_("src/extension-handlers/json.ts");
_kame_require_("src/extension-handlers/jsx.ts");
_kame_require_("src/extension-handlers/ts.ts");
_kame_require_("src/extension-handlers/tsx.ts");
// This file has an underscore at the beginning of its name so that it is at
// the top of the list in the text editor's sidebar

Module.searchExtensions = [".ts", ".tsx", ".coffee", ".jsx", ".js"];
}),
/* --- src/esm-to-require.ts --- */
"src/esm-to-require.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = transform;
// These don't need to be perfect, just enough to make it more convenient
// to do certain things in the repl or eval
const str = /'[^']*'|"[^"]*"/.source;
const optWs = /\s*/.source;
const ident = /[A-Za-z$_][A-Za-z0-9$_]*/.source;
const bareImport = `import${optWs}(${str})`;
const defaultImport = `import${optWs}(${ident})\\s+from${optWs}(${str})`;
const nsImport = `import${optWs}\\*${optWs}as\\s+(${ident})${optWs}from${optWs}(${str})`;
const aliasedNamedSpecifier = `${ident}\\s+as\\s+${ident}`;
const namedSpecifier = `${aliasedNamedSpecifier}|${ident}`;
const namedSpecifierList = `((?:${namedSpecifier}${optWs},?${optWs})+)`;
const namedImport = `import${optWs}\\{${optWs}${namedSpecifierList}${optWs}\\}${optWs}from${optWs}(${str})`;

// only translate bare statements, so we don't munge stuff inside string literals
const stmt = content => `^${optWs}${content}[;\s]*\$`;
const bareImportStmt = new RegExp(stmt(bareImport), "m");
const defaultImportStmt = new RegExp(stmt(defaultImport), "m");
const nsImportStmt = new RegExp(stmt(nsImport), "m");
const namedImportStmt = new RegExp(stmt(namedImport), "m");
const wsAsWs = /\sas\s/;
function transform(expr) {
  let matches = null;
  if (matches = expr.match(bareImportStmt)) {
    return `require(${matches[1]})`;
  } else if (matches = expr.match(defaultImportStmt)) {
    return `${matches[1]} = require(${matches[2]}).default`;
  } else if (matches = expr.match(nsImportStmt)) {
    return `${matches[1]} = require(${matches[2]})`;
  } else if (matches = expr.match(namedImportStmt)) {
    const allSpecifiers = matches[1];
    const source = matches[2];
    const specifiers = allSpecifiers.split(/\s*,\s*/g).map(specifier => specifier.trim()).filter(Boolean);
    const properties = [];
    const bindings = [];
    for (const specifier of specifiers) {
      if (wsAsWs.test(specifier)) {
        const [exportedName, importedName = exportedName] = specifier.split(wsAsWs);
        if (exportedName != null && importedName != null) {
          properties.push(`${exportedName}: ${importedName}`);
          bindings.push(importedName);
        } else {
          // idk what's going on but it's not what I expect.
          // give up on transforming this
          return expr;
        }
      } else {
        properties.push(specifier);
        bindings.push(specifier);
      }
    }
    return `({ ${properties.join(", ")} } = require(${source})); ` + (bindings.length === 1 ? bindings[0] : `({ ${bindings.join(", ")} })`);
  } else {
    return expr;
  }
}
}),
/* --- src/targets/repl/special.ts --- */
"src/targets/repl/special.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOTHING = void 0;
const NOTHING = Symbol("NOTHING");
exports.NOTHING = NOTHING;
}),
/* --- src/langs.ts --- */
"src/langs.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LANGS = void 0;
exports.langToCompiler = langToCompiler;
var _compilers = _interopRequireDefault(_kame_require_("src/compilers.ts"));
const LANGS = new Set(["js", "javascript", "ts", "typescript", "jsx", "tsx", "coffee", "coffeescript"]);
exports.LANGS = LANGS;
function langToCompiler(lang) {
  switch (lang) {
    case "js":
    case "javascript":
      {
        return _compilers.default.js;
      }
    case "ts":
    case "typescript":
      {
        return _compilers.default.ts;
      }
    case "jsx":
      {
        return _compilers.default.jsx;
      }
    case "tsx":
      {
        return _compilers.default.tsx;
      }
    case "coffee":
    case "coffeescript":
      {
        return _compilers.default.coffee;
      }
    default:
      {
        throw new Error(`No compiler for lang: ${lang}`);
      }
  }
}
}),
/* --- src/targets/VERSION_HARDCODED.ts?evalAtBuildTime --- */
"src/targets/VERSION_HARDCODED.ts?evalAtBuildTime": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
module.exports = "git-a50a9c0a4cc7-dirty";
}),
/* --- src/license-text.ts --- */
"src/license-text.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const MIT = `Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.`;
const ISC = `Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.`;
var _default = `Licensing Information

-------------- cutils --------------

C utilities

Copyright (c) 2017 Fabrice Bellard
Copyright (c) 2018 Charlie Gordon

${MIT}

-------------- libbf --------------

Tiny arbitrary precision floating point library

Copyright (c) 2017-2021 Fabrice Bellard

${MIT}

-------------- libregexp --------------

Regular Expression Engine

Copyright (c) 2017-2018 Fabrice Bellard

${MIT}

-------------- libunicode --------------

Unicode utilities

Copyright (c) 2017-2018 Fabrice Bellard

${MIT}

-------------- list --------------

Linux klist like system

Copyright (c) 2016-2017 Fabrice Bellard

${MIT}

-------------- qjsc --------------

QuickJS command line compiler

Copyright (c) 2018-2021 Fabrice Bellard

${MIT}

-------------- quickjs (suchipi fork) --------------

QuickJS Javascript Engine

Copyright (c) 2017-2021 Fabrice Bellard
Copyright (c) 2017-2021 Charlie Gordon
Copyright (c) 2022-2022 Lily Skye

${MIT}

-------------- quickjs-libc (suchipi fork) --------------

QuickJS C library

Copyright (c) 2017-2018 Fabrice Bellard
Copyright (c) 2022-2022 Lily Skye

${MIT}

-------------- qjsbootstrap --------------

QuickJS bootstrap

Built by Lily Skye, using some code generated by qjsc.

Copyright (c) 2022-2022 Lily Skye
Copyright (c) 2017-2021 Fabrice Bellard
Copyright (c) 2017-2021 Charlie Gordon

${MIT}

-------------- quickjs repl --------------

QuickJS Read Eval Print Loop (modified)

Copyright (c) 2017-2020 Fabrice Bellard
Copyright (c) 2017-2020 Charlie Gordon
Copyright (c) 2022 Lily Skye

${MIT}

-------------- @suchipi/print --------------

The ISC License

Copyright (c) 2016-2022, John Gardner
Copyright (c) 2022 Lily Skye

${ISC}

-------------- kleur --------------

The MIT License (MIT)

Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)

${MIT}

-------------- minimatch --------------

The ISC License

Copyright (c) 2011-2022 Isaac Z. Schlueter and Contributors

${ISC}

-------------- brace-expansion --------------

MIT License

Copyright (c) 2013 Julian Gruber <julian@juliangruber.com>

${MIT}

-------------- balanced-match --------------

(MIT)

Copyright (c) 2013 Julian Gruber &lt;julian@juliangruber.com&gt;

${MIT}

-------------- ansi-regex --------------

MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

${MIT}

-------------- strip-ansi --------------

MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

${MIT}

-------------- @suchipi/is --------------

MIT License Copyright (c) 2022 Lily Skye

${MIT}

-------------- coffeescript --------------

Copyright (c) 2009-2018 Jeremy Ashkenas

${MIT}

-------------- lines-and-columns --------------

The MIT License (MIT)

Copyright (c) 2015 Brian Donovan

${MIT}

-------------- sucrase --------------

The MIT License (MIT)

Copyright (c) 2012-2018 various contributors (see AUTHORS)

${MIT}

---

The AUTHORS file for sucrase says:

Direct contributors to the Sucrase project:
Alan Pierce

Sucrase contains a modified fork of Babylon, which itself was forked from Acorn.
Babel and Babylon are copyright 2014-2018 Sebastian McKenzie
See https://babeljs.io/team for a list of contributors to the Babel project.

List of Acorn contributors:
Adrian Rakovsky
Alistair Braidwood
Andres Suarez
Aparajita Fishman
Arian Stolwijk
Artem Govorov
Brandon Mills
Charles Hughes
Conrad Irwin
David Bonnet
Forbes Lindesay
Gilad Peleg
impinball
Ingvar Stepanyan
Jesse McCarthy
Jiaxing Wang
Joel Kemp
Johannes Herr
Jrg Lehni
keeyipchan
Kevin Kwok
krator
Marijn Haverbeke
Martin Carlberg
Mathias Bynens
Mathieu 'p01' Henri
Max Schaefer
Max Zerzouri
Mihai Bazon
Mike Rennie
Nick Fitzgerald
Oskar Schldstrm
Paul Harper
Peter Rust
PlNG
r-e-d
Rich Harris
Sebastian McKenzie
zsjforcn

-------------- clef-parse --------------

MIT License

Copyright (c) 2022 Lily Skye

${MIT}

-------------- papaparse --------------

MIT License

Copyright (c) 2015 Matthew Holt

${MIT}

-------------- yaml (npm package) --------------

The ISC License

Copyright Eemeli Aro <eemeli@gmail.com>

${ISC}

-------------- yavascript --------------

YavaScript script interpreter

MIT License

Copyright (c) 2022 Lily Skye

${MIT}
`;
exports.default = _default;
}),
/* --- dist/yavascript.d.ts?contentString --- */
"dist/yavascript.d.ts?contentString": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
module.exports = "// ===============\n// ---------------\n// YavaScript APIs\n// ---------------\n// ===============\n/**\n * An object representing the process's environment variables. You can read\n * from it to read environment variables, write into it to set environment\n * variables, and/or delete properties from it to unset environment variables.\n * Any value you write will be coerced into a string.\n */\ndeclare const env: { [key: string]: string | undefined };\n\n/**\n * Parse command line --flags into an object of flags and an array of\n * positional arguments. This function is opinionated; if it doesn't meet your\n * needs, you can parse the `scriptArgs` global manually.\n *\n * Flags `--like-this`, `--like_this`, or `--LIKE_THIS` get converted into\n * property names `likeThis` on the returned flags object.\n *\n * Flags like this: `-v` get converted into into property names like this: `v`\n * on the returned flags object.\n *\n * Anything that appears after `--` is considered a positional argument instead\n * of a flag. `--` is not present in the returned positional arguments Array.\n *\n * Single-character flags must have a single leading dash, and multi-character\n * flags must have two leading dashes.\n *\n * Flags with equals signs in them (eg. `--something=42`) are not supported.\n * Write `--something 42` instead.\n *\n * Flags where you specify them multiple times, like `-vvv`, are not supported.\n * Write something like `-v 3` instead.\n *\n * @param hints - An object whose keys are flag names (in camelCase) and whose values indicate what type to treat that flag as. Valid property values are `String`, `Boolean`, `Number`, and `parseScriptArgs.Path`. `parseScriptArgs.Path` will resolve relative paths into absolute paths for you. If no hints object is specified, `parseScriptArgs` will do its best to guess, based on the command-line args.\n * @param argv - An array containing the command line flags you want to parse. If unspecified, `scriptArgs.slice(2)` will be used (we slice 2 in order to skip the yavascript binary and script name). If you pass in an array here, it should only contain command-line flags, not the binary being called.\n *\n * @returns An object with two properties: `flags` and `args`. `flags` is an object whose keys are camelCase flag names and whose values are strings, booleans, or numbers corresponding to the input command-line args. `args` is an Array of positional arguments, as found on the command-line.\n */\ndeclare const parseScriptArgs: {\n  /**\n   * Parse command line --flags into an object of flags and an array of\n   * positional arguments. This function is opinionated; if it doesn't meet your\n   * needs, you can parse the `scriptArgs` global manually.\n   *\n   * Flags `--like-this`, `--like_this`, or `--LIKE_THIS` get converted into\n   * property names `likeThis` on the returned flags object.\n   *\n   * Flags like this: `-v` get converted into into property names like this: `v`\n   * on the returned flags object.\n   *\n   * Anything that appears after `--` is considered a positional argument instead\n   * of a flag. `--` is not present in the returned positional arguments Array.\n   *\n   * Single-character flags must have a single leading dash, and multi-character\n   * flags must have two leading dashes.\n   *\n   * Flags with equals signs in them (eg. `--something=42`) are not supported.\n   * Write `--something 42` instead.\n   *\n   * Flags where you specify them multiple times, like `-vvv`, are not supported.\n   * Write something like `-v 3` instead.\n   *\n   * @param hints - An object whose keys are flag names (in camelCase) and whose values indicate what type to treat that flag as. Valid property values are `String`, `Boolean`, `Number`, and `parseScriptArgs.Path`. `parseScriptArgs.Path` will resolve relative paths into absolute paths for you. If no hints object is specified, `parseScriptArgs` will do its best to guess, based on the command-line args.\n   * @param args - An array containing the command line flags you want to parse. If unspecified, `scriptArgs.slice(2)` will be used (we slice 2 in order to skip the yavascript binary and script name). If you pass in an array here, it should only contain command-line flags, not the binary being called.\n   *\n   * @returns An object with two properties: `flags` and `args`. `flags` is an object whose keys are camelCase flag names and whose values are strings, booleans, or numbers corresponding to the input command-line args. `args` is an Array of positional arguments, as found on the command-line.\n   */\n  (\n    hints?: {\n      [key: string]:\n        | typeof String\n        | typeof Boolean\n        | typeof Number\n        | typeof parseScriptArgs[\"Path\"];\n    },\n    args?: Array<string>\n  ): {\n    flags: { [key: string]: any };\n    args: Array<string>;\n  };\n\n  /**\n   * A hint value for {@link parseScriptArgs}. Behaves similar to the hint value\n   * `String`, except that it also resolves relative paths into absolute paths,\n   * using the following rules:\n   *\n   * - paths `./like/this` or `../like/this` get resolved relative to `pwd()`.\n   * - paths `like/this` or `this` get resolved relative to `pwd()` as if they had a leading `./`.\n   */\n  readonly Path: unique symbol;\n};\n\n/**\n * Read the contents of a file from disk, as a UTF-8 string.\n */\ndeclare function readFile(path: string): string;\n\n/**\n * Write the contents of a string or ArrayBuffer to a file.\n *\n * Strings are written using the UTF-8 encoding.\n */\ndeclare function writeFile(path: string, data: string | ArrayBuffer): void;\n\n/**\n * Function which returns true if the path points to a directory, or if the\n * path points to a symlink which points to a directory. Otherwise, it returns\n * false.\n */\ninterface IsDir {\n  /**\n   * Returns true if the path points to a directory, or if the path points to\n   * a symlink which points to a directory. Otherwise, returns false.\n   */\n  (path: string): boolean;\n\n  /**\n   * Maximum number of symlinks to follow before erroring. Defaults to 100.\n   */\n  symlinkLimit: number;\n}\n\n/**\n * Function which returns true if the path points to a directory, or if the\n * path points to a symlink which points to a directory. Otherwise, it returns\n * false.\n */\ndeclare const isDir: IsDir;\n\n/**\n * Returns true if the path points to a symlink.\n */\ndeclare function isLink(path: string): boolean;\n\n/**\n * Delete the file or directory at the specified path.\n *\n * If the directory isn't empty, its contents will be deleted, too.\n *\n * Provides the same functionality as the command `rm -rf`.\n */\ndeclare function remove(path: string): void;\n\n/**\n * Returns true if a file or directory exists at the specified path.\n *\n * Provides the same functionality as the command `test -e`.\n */\ndeclare function exists(path: string): boolean;\n\n/**\n * Create directories for each of the provided path components,\n * if they don't already exist.\n *\n * Provides the same functionality as the command `mkdir -p`.\n */\ndeclare function ensureDir(path: string): string;\n\n/**\n * Options for {@link copy}.\n */\ndeclare type CopyOptions = {\n  /**\n   * What to do when attempting to copy something into a location where\n   * something else already exists.\n   *\n   * Defaults to \"error\".\n   */\n  whenTargetExists?: \"overwrite\" | \"skip\" | \"error\";\n\n  /**\n   * If provided, this function will be called multiple times as `copy`\n   * traverses the filesystem, to help you understand what's going on and/or\n   * troubleshoot things. In most cases, it makes sense to use a logging\n   * function here, like so:\n   *\n   * ```js\n   * copy(\"./source\", \"./destination\", { trace: console.log });\n   * ```\n   */\n  trace?: (...args: Array<any>) => void;\n};\n\n/**\n * Copy a file or folder from one location to another.\n * Folders are copied recursively.\n *\n * Provides the same functionality as the command `cp -R`.\n */\ndeclare function copy(from: string, to: string, options?: CopyOptions): void;\n\n/**\n * A namespace object providing several path-string-related APIs.\n */\ndeclare const paths: {\n  /**\n   * The separator character the host operating system uses between path\n   * components, ie. the slashes in a filepath. On windows, it's a backslash, and\n   * on all other OSes, it's a forward slash.\n   */\n  OS_PATH_SEPARATOR: \"/\" | \"\\\\\";\n\n  /**\n   * Split a path string (or array of path strings) on / or \\\\, returning an\n   * Array of strings.\n   *\n   * Trailing slashes and duplicate path separators will be removed.\n   *\n   * If the path starts with `/`, the first string in the Array will be empty.\n   */\n  split(path: string | Array<string>): Array<string>;\n\n  /**\n   * Detect which path separator is present in the given path or array of\n   * paths: `\\` or `/`.\n   *\n   * If neither is present, `/` will be returned.\n   */\n  detectSeparator(input: string | Array<string>): string;\n\n  /**\n   * Create a path string from one or more path or path component strings.\n   * {@link paths.OS_PATH_SEPARATOR} will be used to combine parts.\n   *\n   * This function does not resolve `..` or `.`. Use {@link paths.resolve} for that.\n   */\n  join(...parts: Array<string>): string;\n\n  /**\n   * Resolves all `..` and `.` components in a path, returning an absolute\n   * path.\n   *\n   * Use `from` to specify where leading `.` or `..` characters should be\n   * resolved relative to. If unspecified, it defaults to `pwd()`.\n   */\n  resolve(path: string, from?: string): string;\n\n  /**\n   * Returns whether the path starts with either a leading slash or a windows\n   * drive letter.\n   */\n  isAbsolute(path: string): boolean;\n};\n\n/**\n * The absolute path to the current file (whether script or module).\n *\n * Behaves the same as in Node.js, except that it's present within ES modules.\n */\ndeclare const __filename: string;\n\n/**\n * The absolute path to the directory the current file is inside of.\n *\n * Behaves the same as in Node.js, except that it's present within ES modules.\n */\ndeclare const __dirname: string;\n\n/**\n * Return the last component of a path string.\n *\n * Provides the same functionality as the unix binary of the same name.\n */\ndeclare function basename(path: string): string;\n\n/**\n * Read the contents of one of more files from disk as one UTF-8 string,\n * print that string to stdout, then return it.\n */\ndeclare function cat(...paths: Array<string>): string;\n\n/**\n * Change the process's current working directory to the specified path. If no\n * path is specified, moves to the user's home directory.\n *\n * Provides the same functionality as the shell builtin of the same name.\n */\ndeclare function cd(path?: string): void;\n\n/**\n * Removes the final component from a path string.\n *\n * Provides the same functionality as the unix binary of the same name.\n */\ndeclare function dirname(path: string): string;\n\n/**\n * Print one or more values to stdout.\n */\ndeclare const echo: typeof console.log;\n\n/**\n * Returns the file extension of the file at a given path.\n *\n * If the file has no extension (eg `Makefile`, etc), then `''` will be returned.\n *\n * Pass `{ full: true }` to get compound extensions, eg `.d.ts` or `.test.js` instead of just `.ts`/`.js`.\n */\ndeclare function extname(\n  pathOrFilename: string,\n  options?: { full?: boolean }\n): string;\n\n/**\n * Return the contents of a directory, as absolute paths. `.` and `..` are\n * omitted.\n *\n * Use the `relativePaths` option to get relative paths instead (relative to\n * the parent directory).\n */\ndeclare function ls(\n  dir?: string,\n  options?: { relativePaths?: boolean }\n): Array<string>;\n\n/**\n * Print data to stdout using C-style format specifiers.\n */\ndeclare function printf(format: string, ...args: Array<any>): void;\n\n/**\n * Return the process's current working directory.\n *\n * Provides the same functionality as the shell builtin of the same name.\n */\ndeclare function pwd(): string;\n\n/**\n * Read a symlink.\n *\n * Returns the target of the symlink, which may be absolute or relative.\n *\n * Provides the same functionality as the unix binary of the same name.\n */\ndeclare function readlink(path: string): string;\n\n/**\n * Get the absolute path given a relative path. Symlinks are also resolved.\n *\n * The path's target file/directory must exist.\n *\n * Provides the same functionality as the unix binary of the same name.\n */\ndeclare function realpath(path: string): string;\n\ndeclare type BaseExecOptions = {\n  /** Sets the current working directory for the child process. */\n  cwd?: string;\n\n  /** Sets environment variables within the process. */\n  env?: { [key: string | number]: string | number | boolean };\n\n  /**\n   * If provided, this function will be called multiple times as `exec`\n   * runs, to help you understand what's going on and/or troubleshoot things.\n   * In most cases, it makes sense to use a logging function here, like so:\n   *\n   * ```js\n   * exec([\"echo\", \"hi\"], { trace: console.log });\n   * ```\n   */\n  trace?: (...args: Array<any>) => void;\n};\n\ndeclare interface Exec {\n  (args: Array<string> | string): void;\n\n  (args: Array<string> | string, options: Record<string, never>): void;\n\n  (\n    args: Array<string> | string,\n    options: BaseExecOptions & {\n      /**\n       * Whether an Error should be thrown when the process exits with a nonzero\n       * status code.\n       *\n       * Defaults to true.\n       */\n      failOnNonZeroStatus: true;\n      /**\n       * If true, stdout and stderr will be collected into strings and returned\n       * instead of being printed to the screen.\n       *\n       * Defaults to false.\n       */\n      captureOutput: false;\n    }\n  ): void;\n\n  (\n    args: Array<string> | string,\n    options: BaseExecOptions & {\n      /**\n       * Whether an Error should be thrown when the process exits with a nonzero\n       * status code.\n       *\n       * Defaults to true.\n       */\n      failOnNonZeroStatus: false;\n      /**\n       * If true, stdout and stderr will be collected into strings and returned\n       * instead of being printed to the screen.\n       *\n       * Defaults to false.\n       */\n      captureOutput: false;\n    }\n  ):\n    | { status: number; signal: undefined }\n    | { status: undefined; signal: number };\n\n  (\n    args: Array<string> | string,\n    options: BaseExecOptions & {\n      /**\n       * Whether an Error should be thrown when the process exits with a nonzero\n       * status code.\n       *\n       * Defaults to true.\n       */\n      failOnNonZeroStatus: false;\n    }\n  ):\n    | { status: number; signal: undefined }\n    | { status: undefined; signal: number };\n\n  (\n    args: Array<string> | string,\n    options: BaseExecOptions & {\n      /**\n       * Whether an Error should be thrown when the process exits with a nonzero\n       * status code.\n       *\n       * Defaults to true.\n       */\n      failOnNonZeroStatus: true;\n      /**\n       * If true, stdout and stderr will be collected into strings and returned\n       * instead of being printed to the screen.\n       *\n       * Defaults to false.\n       */\n      captureOutput: true;\n    }\n  ): { stdout: string; stderr: string };\n\n  (\n    args: Array<string> | string,\n    options: BaseExecOptions & {\n      /**\n       * If true, stdout and stderr will be collected into strings and returned\n       * instead of being printed to the screen.\n       *\n       * Defaults to false.\n       */\n      captureOutput: true;\n    }\n  ): { stdout: string; stderr: string };\n\n  (\n    args: Array<string> | string,\n    options: BaseExecOptions & {\n      /**\n       * Whether an Error should be thrown when the process exits with a nonzero\n       * status code.\n       *\n       * Defaults to true.\n       */\n      failOnNonZeroStatus: false;\n      captureOutput: true;\n    }\n  ):\n    | { stdout: string; stderr: string; status: number; signal: undefined }\n    | { stdout: string; stderr: string; status: undefined; signal: number };\n}\n\n/** Run a child process using the provided arguments. The first value in the arguments array is the program to run. */\ndeclare const exec: Exec;\n\n/** Alias for `exec(args, { captureOutput: true })` */\ndeclare function $(args: Array<string> | string): {\n  stdout: string;\n  stderr: string;\n};\n\n/**\n * Options for {@link glob}.\n */\ndeclare type GlobOptions = {\n  /**\n   * Whether to treat symlinks to directories as if they themselves were\n   * directories, traversing into them.\n   *\n   * Defaults to false.\n   */\n  followSymlinks?: boolean;\n\n  /**\n   * If provided, this function will be called multiple times as `glob`\n   * traverses the filesystem, to help you understand what's going on and/or\n   * troubleshoot things. In most cases, it makes sense to use a logging\n   * function here, like so:\n   *\n   * ```js\n   * glob([\"./*.js\"], { trace: console.log });\n   * ```\n   */\n  trace?: (...args: Array<any>) => void;\n\n  /**\n   * Directory to interpret glob patterns relative to. Defaults to `pwd()`.\n   */\n  dir?: string;\n};\n\n/**\n * Search the filesystem for files matching the specified glob patterns.\n *\n * Uses [minimatch](https://www.npmjs.com/package/minimatch) with its default\n * options.\n */\ndeclare function glob(\n  patterns: string | Array<string>,\n  options?: GlobOptions\n): Array<string>;\n\n/**\n * Remove ANSI control characters from a string.\n */\ndeclare function stripAnsi(input: string): string;\n\n/**\n * Wrap a string in double quotes, and escape any double-quotes inside using `\\\"`.\n */\ndeclare function quote(input: string): string;\n\n/**\n * Clear the contents and scrollback buffer of the tty by printing special characters into stdout.\n */\ndeclare function clear(): void;\n\n// Colors\n\n/** Wrap a string with the ANSI control characters that will make it print as black text. */\ndeclare function black(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as red text. */\ndeclare function red(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as green text. */\ndeclare function green(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as yellow text. */\ndeclare function yellow(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as blue text. */\ndeclare function blue(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as magenta text. */\ndeclare function magenta(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as cyan text. */\ndeclare function cyan(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as white text. */\ndeclare function white(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as gray text. */\ndeclare function gray(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print as grey text. */\ndeclare function grey(input: string | number): string;\n\n// Background Colors\n\n/** Wrap a string with the ANSI control characters that will make it have a black background. */\ndeclare function bgBlack(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it have a red background. */\ndeclare function bgRed(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it have a green background. */\ndeclare function bgGreen(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it have a yellow background. */\ndeclare function bgYellow(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it have a blue background. */\ndeclare function bgBlue(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it have a magenta background. */\ndeclare function bgMagenta(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it have a cyan background. */\ndeclare function bgCyan(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it have a white background. */\ndeclare function bgWhite(input: string | number): string;\n\n// Modifiers\n\n/** Wrap a string with the ANSI control character that resets all styling. */\ndeclare function reset(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print with a bold style. */\ndeclare function bold(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print with a dimmed style. */\ndeclare function dim(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print italicized. */\ndeclare function italic(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print underlined. */\ndeclare function underline(input: string | number): string;\n/** Wrap a string with ANSI control characters such that its foreground (text) and background colors are swapped. */\ndeclare function inverse(input: string | number): string;\n/** Wrap a string with ANSI control characters such that it is hidden. */\ndeclare function hidden(input: string | number): string;\n/** Wrap a string with the ANSI control characters that will make it print with a horizontal line through its center. */\ndeclare function strikethrough(input: string | number): string;\n\ndeclare type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array;\ndeclare type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\ndeclare const is: {\n  string(value: any): value is string;\n  String(value: any): value is string;\n  number(value: any): value is number;\n  Number(value: any): value is number;\n  boolean(value: any): value is boolean;\n  Boolean(value: any): value is boolean;\n  bigint(value: any): value is bigint;\n  BigInt(value: any): value is BigInt;\n  symbol(value: any): value is symbol;\n  Symbol(value: any): value is symbol;\n  null(value: any): value is null;\n  undefined(value: any): value is undefined;\n  void(value: any): value is null | undefined;\n  object(value: any): value is {\n    [key: string]: unknown;\n    [key: number]: unknown;\n    [key: symbol]: unknown;\n  };\n  Object(value: any): value is {\n    [key: string]: unknown;\n    [key: number]: unknown;\n    [key: symbol]: unknown;\n  };\n  Array(value: any): value is unknown[];\n  function(value: any): value is Function & {\n    [key: string]: unknown;\n    [key: number]: unknown;\n    [key: symbol]: unknown;\n  };\n  Function(value: any): value is Function & {\n    [key: string]: unknown;\n    [key: number]: unknown;\n    [key: symbol]: unknown;\n  };\n  tagged(value: any, tag: string): boolean;\n  instanceOf<T>(value: any, klass: new (...args: any) => T): value is T;\n  Error(value: any): value is Error;\n  Infinity(value: any): value is number;\n  NegativeInfinity(value: any): value is number;\n  NaN(value: any): value is number;\n  Date(value: any): value is Date;\n  RegExp(value: any): value is RegExp;\n  Map(value: any): value is Map<unknown, unknown>;\n  Set(value: any): value is Set<unknown>;\n  WeakMap(value: any): value is Map<unknown, unknown>;\n  WeakSet(value: any): value is Set<unknown>;\n  ArrayBuffer(value: any): value is ArrayBuffer;\n  SharedArrayBuffer(value: any): value is SharedArrayBuffer;\n  DataView(value: any): value is DataView;\n  TypedArray(value: any): value is TypedArray;\n  Int8Array(value: any): value is Int8Array;\n  Uint8Array(value: any): value is Uint8Array;\n  Uint8ClampedArray(value: any): value is Uint8ClampedArray;\n  Int16Array(value: any): value is Int16Array;\n  Uint16Array(value: any): value is Uint16Array;\n  Int32Array(value: any): value is Int32Array;\n  Uint32Array(value: any): value is Uint32Array;\n  Float32Array(value: any): value is Float32Array;\n  Float64Array(value: any): value is Float64Array;\n  Promise(value: any): value is Promise<unknown>;\n  Generator(value: any): value is Generator<unknown, any, unknown>;\n  GeneratorFunction(value: any): value is GeneratorFunction;\n  AsyncFunction(value: any): value is ((...args: any) => Promise<unknown>) & {\n    [key: string]: unknown;\n    [key: number]: unknown;\n    [key: symbol]: unknown;\n  };\n  AsyncGenerator(value: any): value is AsyncGenerator<unknown, any, unknown>;\n  AsyncGeneratorFunction(value: any): value is AsyncGeneratorFunction;\n\n  FILE(value: any): value is FILE;\n\n  JSX: {\n    /** Returns whether `value` is a JSX Element object as created via JSX syntax. */\n    Element(value: any): value is JSX.Element;\n    /** Returns whether `value` is a JSX fragment element as created via JSX syntax. */\n    Fragment(value: any): value is JSX.Fragment;\n  };\n};\n\n/**\n * The data source of a pipe operation; either an in-memory object, or a\n * file stream.\n *\n * - Use `maxLength` to limit how much data to read.\n * - Use `until` to stop reading once a certain byte or character has been\n *   read.\n * - Use `path` or `fd` to open a file.\n */\ndeclare type PipeSource =\n  | { data: string; maxLength?: number; until?: string | byte }\n  | ArrayBuffer\n  | { data: ArrayBuffer; maxLength?: number; until?: string | byte }\n  | SharedArrayBuffer\n  | { data: SharedArrayBuffer; maxLength?: number; until?: string | byte }\n  | TypedArray\n  | { data: TypedArray; maxLength?: number; until?: string | byte }\n  | DataView\n  | { data: DataView; maxLength?: number; until?: string | byte }\n  | FILE\n  | {\n      data: FILE;\n      maxLength?: number;\n      until?: string | byte;\n    }\n  | { path: string; maxLength?: number; until?: string | byte }\n  | { fd: number; maxLength?: number; until?: string | byte };\n\n/**\n * The target destination of a pipe operation; either an in-memory object, or a\n * file stream.\n *\n * - Use `intoExisting` to put data into an existing object or file handle.\n * - Use `intoNew` to put data into a new object.\n * - Use `path` or `fd` to create a new file handle and put data into it.\n */\ndeclare type PipeDestination =\n  | ArrayBuffer\n  | SharedArrayBuffer\n  | DataView\n  | TypedArray\n  | FILE\n  | ArrayBufferConstructor\n  | SharedArrayBufferConstructor\n  | DataViewConstructor\n  | TypedArrayConstructor\n  | StringConstructor\n  | { path: string }\n  | { fd: number };\n\n/**\n * Copy data from one source into the given target. Returns the number of bytes\n * written, and the target that data was written into.\n */\ndeclare function pipe<Dest extends PipeDestination>(\n  from: PipeSource,\n  to: Dest\n): {\n  bytesTransferred: number;\n  target: Dest extends\n    | ArrayBuffer\n    | SharedArrayBuffer\n    | DataView\n    | FILE\n    | { path: string }\n    | { fd: number }\n    ? Dest\n    : Dest extends\n        | ArrayBufferConstructor\n        | SharedArrayBufferConstructor\n        | DataViewConstructor\n        | TypedArrayConstructor\n        | DataViewConstructor\n    ? Dest[\"prototype\"]\n    : Dest extends StringConstructor\n    ? string\n    : never;\n};\n\n/**\n * Launch the Yavascript REPL (read-eval-print-loop).\n *\n * @param context Variables to make available as globals within the repl.\n * @param lang The langauge to use in the repl. Defaults to \"javascript\".\n */\ndeclare function startRepl(\n  context?: { [key: string]: any },\n  lang?:\n    | \"js\"\n    | \"javascript\"\n    | \"ts\"\n    | \"typescript\"\n    | \"jsx\"\n    | \"tsx\"\n    | \"coffee\"\n    | \"coffeescript\"\n): void;\n\n/**\n * Returns the absolute path to the root folder of the git/hg repo.\n *\n * This is done by running `git rev-parse --show-toplevel` and `hg root`.\n *\n * If `relativeTo` is provided, the git and hg commands will be executed in\n * that folder instead of in `pwd()`.\n */\ndeclare function repoRoot(relativeTo?: string): string;\n\n/**\n * Returns whether the provided path is ignored by git.\n */\ndeclare function isGitignored(path: string): boolean;\n\n/**\n * Configures the default value of `trace` in functions which receive `trace`\n * as an option.\n *\n * - If called with `true`, the default value of `trace` in all functions which\n *   receive a `trace` option will be changed to `console.error`.\n * - If called with `false`, the default value of `trace` in all functions which\n *   receive a `trace` option will be changed to `undefined`.\n * - If called with any other value, the provided value will be used as the\n *   default value of `trace` in all functions which receive a `trace` option.\n *\n * If you would like to make your own functions use the default value of\n * `trace` as set by this function (in order to get the same behavior as\n * yavascript API functions which do so), call `traceAll.getDefaultTrace()` to\n * get the value which should be used as the default value.\n */\ndeclare const traceAll: ((\n  trace: boolean | undefined | ((...args: Array<any>) => void)\n) => void) & {\n  getDefaultTrace(): ((...args: Array<any>) => void) | undefined;\n};\n\ndeclare namespace JSX {\n  /**\n   * A string containing the expression that should be called to create JSX\n   * elements.\n   *\n   * Defaults to \"JSX.createElement\".\n   *\n   * If changed, any JSX code loaded afterwards will use a different\n   * expression.\n   *\n   * Note that if you change this, you need to verify that the following\n   * expression always evaluates to `true` (by changing {@link is.JSX.Element}\n   * and {@link is.JSX.Fragment}):\n   * ```jsx\n   * is.JSX.Element(<a />) && is.JSX.Fragment(<></>)\n   * ```\n   *\n   * Failure to uphold this guarantee indicates a bug.\n   */\n  export let pragma: string;\n\n  /**\n   * A string containing the expression that should be used as the first\n   * parameter when creating JSX fragment elements.\n   *\n   * Defaults to \"JSX.Fragment\".\n   *\n   * If changed, any JSX code loaded afterwards will use a different\n   * expression.\n   *\n   * Note that if you change this, you need to verify that the following\n   * expression always evaluates to `true` (by changing {@link is.JSX.Element}\n   * and {@link is.JSX.Fragment}):\n   * ```jsx\n   * is.JSX.Element(<a />) && is.JSX.Fragment(<></>)\n   * ```\n   *\n   * Failure to uphold this guarantee indicates a bug.\n   */\n  export let pragmaFrag: string;\n\n  export const Element: unique symbol;\n\n  export interface Element<\n    Props = { [key: string | symbol | number]: any },\n    Type = any\n  > {\n    $$typeof: typeof Element;\n    type: Type;\n    props: Props;\n    key: string | number | null;\n  }\n\n  /**\n   * The value which gets passed into the JSX element constructor (as\n   * determined by {@link JSX.pragma}) when JSX fragment syntax is used (unless\n   * {@link JSX.pragmaFrag} is changed).\n   */\n  export const Fragment: unique symbol;\n\n  export type Fragment = Element<{}, typeof Fragment>;\n\n  /**\n   * The JSX element constructor, which gets invoked whenever JSX syntax is\n   * used (unless {@link JSX.pragma} is changed).\n   */\n  export const createElement: {\n    <Type extends string | typeof Fragment | ((...args: any) => any)>(\n      type: Type\n    ): Element<{}, Type>;\n    <\n      Type extends string | typeof Fragment | ((...args: any) => any),\n      Props extends { [key: string | number | symbol]: any }\n    >(\n      type: Type,\n      props: Props\n    ): Element<Props, Type>;\n\n    <\n      Type extends string | typeof Fragment | ((...args: any) => any),\n      Props extends { [key: string | number | symbol]: any },\n      Children extends Array<any>\n    >(\n      type: Type,\n      props: Props,\n      ...children: Children\n    ): Element<Props & { children: Children }, Type>;\n\n    <\n      Type extends string | typeof Fragment | ((...args: any) => any),\n      Children extends Array<any>\n    >(\n      type: Type,\n      ...children: Children\n    ): Element<{ children: Children }, Type>;\n  };\n}\n\ndeclare const YAML: {\n  /**\n   * Parse a YAML document (`input`) into a JSON-compatible value.\n   */\n  parse(\n    input: string,\n    reviver?: (this: any, key: string, value: any) => any\n  ): any;\n\n  /**\n   * Convert a JSON-compatible value into a YAML document.\n   */\n  stringify(\n    input: any,\n    replacer?:\n      | ((this: any, key: string, value: any) => any)\n      | (number | string)[]\n      | null,\n    indent?: number\n  ): string;\n};\n\ndeclare const CSV: {\n  /**\n   * Parse a CSV string into an Array of Arrays of strings.\n   *\n   * The outer array holds the rows, and the inner arrays hold the items in\n   * each row.\n   */\n  parse(input: string): Array<Array<string>>;\n\n  /**\n   * Convert an Array of Arrays of strings into a CSV string.\n   *\n   * The outer array holds the rows, and the inner arrays hold the items in\n   * each row.\n   */\n  stringify(input: Array<Array<string>>): string;\n};\n\n// prettier-ignore\n/** Any integer in the range [0, 255]. */\ndeclare type byte =\n|   0 |   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 |  11 |  12 |  13 |  14 |  15 \n|  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 \n|  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 \n|  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  56 |  57 |  58 |  59 |  60 |  61 |  62 |  63 \n|  64 |  65 |  66 |  67 |  68 |  69 |  70 |  71 |  72 |  73 |  74 |  75 |  76 |  77 |  78 |  79 \n|  80 |  81 |  82 |  83 |  84 |  85 |  86 |  87 |  88 |  89 |  90 |  91 |  92 |  93 |  94 |  95 \n|  96 |  97 |  98 |  99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 \n| 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 | 125 | 126 | 127 \n| 128 | 129 | 130 | 131 | 132 | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140 | 141 | 142 | 143 \n| 144 | 145 | 146 | 147 | 148 | 149 | 150 | 151 | 152 | 153 | 154 | 155 | 156 | 157 | 158 | 159 \n| 160 | 161 | 162 | 163 | 164 | 165 | 166 | 167 | 168 | 169 | 170 | 171 | 172 | 173 | 174 | 175 \n| 176 | 177 | 178 | 179 | 180 | 181 | 182 | 183 | 184 | 185 | 186 | 187 | 188 | 189 | 190 | 191 \n| 192 | 193 | 194 | 195 | 196 | 197 | 198 | 199 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 \n| 208 | 209 | 210 | 211 | 212 | 213 | 214 | 215 | 216 | 217 | 218 | 219 | 220 | 221 | 222 | 223 \n| 224 | 225 | 226 | 227 | 228 | 229 | 230 | 231 | 232 | 233 | 234 | 235 | 236 | 237 | 238 | 239 \n| 240 | 241 | 242 | 243 | 244 | 245 | 246 | 247 | 248 | 249 | 250 | 251 | 252 | 253 | 254 | 255;\n\n// Convenience aliases to provide parity with TypeScript types.\ndeclare var number: NumberConstructor;\ndeclare var string: StringConstructor;\ndeclare var boolean: BooleanConstructor;\ndeclare var bigint: BigIntConstructor;\ndeclare var symbol: SymbolConstructor;\n\n// ==========================================\n// ------------------------------------------\n// QuickJS APIs, which YavaScript builds upon\n// ------------------------------------------\n// ==========================================\n// Definitions of the globals and modules added by quickjs-libc\n\n/**\n * Provides the command line arguments. The first argument is the script name.\n */\ndeclare var scriptArgs: Array<string>;\n\n/**\n * Print the arguments separated by spaces and a trailing newline.\n *\n * Non-string args are coerced into a string via [ToString](https://tc39.es/ecma262/#sec-tostring).\n * Objects can override the default `ToString` behavior by defining a `toString` method.\n */\ndeclare var print: (...args: Array<any>) => void;\n\n/**\n * Object that provides functions for logging information.\n */\ndeclare var console: {\n  /** Same as {@link print}(). */\n  log: typeof print;\n\n  /** Same as {@link print}(). */\n  warn: typeof print;\n\n  /** Same as {@link print}(). */\n  error: typeof print;\n\n  /** Same as {@link print}(). */\n  info: typeof print;\n};\n\n/** An object representing a file handle. */\ndeclare interface FILE {\n  /**\n   * Human-readable description of where this FILE points.\n   *\n   * If `target` is a number, the FILE was opened with fdopen, and `target` is\n   * the fd. Otherwise, `target` will be an arbitrary string that describes the\n   * file; it may be the absolute path to the file, the relative path to the\n   * file at time of its opening, or some other string like \"stdin\" or\n   * \"tmpfile\".\n   *\n   * You should *not* use this property for anything other than logging and\n   * debugging. It is *only* provided for debugging and/or troubleshooting\n   * purposes. The value of this property could change at any time when\n   * upgrading yavascript, even if upgrading by a minor or patch release.\n   */\n  target: string | number;\n\n  /**\n   * Close the file handle. Note that for files other than stdin/stdout/stderr,\n   * the file will be closed automatically when the `FILE` object is\n   * garbage-collected.\n   */\n  close(): void;\n\n  /** Outputs the string with the UTF-8 encoding. */\n  puts(...strings: Array<string>): void;\n\n  /**\n   * Formatted printf.\n   *\n   * The same formats as the standard C library `printf` are supported. Integer format types (e.g. `%d`) truncate the Numbers or BigInts to 32 bits. Use the `l` modifier (e.g. `%ld`) to truncate to 64 bits.\n   */\n  printf(fmt: string, ...args: Array<any>): void;\n\n  /** Flush the buffered file. Wrapper for C `fflush`. */\n  flush(): void;\n\n  /** Sync the buffered file to disk. Wrapper for C `fsync`. */\n  sync(): void;\n\n  /**\n   * Seek to a given file position (whence is `std.SEEK_*`).\n   *\n   * `offset` can be a number or a bigint.\n   */\n  seek(offset: number, whence: number): void;\n\n  /** Return the current file position. */\n  tell(): number;\n\n  /** Return the current file position as a bigint. */\n  tello(): BigInt;\n\n  /** Return true if end of file. */\n  eof(): boolean;\n\n  /** Return the associated OS handle. */\n  fileno(): number;\n\n  /** Read `length` bytes from the file to the ArrayBuffer `buffer` at byte position `position` (wrapper to the libc `fread`). Returns the number of bytes read, or `0` if the end of the file has been reached.  */\n  read(buffer: ArrayBuffer, position: number, length: number): number;\n\n  /** Write `length` bytes from the ArrayBuffer `buffer` at byte position `position` into the file (wrapper to the libc `fwrite`). Returns the number of bytes written. */\n  write(buffer: ArrayBuffer, position: number, length: number): number;\n\n  /**\n   * Return the next line from the file, assuming UTF-8 encoding, excluding the trailing line feed or EOF.\n   *\n   * If the end of the file has been reached, then `null` will be returned instead of a string.\n   *\n   * Note: Although the trailing line feed has been removed, a carriage return (`\\r`) may still be present.\n   */\n  getline(): string | null;\n\n  /** Read `maxSize` bytes from the file and return them as a string assuming UTF-8 encoding. If `maxSize` is not present, the file is read up its end. */\n  readAsString(maxSize?: number): string;\n\n  /** Return the next byte from the file. Return -1 if the end of file is reached. */\n  getByte(): number;\n\n  /** Write one byte to the file. */\n  putByte(value: number): void;\n}\n\ndeclare module \"std\" {\n  /**\n   * Exit the process with the provided status code.\n   *\n   * @param statusCode The exit code; 0 for success, nonzero for failure.\n   */\n  export function exit(statusCode: number): void;\n\n  /**\n   * Evaluate the string `code` as a script (global eval).\n   *\n   * @param code - The code to evaluate.\n   * @param options - An optional object containing the following optional properties:\n   * @property backtraceBarrier - Boolean (default = false). If true, error backtraces do not list the stack frames below the evalScript.\n   * @returns The result of the evaluation.\n   */\n  export function evalScript(\n    code: string,\n    options?: { backtraceBarrier?: boolean }\n  ): any;\n\n  /**\n   * Evaluate the file `filename` as a script (global eval).\n   *\n   * @param filename - The relative or absolute path to the file to load. Relative paths are resolved relative to the process's current working directory.\n   * @returns The result of the evaluation.\n   */\n  export function loadScript(filename: string): any;\n\n  /**\n   * Evaluate the file `filename` as a module. Effectively a synchronous dynamic `import()`.\n   *\n   * @param filename - The relative or absolute path to the file to import. Relative paths are resolved relative to the file calling `importModule`, or `basename` if present.\n   * @param basename - If present and `filename` is a relative path, `filename` will be resolved relative to this basename.\n   * @returns The result of the evaluation (module namespace object).\n   */\n  export function importModule(\n    filename: string,\n    basename?: string\n  ): { [key: string]: any };\n\n  /**\n   * Return the resolved path to a module.\n   *\n   * @param filename - The relative or absolute path to the file to import. Relative paths are resolved relative to the file calling `importModule`, or `basename` if present.\n   * @param basename - If present and `filename` is a relative path, `filename` will be resolved relative to this basename.\n   * @returns The resolved module path.\n   */\n  export function resolveModule(filename: string, basename?: string): string;\n\n  /**\n   * Load the file `filename` and return it as a string assuming UTF-8 encoding.\n   *\n   * @param filename - The relative or absolute path to the file to load. Relative paths are resolved relative to the process's current working directory.\n   */\n  export function loadFile(filename: string): string;\n\n  /**\n   * Read the script of module filename from an active stack frame, then return it as a string.\n   *\n   * If there isn't a valid filename for the specified stack frame, an error will be thrown.\n   *\n   * @param stackLevels - How many levels up the stack to search for a filename. Defaults to 0, which uses the current stack frame.\n   */\n  export function getFileNameFromStack(stackLevels?: number): string;\n\n  /**\n   * Return a boolean indicating whether the provided value is a FILE object.\n   *\n   * @param value - The value to check.\n   * @returns Whether the value was a `FILE` or not.\n   */\n  export function isFILE(value: any): boolean;\n\n  /**\n   * Open a file (wrapper to the libc `fopen()`).\n   * Return the FILE object.\n   *\n   * @param filename - The relative or absolute path to the file to open. Relative paths are resolved relative to the process's current working directory.\n   * @param flags - A string containing any combination of the characters 'r', 'w', 'a', '+', and/or 'b'.\n   * @returns The opened FILE object.\n   */\n  export function open(filename: string, flags: string): FILE;\n\n  /**\n   * Open a process by creating a pipe (wrapper to the libc `popen()`).\n   * Return the FILE object.\n   *\n   * @param command - The command line to execute. Gets passed via `/bin/sh -c`.\n   * @param flags - A string containing any combination of the characters 'r', 'w', 'a', '+', and/or 'b'.\n   * @returns The opened FILE object.\n   */\n  export function popen(command: string, flags: string): FILE;\n\n  /**\n   * Open a file from a file handle (wrapper to the libc `fdopen()`).\n   * Return the FILE object.\n   *\n   * @param fd - The file handle to open.\n   * @param flags - A string containing any combination of the characters 'r', 'w', 'a', '+', and/or 'b'.\n   * @returns The opened FILE object.\n   */\n  export function fdopen(fd: number, flags: string): FILE;\n\n  /**\n   * Open a temporary file.\n   * Return the FILE object.\n   *\n   * @returns The opened FILE object.\n   */\n  export function tmpfile(): FILE;\n\n  /** Equivalent to `std.out.puts(str)`. */\n  export function puts(...strings: Array<string>): void;\n\n  /** Equivalent to `std.out.printf(fmt, ...args)` */\n  export function printf(fmt: string, ...args: Array<any>): void;\n\n  /** Equivalent to the libc sprintf(). */\n  export function sprintf(fmt: string, ...args: Array<any>): void;\n\n  /** Wrapper to the libc file stdin. */\n  var in_: FILE;\n\n  export { in_ as in };\n\n  /** Wrapper to the libc file stdout. */\n  export var out: FILE;\n\n  /** Wrapper to the libc file stderr. */\n  export var err: FILE;\n\n  /** Constant for {@link FILE.seek}. Declares that pointer offset should be relative to the beginning of the file. See also libc `fseek()`. */\n  export var SEEK_SET: number;\n\n  /** Constant for {@link FILE.seek}. Declares that the offset should be relative to the current position of the FILE handle. See also libc `fseek()`. */\n  export var SEEK_CUR: number;\n\n  /** Constant for {@link FILE.seek}. Declares that the offset should be relative to the end of the file. See also libc `fseek()`. */\n  export var SEEK_END: number;\n\n  /** Manually invoke the cycle removal algorithm (garbage collector). The cycle removal algorithm is automatically started when needed, so this function is useful in case of specific memory constraints or for testing. */\n  export function gc(): void;\n\n  /** Return the value of the environment variable `name` or `undefined` if it is not defined. */\n  export function getenv(name: string): string | undefined;\n\n  /** Set the value of the environment variable `name` to the string `value`. */\n  export function setenv(name: string, value: string): void;\n\n  /** Delete the environment variable `name`. */\n  export function unsetenv(name: string): void;\n\n  /** Return an object containing the environment variables as key-value pairs. */\n  export function getenviron(): { [key: string]: string | undefined };\n\n  interface UrlGet {\n    /**\n     * Download `url` using the `curl` command line utility. Returns string\n     * when the http status code is between 200 and 299, and throws otherwise.\n     *\n     * Pass an object with { full: true } as the second argument to get\n     * response headers and status code.\n     */\n    (url: string): string;\n\n    /**\n     * Download `url` using the `curl` command line utility. Returns string\n     * when the http status code is between 200 and 299, and throws otherwise.\n     *\n     * Pass an object with { full: true } as the second argument to get\n     * response headers and status code.\n     */\n    (url: string, options: { binary: false }): string;\n\n    /**\n     * Download `url` using the `curl` command line utility. Returns string\n     * when the http status code is between 200 and 299, and throws otherwise.\n     *\n     * Pass an object with { full: true } as the second argument to get\n     * response headers and status code.\n     */\n    (url: string, options: { full: false }): string;\n\n    /**\n     * Download `url` using the `curl` command line utility. Returns string\n     * when the http status code is between 200 and 299, and throws otherwise.\n     *\n     * Pass an object with { full: true } as the second argument to get\n     * response headers and status code.\n     */\n    (url: string, options: { binary: false; full: false }): string;\n\n    /**\n     * Download `url` using the `curl` command line utility. Returns\n     * ArrayBuffer when the http status code is between 200 and 299, and throws\n     * otherwise.\n     *\n     * Pass an object with { full: true } as the second argument to get\n     * response headers and status code.\n     */\n    (url: string, options: { binary: true }): ArrayBuffer;\n\n    /**\n     * Download `url` using the `curl` command line utility. Returns\n     * ArrayBuffer when the http status code is between 200 and 299, and throws\n     * otherwise.\n     *\n     * Pass an object with { full: true } as the second argument to get\n     * response headers and status code.\n     */\n    (url: string, options: { binary: true; full: false }): ArrayBuffer;\n\n    /**\n     * Download `url` using the `curl` command line utility.\n     *\n     * Returns an object with three properties:\n     *\n     * - `response`: response body content (string)\n     * - `responseHeaders`: headers separated by CRLF (string)\n     * - `status`: status code (number)\n     */\n    (url: string, options: { full: true }): {\n      status: number;\n      response: string;\n      responseHeaders: string;\n    };\n\n    /**\n     * Download `url` using the `curl` command line utility.\n     *\n     * Returns an object with three properties:\n     *\n     * - `response`: response body content (string)\n     * - `responseHeaders`: headers separated by CRLF (string)\n     * - `status`: status code (number)\n     */\n    (url: string, options: { full: true; binary: false }): {\n      status: number;\n      response: string;\n      responseHeaders: string;\n    };\n\n    /**\n     * Download `url` using the `curl` command line utility.\n     *\n     * Returns an object with three properties:\n     *\n     * - `response`: response body content (ArrayBuffer)\n     * - `responseHeaders`: headers separated by CRLF (string)\n     * - `status`: status code (number)\n     */\n    (url: string, options: { full: true; binary: true }): {\n      status: number;\n      response: ArrayBuffer;\n      responseHeaders: string;\n    };\n  }\n\n  export var urlGet: UrlGet;\n\n  /**\n   * Parse `str` using a superset of JSON.parse. The following extensions are accepted:\n   *\n   * - Single line and multiline comments\n   * - unquoted properties (ASCII-only Javascript identifiers)\n   * - trailing comma in array and object definitions\n   * - single quoted strings\n   * - `\\f` and `\\v` are accepted as space characters\n   * - leading plus in numbers\n   * - octal (0o prefix) and hexadecimal (0x prefix) numbers\n   */\n  export function parseExtJSON(str: string): any;\n}\n\ndeclare module \"os\" {\n  /**\n   * Open a file handle. Returns a number; the file descriptor.\n   *\n   * @param filename - The path to the file to open.\n   * @param flags - Numeric flags that set the mode to use when opening the file. See `os.O_*`\n   * @param mode - Octal access mask. Defaults to 0o666.\n   */\n  export function open(filename: string, flags: number, mode?: number): number;\n\n  /** POSIX open flag, used in {@link open}. */\n  export var O_RDONLY: number;\n\n  /** POSIX open flag, used in {@link open}. */\n  export var O_WRONLY: number;\n\n  /** POSIX open flag, used in {@link open}. */\n  export var O_RDWR: number;\n\n  /** POSIX open flag, used in {@link open}. */\n  export var O_APPEND: number;\n\n  /** POSIX open flag, used in {@link open}. */\n  export var O_CREAT: number;\n\n  /** POSIX open flag, used in {@link open}. */\n  export var O_EXCL: number;\n\n  /** POSIX open flag, used in {@link open}. */\n  export var O_TRUNC: number;\n\n  /** Windows-specific open flag: open the file in text mode. The default is binary mode. Used in {@link open}. */\n  export var O_TEXT: number;\n\n  /** Close the file with descriptor `fd`. */\n  export function close(fd: number): void;\n\n  interface OsSeek {\n    /** Seek in the file. Use `std.SEEK_*` for `whence`. `offset` is either a number or a bigint. If `offset` is a bigint, a bigint is returned too. */\n    (fd: number, offset: number, whence: number): number;\n\n    /** Seek in the file. Use `std.SEEK_*` for `whence`. `offset` is either a number or a bigint. If `offset` is a bigint, a bigint is returned too. */\n    (fd: number, offset: BigInt, whence: number): BigInt;\n  }\n\n  /** Seek in the file. Use `std.SEEK_*` for `whence`. `offset` is either a number or a bigint. If `offset` is a bigint, a bigint is returned too. */\n  export var seek: OsSeek;\n\n  /** Read `length` bytes from the file with descriptor `fd` to the ArrayBuffer `buffer` at byte position `offset`. Return the number of read bytes. */\n  export function read(\n    fd: number,\n    buffer: ArrayBuffer,\n    offset: number,\n    length: number\n  ): number;\n\n  /** Write `length` bytes to the file with descriptor `fd` from the ArrayBuffer `buffer` at byte position `offset`. Return the number of written bytes. */\n  export function write(\n    fd: number,\n    buffer: ArrayBuffer,\n    offset: number,\n    length: number\n  ): number;\n\n  /** Return `true` if the file opened with descriptor `fd` is a TTY (terminal). */\n  export function isatty(fd: number): boolean;\n\n  /** Return the TTY size as `[width, height]` or `null` if not available. */\n  export function ttyGetWinSize(fd: number): null | [number, number];\n\n  /** Set the TTY in raw mode. */\n  export function ttySetRaw(fd: number): void;\n\n  /** Remove a file. */\n  export function remove(filename: string): void;\n\n  /** Rename a file. */\n  export function rename(oldname: string, newname: string): void;\n\n  /** Return the canonicalized absolute pathname of `path`. */\n  export function realpath(path: string): string;\n\n  /** Return the current working directory. */\n  export function getcwd(): string;\n\n  /** Change the current directory. */\n  export function chdir(path: string): void;\n\n  /** Create a directory at `path`. */\n  export function mkdir(path: string, mode?: number): void;\n\n  export type Stats = {\n    dev: number;\n    ino: number;\n    mode: number;\n    nlink: number;\n    uid: number;\n    gid: number;\n    rdev: number;\n    size: number;\n    blocks: number;\n    atime: number;\n    mtime: number;\n    ctime: number;\n  };\n\n  /**\n   * Return a stats object with the following fields:\n   *\n   * - `dev`\n   * - `ino`\n   * - `mode`\n   * - `nlink`\n   * - `uid`\n   * - `gid`\n   * - `rdev`\n   * - `size`\n   * - `blocks`\n   * - `atime`\n   * - `mtime`\n   * - `ctime`\n   *\n   * The times are specified in milliseconds since 1970. `lstat()` is the same as `stat()` except that it returns information about the link itself.\n   */\n  export function stat(path: string): Stats;\n\n  /**\n   * Return a stats object with the following fields:\n   *\n   * - `dev`\n   * - `ino`\n   * - `mode`\n   * - `nlink`\n   * - `uid`\n   * - `gid`\n   * - `rdev`\n   * - `size`\n   * - `blocks`\n   * - `atime`\n   * - `mtime`\n   * - `ctime`\n   *\n   * The times are specified in milliseconds since 1970. `lstat()` is the same as `stat()` except that it returns information about the link itself.\n   */\n  export function lstat(path: string): Stats;\n\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_IFMT: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_IFIFO: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_IFCHR: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_IFDIR: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_IFBLK: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_IFREG: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_IFSOCK: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_IFLNK: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_ISGID: number;\n  /** Constant to interpret the `mode` property returned by `stat()`. Has the same value as in the C system header `sys/stat.h`. */\n  export var S_ISUID: number;\n\n  /**\n   * Change the access and modification times of the file path.\n   *\n   * The times are specified in milliseconds since 1970.\n   */\n  export function utimes(path: string, atime: number, mtime: number): void;\n\n  /** Create a link at `linkpath` containing the string `target`. */\n  export function symlink(target: string, linkpath: string): void;\n\n  /** Return the link target. */\n  export function readlink(path: string): string;\n\n  /** Return an array of strings containing the filenames of the directory `path`. */\n  export function readdir(path: string): Array<string>;\n\n  /** Add a read handler to the file with descriptor `fd`. `func` is called each time there is data pending for `fd`. A single read handler per file handle is supported. Use `func = null` to remove the handler. */\n  export function setReadHandler(fd: number, func: null | (() => void)): void;\n\n  /** Add a write handler to the file with descriptor `fd`. `func` is called each time data can be written to `fd`. A single write handler per file handle is supported. Use `func = null` to remove the handler. */\n  export function setWriteHandler(fd: number, func: null | (() => void)): void;\n\n  /** Call the function `func` when the signal `signal` happens. Only a single handler per signal number is supported. Use `null` to set the default handler or `undefined` to ignore the signal. Signal handlers can only be defined in the main thread. */\n  export function signal(\n    signal: number,\n    func: null | undefined | (() => void)\n  ): void;\n\n  /** POSIX signal number. */\n  export var SIGINT: number;\n\n  /** POSIX signal number. */\n  export var SIGABRT: number;\n\n  /** POSIX signal number. */\n  export var SIGFPE: number;\n\n  /** POSIX signal number. */\n  export var SIGILL: number;\n\n  /** POSIX signal number. */\n  export var SIGSEGV: number;\n\n  /** POSIX signal number. */\n  export var SIGTERM: number;\n\n  /** Send the signal `sig` to the process `pid`. Use `os.SIG*` constants. */\n  export function kill(pid: number, sig: number): void;\n\n  export type ExecOptions = {\n    /** Boolean (default = true). If true, wait until the process is terminated. In this case, `exec` returns the exit code if positive or the negated signal number if the process was interrupted by a signal. If false, do not block and return the process id of the child. */\n    block?: boolean;\n\n    /** Boolean (default = true). If true, the file is searched in the `PATH` environment variable. */\n    usePath?: boolean;\n\n    /** String (default = `args[0]`). Set the file to be executed. */\n    file?: string;\n\n    /** String. If present, set the working directory of the new process. */\n    cwd?: string;\n\n    /** If present, set the file descriptor in the child for stdin. */\n    stdin?: number;\n\n    /** If present, set the file descriptor in the child for stdout. */\n    stdout?: number;\n\n    /** If present, set the file descriptor in the child for stderr. */\n    stderr?: number;\n\n    /** Object. If present, set the process environment from the object key-value pairs. Otherwise use the same environment as the current process. To get the current process's environment variables as on object, use `std.getenviron()`. */\n    env?: { [key: string | number]: string | number | boolean };\n\n    /** Integer. If present, the process uid with `setuid`. */\n    uid?: number;\n\n    /** Integer. If present, the process gid with `setgid`. */\n    gid?: number;\n  };\n\n  /** Execute a process with the arguments args, and the provided options (if any). */\n  export function exec(args: Array<string>, options?: ExecOptions): number;\n\n  /**\n   * `waitpid` Unix system call. Returns the array [ret, status].\n   *\n   * From man waitpid(2):\n   *\n   * waitpid(): on success, returns the process ID of the child whose state has changed; if WNOHANG was specified and one or more child(ren) specified by pid exist, but have not yet changed state, then 0 is returned.\n   */\n  export function waitpid(pid: number, options?: number): [number, number];\n\n  /** Constant for the `options` argument of `waitpid`. */\n  export var WNOHANG: number;\n  /** Constant for the `options` argument of `waitpid`. */\n  export var WUNTRACED: number;\n\n  /** Function to be used to interpret the 'status' return value of `waitpid`. */\n  export function WEXITSTATUS(status: number): number;\n  /** Function to be used to interpret the 'status' return value of `waitpid`. */\n  export function WTERMSIG(status: number): number;\n  /** Function to be used to interpret the 'status' return value of `waitpid`. */\n  export function WSTOPSIG(status: number): number;\n\n  /** Function to be used to interpret the 'status' return value of `waitpid`. */\n  export function WIFEXITED(status: number): boolean;\n  /** Function to be used to interpret the 'status' return value of `waitpid`. */\n  export function WIFSIGNALED(status: number): boolean;\n  /** Function to be used to interpret the 'status' return value of `waitpid`. */\n  export function WIFSTOPPED(status: number): boolean;\n  /** Function to be used to interpret the 'status' return value of `waitpid`. */\n  export function WIFCONTINUED(status: number): boolean;\n\n  /** `dup` Unix system call. */\n  export function dup(fd: number): number;\n\n  /** `dup2` Unix system call. */\n  export function dup2(oldfd: number, newfd: number): number;\n\n  /** `pipe` Unix system call. Return two handles as `[read_fd, write_fd]`. */\n  export function pipe(): null | [number, number];\n\n  /** Sleep for `delay_ms` milliseconds. */\n  export function sleep(delay_ms: number): void;\n\n  export type OSTimer = { [Symbol.toStringTag]: \"OSTimer\" };\n\n  /** Call the function func after delay ms. Return a handle to the timer. */\n  export function setTimeout(\n    func: (...args: any) => any,\n    delay: number\n  ): OSTimer;\n\n  /** Cancel a timer. */\n  export function clearTimeout(handle: OSTimer): void;\n\n  /** Return a string representing the platform: \"linux\", \"darwin\", \"win32\", \"freebsd\", or \"js\" (emscripten). */\n  export var platform: \"linux\" | \"darwin\" | \"win32\" | \"freebsd\" | \"js\";\n\n  /**\n   * Things that can be put into Worker.postMessage.\n   *\n   * NOTE: This is effectively the same stuff as supported by the structured\n   * clone algorithm, but without support for Map/Set (not supported in\n   * QuickJS yet).\n   */\n  export type StructuredClonable =\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    | Boolean\n    | String\n    | Date\n    | RegExp\n    | ArrayBuffer\n    | Int8Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n    | BigInt64Array\n    | BigUint64Array\n    | DataView\n    | Array<StructuredClonable>\n    | SharedArrayBuffer\n    // Map and Set not yet supported\n    // | Map<StructuredClonable, StructuredClonable>\n    // | Set<StructuredClonable>\n    | { [key: string | number]: StructuredClonable };\n\n  export class Worker {\n    /**\n     * Constructor to create a new thread (worker) with an API close to the\n     * `WebWorkers`. `moduleFilename` is a string specifying the module\n     * filename which is executed in the newly created thread. As for\n     * dynamically imported module, it is relative to the current script or\n     * module path. Threads normally dont share any data and communicate\n     * between each other with messages. Nested workers are not supported.\n     */\n    constructor(moduleFilename: string);\n\n    /**\n     * In the created worker, Worker.parent represents the parent worker and is\n     * used to send or receive messages.\n     */\n    static parent: Worker;\n\n    /**\n     * Send a message to the corresponding worker. msg is cloned in the\n     * destination worker using an algorithm similar to the HTML structured\n     * clone algorithm. SharedArrayBuffer are shared between workers.\n     *\n     * Current limitations: Map and Set are not supported yet.\n     */\n    postMessage(msg: StructuredClonable): void;\n\n    /**\n     * Set a function which is called each time a message is received. The\n     * function is called with a single argument. It is an object with a data\n     * property containing the received message. The thread is not terminated\n     * if there is at least one non null onmessage handler.\n     */\n    onmessage: null | ((event: { data: StructuredClonable }) => void);\n  }\n\n  /** constant for {@link access}(); test for read permission. */\n  export var R_OK: number;\n\n  /** constant for {@link access}(); test for write permission. */\n  export var W_OK: number;\n\n  /** constant for {@link access}(); test for execute (search) permission. */\n  export var X_OK: number;\n\n  /** constant for {@link access}(); test for existence of file. */\n  export var F_OK: number;\n\n  /** `access` Unix system call; checks if a file is readable, writable, executable, and/or exists (use {@link R_OK}, {@link W_OK}, {@link X_OK}, and/or {@link F_OK} for `accessMode`). Throws a descriptive error (with errno property) if the requested access is not available; otherwise, returns undefined. */\n  export function access(path: string, accessMode: number): void;\n\n  /** gets the path to the executable which is executing this JS code. might be a relative path or symlink. */\n  export function execPath(): string;\n}\n\n/**\n * Options for {@link inspect}.\n */\ndeclare interface InspectOptions {\n  /** Whether to display non-enumerable properties. Defaults to false. */\n  all?: boolean;\n\n  /** Whether to invoke getter functions. Defaults to false. */\n  followGetters?: boolean;\n\n  /** Whether to display the indexes of iterable entries. Defaults to false. */\n  indexes?: boolean;\n\n  /** Hide object details after  recursions. Defaults to Infinity. */\n  maxDepth?: number;\n\n  /** If true, don't identify well-known symbols as `@@`. Defaults to false. */\n  noAmp?: boolean;\n\n  /** If true, don't format byte-arrays as hexadecimal. Defaults to false. */\n  noHex?: boolean;\n\n  /** If true, don't display function source code. Defaults to false. */\n  noSource?: boolean;\n\n  /** Whether to show `__proto__` properties if possible. Defaults to false. */\n  proto?: boolean;\n\n  /** Whether to sort properties alphabetically. When false, properties are sorted by creation order. Defaults to false. */\n  sort?: boolean;\n\n  /** Options that control whether and how ANSI terminal escape sequences for colours should be added to the output. Defaults to false, meaning no colours. */\n  colours?: boolean | 256 | 8 | InspectColours;\n\n  /** Prefix string to use for indentation. Defaults to '\\t'. */\n  indent?: string;\n}\n\ndeclare interface InspectColours {\n  off?: string | number;\n  red?: string | number;\n  grey?: string | number;\n  green?: string | number;\n  darkGreen?: string | number;\n  punct?: string | number;\n  keys?: string | number;\n  keyEscape?: string | number;\n  typeColour?: string | number;\n  primitive?: string | number;\n  escape?: string | number;\n  date?: string | number;\n  hexBorder?: string | number;\n  hexValue?: string | number;\n  hexOffset?: string | number;\n  reference?: string | number;\n  srcBorder?: string | number;\n  srcRowNum?: string | number;\n  srcRowText?: string | number;\n  nul?: string | number;\n  nulProt?: string | number;\n  undef?: string | number;\n  noExts?: string | number;\n  frozen?: string | number;\n  sealed?: string | number;\n  regex?: string | number;\n  string?: string | number;\n  symbol?: string | number;\n  symbolFade?: string | number;\n  braces?: string | number;\n  quotes?: string | number;\n  empty?: string | number;\n  dot?: string | number;\n}\n\ndeclare interface InspectFunction {\n  /**\n   * Generate a human-readable representation of a value.\n   *\n   * @param value - Value to inspect\n   * @param options - Additional settings for refining output\n   * @returns A string representation of `value`.\n   */\n  (value: any, options?: InspectOptions): string;\n\n  /**\n   * Generate a human-readable representation of a value.\n   *\n   * @param value - Value to inspect\n   * @param key - The value's corresponding member name\n   * @param options - Additional settings for refining output\n   * @returns A string representation of `value`.\n   */\n  (value: any, key?: string | symbol, options?: InspectOptions): string;\n}\n\n/**\n * Generate a human-readable representation of a value.\n *\n * @param value - Value to inspect\n * @param key - The value's corresponding member name\n * @param options - Additional settings for refining output\n * @returns A string representation of `value`.\n */\ndeclare var inspect: InspectFunction;\n\n/**\n * A class which represents a module namespace object. Note, however, that\n * instances of this class cannot be constructed manually, and must instead be\n * obtained from `import * as`, `import()`, `std.importModule`, or `require`.\n *\n * The static properties on `Module` let you configure the module loader\n * (import/export/require). You can use these properties to add support for\n * importing new filetypes.\n */\ndeclare class Module {\n  /** A module namespace object has arbitrary exports. */\n  [key: string | number | symbol]: any;\n\n  /**\n   * Module objects are not constructable.\n   *\n   * You must instead obtain them using import or require.\n   */\n  private constructor();\n\n  /**\n   * Returns true if `target` is a module namespace object.\n   */\n  static [Symbol.hasInstance](target: any): target is Module;\n\n  /**\n   * A list of filetype extensions that may be omitted from an import specifier\n   * string.\n   *\n   * Defaults to `[\".js\"]`. You can add more strings to this array to\n   * make the engine search for additional files when resolving a\n   * require/import.\n   *\n   * See the doc comment on {@link require} for more information.\n   *\n   * NOTE: If you add a new extension to this array, you will likely also want\n   * to add to {@link Module.compilers}.\n   */\n  static searchExtensions: Array<string>;\n\n  /**\n   * User-defined functions which will handle getting the JavaScript code\n   * associated with a module.\n   *\n   * The key for each property in this object should be a file extension\n   * string with a leading dot, eg `\".jsx\"`. The value for each property should\n   * be a function which receives (1) the filepath to a module, and (2) that\n   * file's content as a UTF-8 string, and the function should return a string\n   * containing JavaScript code that corresponds to that module. In most cases,\n   * these functions will compile the contents of the file from one format into JavaScript.\n   *\n   * The function does not have to use the second 'content' argument it\n   * receives (ie. when loading binary files).\n   *\n   * By adding to this object, you can make it possible to import non-js\n   * filetypes; compile-to-JS languages like JSX, TypeScript, and CoffeeScript\n   * can be compiled at import time, and asset files like .txt files or .png\n   * files can be converted into an appropriate data structure at import time.\n   *\n   * As an example, to make it possible to import .txt files, you might do:\n   * ```js\n   * import * as std from \"std\";\n   *\n   * Module.compilers[\".txt\"] = (filename, content) => {\n   *   return `export default ${JSON.stringify(content)}`;\n   * }\n   * ```\n   * (leveraging `JSON.stringify`'s ability to escape quotes).\n   *\n   * Then, later in your code, you can do:\n   * ```js\n   * import names from \"./names.txt\";\n   * ```\n   *\n   * And `names` will be a string containing the contents of names.txt.\n   *\n   * NOTE: When adding to this object, you may also wish to add to\n   * {@link Module.searchExtensions}.\n   */\n  static compilers: {\n    [extensionWithDot: string]: (filename: string, content: string) => string;\n  };\n}\n\n/**\n * Synchronously import a module.\n *\n * `source` will be resolved relative to the calling file.\n *\n * If `source` does not have a file extension, and a file without an extension\n * cannot be found, the engine will check for files with the extensions in\n * {@link Module.searchExtensions}, and use one of those if present. This\n * behavior also happens when using normal `import` statements.\n *\n * For example, if you write:\n *\n * ```js\n * import something from \"./somewhere\";\n * ```\n *\n * but there's no file named `somewhere` in the same directory as the file\n * where that import appears, and `Module.searchExtensions` is the default\n * value:\n *\n * ```js\n * [\".js\"]\n * ```\n *\n * then the engine will look for `somewhere.js`. If that doesn't exist, the\n * engine will look for `somewhere/index.js`. If *that* doesn't exist, an error\n * will be thrown.\n *\n * If you add more extensions to `Module.searchExtensions`, then the engine\n * will use those, too. It will search in the same order as the strings appear\n * in the `Module.searchExtensions` array.\n */\ndeclare var require: ((source: string) => { [key: string]: any }) & {\n  /**\n   * Resolves the normalized path to a modules, relative to the calling file.\n   */\n  resolve: (source: string) => string;\n};\n\ndeclare var setTimeout: typeof import(\"os\").setTimeout;\ndeclare var clearTimeout: typeof import(\"os\").clearTimeout;\n\ndeclare type Interval = { [Symbol.toStringTag]: \"Interval\" };\n\ndeclare function setInterval(func: (...args: any) => any, ms: number): Interval;\ndeclare function clearInterval(interval: Interval): void;\n\ninterface StringConstructor {\n  /**\n   * A no-op template literal tag.\n   *\n   * https://github.com/tc39/proposal-string-cooked\n   */\n  cooked(\n    strings: readonly string[] | ArrayLike<string>,\n    ...substitutions: any[]\n  ): string;\n\n  /**\n   * Remove leading minimum indentation from the string.\n   * The first line of the string must be empty.\n   *\n   * https://github.com/tc39/proposal-string-dedent\n   */\n  dedent: {\n    /**\n     * Remove leading minimum indentation from the string.\n     * The first line of the string must be empty.\n     *\n     * https://github.com/tc39/proposal-string-dedent\n     */\n    (input: string): string;\n\n    /**\n     * Remove leading minimum indentation from the template literal.\n     * The first line of the string must be empty.\n     *\n     * https://github.com/tc39/proposal-string-dedent\n     */\n    (\n      strings: readonly string[] | ArrayLike<string>,\n      ...substitutions: any[]\n    ): string;\n\n    /**\n     * Wrap another template tag function such that tagged literals\n     * become dedented before being passed to the wrapped function.\n     *\n     * https://www.npmjs.com/package/string-dedent#usage\n     */\n    <\n      Func extends (\n        strings: readonly string[] | ArrayLike<string>,\n        ...substitutions: any[]\n      ) => string\n    >(\n      input: Func\n    ): Func;\n  };\n}\n";
}),
/* --- src/targets/repl/modified-qjs-repl.js --- */
"src/targets/repl/modified-qjs-repl.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startRepl = startRepl;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var os = _interopRequireWildcard(_kame_require_("external:os"));
var _printError = _interopRequireDefault(_kame_require_("src/print-error.ts"));
var inspectOptions = _interopRequireWildcard(_kame_require_("src/inspect-options.ts"));
var _special = _kame_require_("src/targets/repl/special.ts");
var esmToRequire = _interopRequireWildcard(_kame_require_("src/esm-to-require.ts"));
var _langs = _kame_require_("src/langs.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
/*
 * QuickJS Read Eval Print Loop (modified)
 *
 * Copyright (c) 2017-2020 Fabrice Bellard
 * Copyright (c) 2017-2020 Charlie Gordon
 * Copyright (c) 2022 Lily Skye
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function startRepl(lang) {
  const compiler = (0, _langs.langToCompiler)(lang);
  const compileExpression = expr => {
    const compiledCode = compiler(expr, {
      expression: true
    });
    return esmToRequire.transform(compiledCode);
  };

  /* add 'os' and 'std' bindings */
  globalThis.os = os;
  globalThis.std = std;

  /* close global objects */
  var Object = globalThis.Object;
  var String = globalThis.String;
  var Date = globalThis.Date;
  var Math = globalThis.Math;
  var colors = {
    none: "\x1b[0m",
    black: "\x1b[30m",
    red: "\x1b[31m",
    green: "\x1b[32m",
    yellow: "\x1b[33m",
    blue: "\x1b[34m",
    magenta: "\x1b[35m",
    cyan: "\x1b[36m",
    white: "\x1b[37m",
    gray: "\x1b[30;1m",
    grey: "\x1b[30;1m",
    bright_red: "\x1b[31;1m",
    bright_green: "\x1b[32;1m",
    bright_yellow: "\x1b[33;1m",
    bright_blue: "\x1b[34;1m",
    bright_magenta: "\x1b[35;1m",
    bright_cyan: "\x1b[36;1m",
    bright_white: "\x1b[37;1m"
  };

  // Styles here are trying to match the styles from the builtin inspect
  // function, which itself comes from npm:@suchipi/print
  var styles = {
    default: "none",
    comment: "gray",
    string: "bright_green",
    regex: "bright_green",
    literal: "bright_magenta",
    number: "bright_magenta",
    keyword: "bright_blue",
    function: "bright_green",
    identifier: "none",
    error: "red",
    error_msg: "bright_red"
  };
  var history = [];
  var clip_board = "";
  var pstate = "";
  var prompt = "";
  var plen = 0;
  var ps1 = "> ";
  var ps2 = "  ... ";
  var utf8 = true;
  var show_time = false;
  var show_colors = true;
  var eval_time = 0;
  var mexpr = "";
  var level = 0;
  var cmd = "";
  var cursor_pos = 0;
  var last_cmd = "";
  var last_cursor_pos = 0;
  var history_index;
  var this_fun, last_fun;
  var quote_flag = false;
  var term_fd;
  var term_read_buf;
  var term_width;
  /* current X position of the cursor in the terminal */
  var term_cursor_x = 0;
  function termInit() {
    var tab;
    term_fd = std.in.fileno();

    /* get the terminal size */
    term_width = 80;
    if (os.isatty(term_fd)) {
      if (os.ttyGetWinSize) {
        tab = os.ttyGetWinSize(term_fd);
        if (tab) {
          term_width = tab[0];
        }
      }
      if (os.ttySetRaw) {
        /* set the TTY to raw mode */
        os.ttySetRaw(term_fd);
      }
    }

    /* install a Ctrl-C signal handler */
    os.signal(os.SIGINT, sigint_handler);

    /* install a handler to read stdin */
    term_read_buf = new Uint8Array(64);
    os.setReadHandler(term_fd, term_read_handler);
  }
  function sigint_handler() {
    /* send Ctrl-C to readline */
    handle_byte(3);
  }
  function term_read_handler() {
    var l, i;
    l = os.read(term_fd, term_read_buf.buffer, 0, term_read_buf.length);
    for (i = 0; i < l; i++) {
      handle_byte(term_read_buf[i]);
    }
  }
  var utf8_state = 0;
  var utf8_val = 0;
  function handle_byte(c) {
    if (!utf8) {
      handle_char(c);
    } else if (utf8_state !== 0 && c >= 0x80 && c < 0xc0) {
      utf8_val = utf8_val << 6 | c & 0x3f;
      utf8_state--;
      if (utf8_state === 0) {
        handle_char(utf8_val);
      }
    } else if (c >= 0xc0 && c < 0xf8) {
      utf8_state = 1 + (c >= 0xe0) + (c >= 0xf0);
      utf8_val = c & (1 << 6 - utf8_state) - 1;
    } else {
      utf8_state = 0;
      handle_char(c);
    }
  }
  function is_alpha(c) {
    return typeof c === "string" && (c >= "A" && c <= "Z" || c >= "a" && c <= "z");
  }
  function is_digit(c) {
    return typeof c === "string" && c >= "0" && c <= "9";
  }
  function is_word(c) {
    return typeof c === "string" && (is_alpha(c) || is_digit(c) || c == "_" || c == "$");
  }
  function ucs_length(str) {
    var len,
      c,
      i,
      str_len = str.length;
    len = 0;
    /* we never count the trailing surrogate to have the
         following property: ucs_length(str) =
         ucs_length(str.substring(0, a)) + ucs_length(str.substring(a,
         str.length)) for 0 <= a <= str.length */
    for (i = 0; i < str_len; i++) {
      c = str.charCodeAt(i);
      if (c < 0xdc00 || c >= 0xe000) {
        len++;
      }
    }
    return len;
  }
  function is_trailing_surrogate(c) {
    var d;
    if (typeof c !== "string") {
      return false;
    }
    d = c.codePointAt(0); /* can be NaN if empty string */
    return d >= 0xdc00 && d < 0xe000;
  }
  function is_balanced(a, b) {
    switch (a + b) {
      case "()":
      case "[]":
      case "{}":
        return true;
    }
    return false;
  }
  function print_color_text(str, start, style_names) {
    var i, j;
    for (j = start; j < str.length;) {
      var style = style_names[i = j];
      while (++j < str.length && style_names[j] == style) {
        continue;
      }
      std.puts(colors[styles[style] || "default"]);
      std.puts(str.substring(i, j));
      std.puts(colors["none"]);
    }
  }
  function print_csi(n, code) {
    std.puts("\x1b[" + (n != 1 ? n : "") + code);
  }

  /* XXX: handle double-width characters */
  function move_cursor(delta) {
    var i, l;
    if (delta > 0) {
      while (delta != 0) {
        if (term_cursor_x == term_width - 1) {
          std.puts("\n"); /* translated to CRLF */
          term_cursor_x = 0;
          delta--;
        } else {
          l = Math.min(term_width - 1 - term_cursor_x, delta);
          print_csi(l, "C"); /* right */
          delta -= l;
          term_cursor_x += l;
        }
      }
    } else {
      delta = -delta;
      while (delta != 0) {
        if (term_cursor_x == 0) {
          print_csi(1, "A"); /* up */
          print_csi(term_width - 1, "C"); /* right */
          delta--;
          term_cursor_x = term_width - 1;
        } else {
          l = Math.min(delta, term_cursor_x);
          print_csi(l, "D"); /* left */
          delta -= l;
          term_cursor_x -= l;
        }
      }
    }
  }
  function update() {
    var i, cmd_len;
    /* cursor_pos is the position in 16 bit characters inside the
           UTF-16 string 'cmd' */
    if (cmd != last_cmd) {
      if (!show_colors && last_cmd.substring(0, last_cursor_pos) == cmd.substring(0, last_cursor_pos)) {
        /* optimize common case */
        std.puts(cmd.substring(last_cursor_pos));
      } else {
        /* goto the start of the line */
        move_cursor(-ucs_length(last_cmd.substring(0, last_cursor_pos)));
        if (show_colors) {
          var str = mexpr ? mexpr + "\n" + cmd : cmd;
          var start = str.length - cmd.length;
          var colorstate = colorize_js(str);
          print_color_text(str, start, colorstate[2]);
        } else {
          std.puts(cmd);
        }
      }
      term_cursor_x = (term_cursor_x + ucs_length(cmd)) % term_width;
      if (term_cursor_x == 0) {
        /* show the cursor on the next line */
        std.puts(" \x08");
      }
      /* remove the trailing characters */
      std.puts("\x1b[J");
      last_cmd = cmd;
      last_cursor_pos = cmd.length;
    }
    if (cursor_pos > last_cursor_pos) {
      move_cursor(ucs_length(cmd.substring(last_cursor_pos, cursor_pos)));
    } else if (cursor_pos < last_cursor_pos) {
      move_cursor(-ucs_length(cmd.substring(cursor_pos, last_cursor_pos)));
    }
    last_cursor_pos = cursor_pos;
    std.out.flush();
  }

  /* editing commands */
  function insert(str) {
    if (str) {
      cmd = cmd.substring(0, cursor_pos) + str + cmd.substring(cursor_pos);
      cursor_pos += str.length;
    }
  }
  function quoted_insert() {
    quote_flag = true;
  }
  function abort() {
    cmd = "";
    cursor_pos = 0;
    return -2;
  }
  function alert() {}
  function beginning_of_line() {
    cursor_pos = 0;
  }
  function end_of_line() {
    cursor_pos = cmd.length;
  }
  function forward_char() {
    if (cursor_pos < cmd.length) {
      cursor_pos++;
      while (is_trailing_surrogate(cmd.charAt(cursor_pos))) {
        cursor_pos++;
      }
    }
  }
  function backward_char() {
    if (cursor_pos > 0) {
      cursor_pos--;
      while (is_trailing_surrogate(cmd.charAt(cursor_pos))) {
        cursor_pos--;
      }
    }
  }
  function skip_word_forward(pos) {
    while (pos < cmd.length && !is_word(cmd.charAt(pos))) {
      pos++;
    }
    while (pos < cmd.length && is_word(cmd.charAt(pos))) {
      pos++;
    }
    return pos;
  }
  function skip_word_backward(pos) {
    while (pos > 0 && !is_word(cmd.charAt(pos - 1))) {
      pos--;
    }
    while (pos > 0 && is_word(cmd.charAt(pos - 1))) {
      pos--;
    }
    return pos;
  }
  function forward_word() {
    cursor_pos = skip_word_forward(cursor_pos);
  }
  function backward_word() {
    cursor_pos = skip_word_backward(cursor_pos);
  }
  function accept_line() {
    std.puts("\n");
    history_add(cmd);
    return -1;
  }
  function history_add(str) {
    if (str) {
      history.push(str);
    }
    history_index = history.length;
  }
  function previous_history() {
    if (history_index > 0) {
      if (history_index == history.length) {
        history.push(cmd);
      }
      history_index--;
      cmd = history[history_index];
      cursor_pos = cmd.length;
    }
  }
  function next_history() {
    if (history_index < history.length - 1) {
      history_index++;
      cmd = history[history_index];
      cursor_pos = cmd.length;
    }
  }
  function history_search(dir) {
    var pos = cursor_pos;
    for (var i = 1; i <= history.length; i++) {
      var index = (history.length + i * dir + history_index) % history.length;
      if (history[index].substring(0, pos) == cmd.substring(0, pos)) {
        history_index = index;
        cmd = history[index];
        return;
      }
    }
  }
  function history_search_backward() {
    return history_search(-1);
  }
  function history_search_forward() {
    return history_search(1);
  }
  function delete_char_dir(dir) {
    var start, end;
    start = cursor_pos;
    if (dir < 0) {
      start--;
      while (is_trailing_surrogate(cmd.charAt(start))) {
        start--;
      }
    }
    end = start + 1;
    while (is_trailing_surrogate(cmd.charAt(end))) {
      end++;
    }
    if (start >= 0 && start < cmd.length) {
      if (last_fun === kill_region) {
        kill_region(start, end, dir);
      } else {
        cmd = cmd.substring(0, start) + cmd.substring(end);
        cursor_pos = start;
      }
    }
  }
  function delete_char() {
    delete_char_dir(1);
  }
  function control_d() {
    if (cmd.length == 0) {
      std.puts("\n");
      return -3; /* exit read eval print loop */
    } else {
      delete_char_dir(1);
    }
  }
  function backward_delete_char() {
    delete_char_dir(-1);
  }
  function transpose_chars() {
    var pos = cursor_pos;
    if (cmd.length > 1 && pos > 0) {
      if (pos == cmd.length) {
        pos--;
      }
      cmd = cmd.substring(0, pos - 1) + cmd.substring(pos, pos + 1) + cmd.substring(pos - 1, pos) + cmd.substring(pos + 1);
      cursor_pos = pos + 1;
    }
  }
  function transpose_words() {
    var p1 = skip_word_backward(cursor_pos);
    var p2 = skip_word_forward(p1);
    var p4 = skip_word_forward(cursor_pos);
    var p3 = skip_word_backward(p4);
    if (p1 < p2 && p2 <= cursor_pos && cursor_pos <= p3 && p3 < p4) {
      cmd = cmd.substring(0, p1) + cmd.substring(p3, p4) + cmd.substring(p2, p3) + cmd.substring(p1, p2);
      cursor_pos = p4;
    }
  }
  function upcase_word() {
    var end = skip_word_forward(cursor_pos);
    cmd = cmd.substring(0, cursor_pos) + cmd.substring(cursor_pos, end).toUpperCase() + cmd.substring(end);
  }
  function downcase_word() {
    var end = skip_word_forward(cursor_pos);
    cmd = cmd.substring(0, cursor_pos) + cmd.substring(cursor_pos, end).toLowerCase() + cmd.substring(end);
  }
  function kill_region(start, end, dir) {
    var s = cmd.substring(start, end);
    if (last_fun !== kill_region) {
      clip_board = s;
    } else if (dir < 0) {
      clip_board = s + clip_board;
    } else {
      clip_board = clip_board + s;
    }
    cmd = cmd.substring(0, start) + cmd.substring(end);
    if (cursor_pos > end) {
      cursor_pos -= end - start;
    } else if (cursor_pos > start) {
      cursor_pos = start;
    }
    this_fun = kill_region;
  }
  function kill_line() {
    kill_region(cursor_pos, cmd.length, 1);
  }
  function backward_kill_line() {
    kill_region(0, cursor_pos, -1);
  }
  function kill_word() {
    kill_region(cursor_pos, skip_word_forward(cursor_pos), 1);
  }
  function backward_kill_word() {
    kill_region(skip_word_backward(cursor_pos), cursor_pos, -1);
  }
  function yank() {
    insert(clip_board);
  }
  function control_c() {
    if (last_fun === control_c) {
      std.puts("\n");
      std.exit(0);
    } else {
      std.puts("\n(Press Ctrl-C again to quit)\n");
      readline_print_prompt();
    }
  }
  function reset() {
    cmd = "";
    cursor_pos = 0;
  }
  function get_context_word(line, pos) {
    var s = "";
    while (pos > 0 && is_word(line[pos - 1])) {
      pos--;
      s = line[pos] + s;
    }
    return s;
  }
  function get_context_object(line, pos) {
    var obj, base, c;
    if (pos <= 0 || " ~!%^&*(-+={[|:;,<>?/".indexOf(line[pos - 1]) >= 0) {
      return globalThis;
    }
    if (pos >= 2 && line[pos - 1] === ".") {
      pos--;
      obj = {};
      switch (c = line[pos - 1]) {
        case "'":
        case '"':
          return "a";
        case "]":
          return [];
        case "}":
          return {};
        case "/":
          return / /;
        default:
          if (is_word(c)) {
            base = get_context_word(line, pos);
            if (["true", "false", "null", "this"].includes(base) || !isNaN(+base)) {
              return eval(base);
            }
            obj = get_context_object(line, pos - base.length);
            if (obj === null || obj === void 0) {
              return obj;
            }
            if (obj === globalThis && obj[base] === void 0) {
              return eval(base);
            } else {
              return obj[base];
            }
          }
          return {};
      }
    }
    return void 0;
  }
  function get_completions(line, pos) {
    var s, obj, ctx_obj, r, i, j;
    s = get_context_word(line, pos);
    ctx_obj = get_context_object(line, pos - s.length);
    r = [];
    // enumerate properties from object and its prototype chain,
    // add non-numeric regular properties with s as e prefix
    for (i = 0, obj = ctx_obj; i < 10 && obj !== null && obj !== void 0; i++) {
      var props = Object.getOwnPropertyNames(obj);
      /* add non-numeric regular properties */
      for (j = 0; j < props.length; j++) {
        var prop = props[j];
        if (typeof prop == "string" && String(Number(prop)) != prop && prop.startsWith(s)) {
          r.push(prop);
        }
      }
      obj = Object.getPrototypeOf(obj);
    }
    if (r.length > 1) {
      /* sort list with internal names last and remove duplicates */
      function symcmp(a, b) {
        if (a[0] != b[0]) {
          if (a[0] == "_") {
            return 1;
          }
          if (b[0] == "_") {
            return -1;
          }
        }
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return +1;
        }
        return 0;
      }
      r.sort(symcmp);
      for (i = j = 1; i < r.length; i++) {
        if (r[i] != r[i - 1]) {
          r[j++] = r[i];
        }
      }
      r.length = j;
    }
    /* 'tab' = list of completions, 'pos' = cursor position inside
           the completions */
    return {
      tab: r,
      pos: s.length,
      ctx: ctx_obj
    };
  }
  function completion() {
    var tab, res, s, i, j, len, t, max_width, col, n_cols, row, n_rows;
    res = get_completions(cmd, cursor_pos);
    tab = res.tab;
    if (tab.length === 0) {
      return;
    }
    s = tab[0];
    len = s.length;
    /* add the chars which are identical in all the completions */
    for (i = 1; i < tab.length; i++) {
      t = tab[i];
      for (j = 0; j < len; j++) {
        if (t[j] !== s[j]) {
          len = j;
          break;
        }
      }
    }
    for (i = res.pos; i < len; i++) {
      insert(s[i]);
    }
    if (last_fun === completion && tab.length == 1) {
      /* append parentheses to function names */
      var m = res.ctx[tab[0]];
      if (typeof m == "function") {
        insert("(");
        if (m.length == 0) {
          insert(")");
        }
      } else if (typeof m == "object") {
        insert(".");
      }
    }
    /* show the possible completions */
    if (last_fun === completion && tab.length >= 2) {
      max_width = 0;
      for (i = 0; i < tab.length; i++) {
        max_width = Math.max(max_width, tab[i].length);
      }
      max_width += 2;
      n_cols = Math.max(1, Math.floor((term_width + 1) / max_width));
      n_rows = Math.ceil(tab.length / n_cols);
      std.puts("\n");
      /* display the sorted list column-wise */
      for (row = 0; row < n_rows; row++) {
        for (col = 0; col < n_cols; col++) {
          i = col * n_rows + row;
          if (i >= tab.length) {
            break;
          }
          s = tab[i];
          if (col != n_cols - 1) {
            s = s.padEnd(max_width);
          }
          std.puts(s);
        }
        std.puts("\n");
      }
      /* show a new prompt */
      readline_print_prompt();
    }
  }

  /* command table */
  var commands = {
    "\x01": beginning_of_line /* ^A - bol */,
    "\x02": backward_char /* ^B - backward-char */,
    "\x03": control_c /* ^C - abort */,
    "\x04": control_d /* ^D - delete-char or exit */,
    "\x05": end_of_line /* ^E - eol */,
    "\x06": forward_char /* ^F - forward-char */,
    "\x07": abort /* ^G - bell */,
    "\x08": backward_delete_char /* ^H - backspace */,
    "\x09": completion /* ^I - history-search-backward */,
    "\x0a": accept_line /* ^J - newline */,
    "\x0b": kill_line /* ^K - delete to end of line */,
    "\x0d": accept_line /* ^M - enter */,
    "\x0e": next_history /* ^N - down */,
    "\x10": previous_history /* ^P - up */,
    "\x11": quoted_insert /* ^Q - quoted-insert */,
    "\x12": alert /* ^R - reverse-search */,
    "\x13": alert /* ^S - search */,
    "\x14": transpose_chars /* ^T - transpose */,
    "\x18": reset /* ^X - cancel */,
    "\x19": yank /* ^Y - yank */,
    "\x1bOA": previous_history /* ^[OA - up */,
    "\x1bOB": next_history /* ^[OB - down */,
    "\x1bOC": forward_char /* ^[OC - right */,
    "\x1bOD": backward_char /* ^[OD - left */,
    "\x1bOF": forward_word /* ^[OF - ctrl-right */,
    "\x1bOH": backward_word /* ^[OH - ctrl-left */,
    "\x1b[1;5C": forward_word /* ^[[1;5C - ctrl-right */,
    "\x1b[1;5D": backward_word /* ^[[1;5D - ctrl-left */,
    "\x1b[1~": beginning_of_line /* ^[[1~ - bol */,
    "\x1b[3~": delete_char /* ^[[3~ - delete */,
    "\x1b[4~": end_of_line /* ^[[4~ - eol */,
    "\x1b[5~": history_search_backward /* ^[[5~ - page up */,
    "\x1b[6~": history_search_forward /* ^[[5~ - page down */,
    "\x1b[A": previous_history /* ^[[A - up */,
    "\x1b[B": next_history /* ^[[B - down */,
    "\x1b[C": forward_char /* ^[[C - right */,
    "\x1b[D": backward_char /* ^[[D - left */,
    "\x1b[F": end_of_line /* ^[[F - end */,
    "\x1b[H": beginning_of_line /* ^[[H - home */,
    "\x1b\x7f": backward_kill_word /* M-C-? - backward_kill_word */,
    "\x1bb": backward_word /* M-b - backward_word */,
    "\x1bd": kill_word /* M-d - kill_word */,
    "\x1bf": forward_word /* M-f - backward_word */,
    "\x1bk": backward_kill_line /* M-k - backward_kill_line */,
    "\x1bl": downcase_word /* M-l - downcase_word */,
    "\x1bt": transpose_words /* M-t - transpose_words */,
    "\x1bu": upcase_word /* M-u - upcase_word */,
    "\x7f": backward_delete_char /* ^? - delete */
  };

  function dupstr(str, count) {
    var res = "";
    while (count-- > 0) {
      res += str;
    }
    return res;
  }
  var readline_keys;
  var readline_state;
  var readline_cb;
  function readline_print_prompt() {
    std.puts(prompt);
    term_cursor_x = ucs_length(prompt) % term_width;
    last_cmd = "";
    last_cursor_pos = 0;
  }
  function readline_start(defstr, cb) {
    cmd = defstr || "";
    cursor_pos = cmd.length;
    history_index = history.length;
    readline_cb = cb;
    prompt = pstate;
    if (mexpr) {
      prompt += dupstr(" ", plen - prompt.length);
      prompt += ps2;
    } else {
      if (show_time) {
        var t = Math.round(eval_time) + " ";
        eval_time = 0;
        t = dupstr("0", 5 - t.length) + t;
        prompt += t.substring(0, t.length - 4) + "." + t.substring(t.length - 4);
      }
      plen = prompt.length;
      prompt += ps1;
    }
    readline_print_prompt();
    update();
    readline_state = 0;
  }
  function handle_char(c1) {
    var c;
    c = String.fromCodePoint(c1);
    switch (readline_state) {
      case 0:
        if (c == "\x1b") {
          /* '^[' - ESC */
          readline_keys = c;
          readline_state = 1;
        } else {
          handle_key(c);
        }
        break;
      case 1 /* '^[ */:
        readline_keys += c;
        if (c == "[") {
          readline_state = 2;
        } else if (c == "O") {
          readline_state = 3;
        } else {
          handle_key(readline_keys);
          readline_state = 0;
        }
        break;
      case 2 /* '^[[' - CSI */:
        readline_keys += c;
        if (!(c == ";" || c >= "0" && c <= "9")) {
          handle_key(readline_keys);
          readline_state = 0;
        }
        break;
      case 3 /* '^[O' - ESC2 */:
        readline_keys += c;
        handle_key(readline_keys);
        readline_state = 0;
        break;
    }
  }
  function handle_key(keys) {
    var fun;
    if (quote_flag) {
      if (ucs_length(keys) === 1) {
        insert(keys);
      }
      quote_flag = false;
    } else if (fun = commands[keys]) {
      this_fun = fun;
      switch (fun(keys)) {
        case -1:
          readline_cb(cmd);
          return;
        case -2:
          readline_cb(null);
          return;
        case -3:
          /* uninstall a Ctrl-C signal handler */
          os.signal(os.SIGINT, null);
          /* uninstall the stdin read handler */
          os.setReadHandler(term_fd, null);
          return;
      }
      last_fun = this_fun;
    } else if (ucs_length(keys) === 1 && keys >= " ") {
      insert(keys);
      last_fun = insert;
    } else {
      alert(); /* beep! */
    }

    cursor_pos = cursor_pos < 0 ? 0 : cursor_pos > cmd.length ? cmd.length : cursor_pos;
    update();
  }
  function extract_directive(a) {
    var pos;
    if (a[0] !== "\\") {
      return "";
    }
    for (pos = 1; pos < a.length; pos++) {
      if (!is_alpha(a[pos])) {
        break;
      }
    }
    return a.substring(1, pos);
  }

  /* return true if the string after cmd can be evaluted as JS */
  function handle_directive(cmd, expr) {
    var param, prec1, expBits1;
    if (cmd === "h" || cmd === "?" || cmd == "help") {
      help();
    } else if (cmd === "load") {
      var filename = expr.substring(cmd.length + 1).trim();
      if (filename.lastIndexOf(".") <= filename.lastIndexOf("/")) {
        filename += ".js";
      }
      std.loadScript(filename);
      return false;
    } else if (cmd === "t") {
      show_time = !show_time;
    } else if (cmd === "clear") {
      std.puts("\x1b[H\x1b[J");
    } else if (cmd === "q") {
      std.exit(0);
    } else {
      std.puts("Unknown directive: " + cmd + "\n");
      return false;
    }
    return true;
  }
  function help() {
    function sel(n) {
      return n ? "*" : " ";
    }
    std.puts("\\h          this help\n" + "\\t         " + sel(show_time) + "toggle timing display\n" + "\\clear      clear the terminal\n");
    std.puts("\\q          exit\n");
  }
  function eval_and_print(expr) {
    var result;
    try {
      const newExpr = compileExpression(expr);
      if (newExpr !== expr) {
        std.puts(colors.gray);
        std.puts(`-> ${newExpr.replace(/\s+/g, " ")}`);
        std.puts(colors.none);
        std.puts("\n");
        expr = newExpr;
      }
      var now = new Date().getTime();
      /* eval as a script */
      result = std.evalScript(expr, {
        backtraceBarrier: true
      });
      eval_time = new Date().getTime() - now;
      std.puts(colors.none);
      if (result !== _special.NOTHING) {
        std.puts(inspect(result, inspectOptions.forPrint));
        std.puts(colors.none);
        std.puts("\n");
      }
      /* set the last result */
      globalThis._ = result;
    } catch (error) {
      globalThis._error = error;
      std.puts(colors[styles.error_msg]);
      (0, _printError.default)(error, std.out);
      std.puts(colors.none);
    }
  }
  function cmd_readline_start() {
    readline_start(dupstr("    ", level), readline_handle_cmd);
  }
  function readline_handle_cmd(expr) {
    handle_cmd(expr);
    cmd_readline_start();
  }
  function handle_cmd(expr) {
    var colorstate, cmd;
    if (expr === null) {
      expr = "";
      return;
    }
    if (expr === "?") {
      help();
      return;
    }
    cmd = extract_directive(expr);
    if (cmd.length > 0) {
      if (!handle_directive(cmd, expr)) {
        return;
      }
      expr = expr.substring(cmd.length + 1);
    }
    if (expr === "") {
      return;
    }
    if (mexpr) {
      expr = mexpr + "\n" + expr;
    }
    colorstate = colorize_js(expr);
    pstate = colorstate[0];
    level = colorstate[1];
    if (pstate) {
      mexpr = expr;
      return;
    }
    mexpr = "";
    eval_and_print(expr);
    level = 0;

    /* run the garbage collector after each command */
    std.gc();
  }
  function colorize_js(str) {
    var i,
      c,
      start,
      n = str.length;
    var style,
      state = "",
      level = 0;
    var can_regex = 1;
    var r = [];
    function push_state(c) {
      state += c;
    }
    function last_state(c) {
      return state.substring(state.length - 1);
    }
    function pop_state(c) {
      var c = last_state();
      state = state.substring(0, state.length - 1);
      return c;
    }
    function parse_block_comment() {
      style = "comment";
      push_state("/");
      for (i++; i < n - 1; i++) {
        if (str[i] == "*" && str[i + 1] == "/") {
          i += 2;
          pop_state("/");
          break;
        }
      }
    }
    function parse_line_comment() {
      style = "comment";
      for (i++; i < n; i++) {
        if (str[i] == "\n") {
          break;
        }
      }
    }
    function parse_string(delim) {
      style = "string";
      push_state(delim);
      while (i < n) {
        c = str[i++];
        if (c == "\n") {
          style = "error";
          continue;
        }
        if (c == "\\") {
          if (i >= n) {
            break;
          }
          i++;
        } else if (c == delim) {
          pop_state();
          break;
        }
      }
    }
    function parse_regex() {
      style = "regex";
      push_state("/");
      while (i < n) {
        c = str[i++];
        if (c == "\n") {
          style = "error";
          continue;
        }
        if (c == "\\") {
          if (i < n) {
            i++;
          }
          continue;
        }
        if (last_state() == "[") {
          if (c == "]") {
            pop_state();
          }
          // ECMA 5: ignore '/' inside char classes
          continue;
        }
        if (c == "[") {
          push_state("[");
          if (str[i] == "[" || str[i] == "]") {
            i++;
          }
          continue;
        }
        if (c == "/") {
          pop_state();
          while (i < n && is_word(str[i])) {
            i++;
          }
          break;
        }
      }
    }
    function parse_number() {
      style = "number";
      while (i < n && (is_word(str[i]) || str[i] == "." && (i == n - 1 || str[i + 1] != "."))) {
        i++;
      }
    }
    var js_literals = "|true|false|null|undefined";
    var js_keywords = "|" + "break|case|catch|continue|debugger|default|delete|do|" + "else|finally|for|function|if|in|instanceof|new|" + "return|switch|this|throw|try|typeof|while|with|" + "class|const|enum|import|export|extends|super|" + "implements|interface|let|package|private|protected|" + "public|static|yield|" + "Infinity|NaN|" + "eval|arguments|" + "void|var|" + "await|";
    var js_no_regex = "|this|super|undefined|null|true|false|Infinity|NaN|arguments|";
    function parse_identifier() {
      can_regex = 1;
      while (i < n && is_word(str[i])) {
        i++;
      }
      var w = "|" + str.substring(start, i) + "|";
      const isLiteral = js_literals.indexOf(w) >= 0;
      const isKeyword = js_keywords.indexOf(w) >= 0;
      if (isLiteral || isKeyword) {
        if (isLiteral) {
          style = "literal";
        } else if (isKeyword) {
          style = "keyword";
        }
        if (js_no_regex.indexOf(w) >= 0) {
          can_regex = 0;
        }
        return;
      }
      var i1 = i;
      while (i1 < n && str[i1] == " ") {
        i1++;
      }
      if (i1 < n && str[i1] == "(") {
        style = "function";
        return;
      }
      style = "identifier";
      can_regex = 0;
    }
    function set_style(from, to) {
      while (r.length < from) {
        r.push("default");
      }
      while (r.length < to) {
        r.push(style);
      }
    }
    for (i = 0; i < n;) {
      style = null;
      start = i;
      switch (c = str[i++]) {
        case " ":
        case "\t":
        case "\r":
        case "\n":
          continue;
        case "+":
        case "-":
          if (i < n && str[i] == c) {
            i++;
            continue;
          }
          can_regex = 1;
          continue;
        case "/":
          if (i < n && str[i] == "*") {
            // block comment
            parse_block_comment();
            break;
          }
          if (i < n && str[i] == "/") {
            // line comment
            parse_line_comment();
            break;
          }
          if (can_regex) {
            parse_regex();
            can_regex = 0;
            break;
          }
          can_regex = 1;
          continue;
        case "'":
        case '"':
        case "`":
          parse_string(c);
          can_regex = 0;
          break;
        case "(":
        case "[":
        case "{":
          can_regex = 1;
          level++;
          push_state(c);
          continue;
        case ")":
        case "]":
        case "}":
          can_regex = 0;
          if (level > 0 && is_balanced(last_state(), c)) {
            level--;
            pop_state();
            continue;
          }
          style = "error";
          break;
        default:
          if (is_digit(c)) {
            parse_number();
            can_regex = 0;
            break;
          }
          if (is_word(c) || c == "$") {
            parse_identifier();
            break;
          }
          can_regex = 1;
          continue;
      }
      if (style) {
        set_style(start, i);
      }
    }
    set_style(n, n);
    return [state, level, r];
  }
  termInit();
  cmd_readline_start();
}
}),
/* --- src/api/commands/extname.ts --- */
"src/api/commands/extname.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extname = extname;
var _basename = _kame_require_("src/api/commands/basename.ts");
function extname(pathOrFilename, options = {}) {
  const filename = (0, _basename.basename)(pathOrFilename);
  const parts = filename.split(".");
  if (parts.length === 1) {
    return "";
  }
  if (options.full) {
    return "." + parts.slice(1).join(".");
  } else {
    return "." + parts[parts.length - 1];
  }
}
}),
/* --- node_modules/kleur/index.js --- */
"node_modules/kleur/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

let FORCE_COLOR,
  NODE_DISABLE_COLORS,
  NO_COLOR,
  TERM,
  isTTY = true;
if (typeof process !== 'undefined') {
  ({
    FORCE_COLOR,
    NODE_DISABLE_COLORS,
    NO_COLOR,
    TERM
  } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
const $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY),
  // modifiers
  reset: init(0, 0),
  bold: init(1, 22),
  dim: init(2, 22),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  // colors
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  grey: init(90, 39),
  // background colors
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49)
};
function run(arr, str) {
  let i = 0,
    tmp,
    beg = '',
    end = '';
  for (; i < arr.length; i++) {
    tmp = arr[i];
    beg += tmp.open;
    end += tmp.close;
    if (!!~str.indexOf(tmp.close)) {
      str = str.replace(tmp.rgx, tmp.close + tmp.open);
    }
  }
  return beg + str + end;
}
function chain(has, keys) {
  let ctx = {
    has,
    keys
  };
  ctx.reset = $.reset.bind(ctx);
  ctx.bold = $.bold.bind(ctx);
  ctx.dim = $.dim.bind(ctx);
  ctx.italic = $.italic.bind(ctx);
  ctx.underline = $.underline.bind(ctx);
  ctx.inverse = $.inverse.bind(ctx);
  ctx.hidden = $.hidden.bind(ctx);
  ctx.strikethrough = $.strikethrough.bind(ctx);
  ctx.black = $.black.bind(ctx);
  ctx.red = $.red.bind(ctx);
  ctx.green = $.green.bind(ctx);
  ctx.yellow = $.yellow.bind(ctx);
  ctx.blue = $.blue.bind(ctx);
  ctx.magenta = $.magenta.bind(ctx);
  ctx.cyan = $.cyan.bind(ctx);
  ctx.white = $.white.bind(ctx);
  ctx.gray = $.gray.bind(ctx);
  ctx.grey = $.grey.bind(ctx);
  ctx.bgBlack = $.bgBlack.bind(ctx);
  ctx.bgRed = $.bgRed.bind(ctx);
  ctx.bgGreen = $.bgGreen.bind(ctx);
  ctx.bgYellow = $.bgYellow.bind(ctx);
  ctx.bgBlue = $.bgBlue.bind(ctx);
  ctx.bgMagenta = $.bgMagenta.bind(ctx);
  ctx.bgCyan = $.bgCyan.bind(ctx);
  ctx.bgWhite = $.bgWhite.bind(ctx);
  return ctx;
}
function init(open, close) {
  let blk = {
    open: `\x1b[${open}m`,
    close: `\x1b[${close}m`,
    rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
  };
  return function (txt) {
    if (this !== void 0 && this.has !== void 0) {
      !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
      return txt === void 0 ? this : $.enabled ? run(this.keys, txt + '') : txt + '';
    }
    return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + '') : txt + '';
  };
}
module.exports = $;
}),
/* --- node_modules/strip-ansi/index.js --- */
"node_modules/strip-ansi/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

const ansiRegex = _kame_require_("node_modules/ansi-regex/index.js");
module.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
}),
/* --- src/api/commands/_all.ts --- */
"src/api/commands/_all.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "basename", {
  enumerable: true,
  get: function () {
    return _basename.basename;
  }
});
Object.defineProperty(exports, "cat", {
  enumerable: true,
  get: function () {
    return _cat.cat;
  }
});
Object.defineProperty(exports, "cd", {
  enumerable: true,
  get: function () {
    return _cd.cd;
  }
});
Object.defineProperty(exports, "dirname", {
  enumerable: true,
  get: function () {
    return _dirname.dirname;
  }
});
Object.defineProperty(exports, "echo", {
  enumerable: true,
  get: function () {
    return _echo.echo;
  }
});
Object.defineProperty(exports, "extname", {
  enumerable: true,
  get: function () {
    return _extname.extname;
  }
});
Object.defineProperty(exports, "ls", {
  enumerable: true,
  get: function () {
    return _ls.ls;
  }
});
Object.defineProperty(exports, "printf", {
  enumerable: true,
  get: function () {
    return _printf.printf;
  }
});
Object.defineProperty(exports, "pwd", {
  enumerable: true,
  get: function () {
    return _pwd.pwd;
  }
});
Object.defineProperty(exports, "readlink", {
  enumerable: true,
  get: function () {
    return _readlink.readlink;
  }
});
Object.defineProperty(exports, "realpath", {
  enumerable: true,
  get: function () {
    return _realpath.realpath;
  }
});
var _basename = _kame_require_("src/api/commands/basename.ts");
var _cat = _kame_require_("src/api/commands/cat.ts");
var _cd = _kame_require_("src/api/commands/cd.ts");
var _dirname = _kame_require_("src/api/commands/dirname.ts");
var _echo = _kame_require_("src/api/commands/echo.ts");
var _extname = _kame_require_("src/api/commands/extname.ts");
var _ls = _kame_require_("src/api/commands/ls.ts");
var _printf = _kame_require_("src/api/commands/printf.ts");
var _pwd = _kame_require_("src/api/commands/pwd.ts");
var _readlink = _kame_require_("src/api/commands/readlink.ts");
var _realpath = _kame_require_("src/api/commands/realpath.ts");
}),
/* --- src/api/commands/_stubs.ts --- */
"src/api/commands/_stubs.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cp = cp;
exports.mkdir = mkdir;
function mkdir() {
  throw new Error("'mkdir' is not part of the yavascript API. Use 'ensureDir' instead");
}
function cp() {
  throw new Error("'cp' is not part of the yavascript API. Use 'copy' instead");
}
}),
/* --- src/api/env.ts --- */
"src/api/env.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.env = void 0;
var std = _interopRequireWildcard(_kame_require_("external:std"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const _env = std.getenviron();
const env = new Proxy(_env, {
  get(target, property, receiver) {
    if (typeof property === "symbol") return undefined;
    return std.getenv(property) || undefined;
  },
  set(target, property, value, receiver) {
    if (typeof property === "symbol") return false;
    if (value == null) {
      delete _env[property];
      std.unsetenv(property);
    } else {
      const strValue = String(value);
      _env[property] = strValue;
      std.setenv(property, strValue);
    }
    return true;
  },
  deleteProperty(target, property) {
    if (typeof property === "symbol") return false;
    std.unsetenv(property);
    delete _env[property];
    return true;
  },
  ownKeys(target) {
    return Object.keys(std.getenviron());
  },
  has(target, property) {
    if (typeof property === "symbol") return false;
    const result = std.getenv(property);
    return typeof result !== "undefined";
  }
});
exports.env = env;
}),
/* --- src/api/exec/index.ts --- */
"src/api/exec/index.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exec = _kame_require_("src/api/exec/exec.ts");
Object.keys(_exec).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _exec[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _exec[key];
    }
  });
});
}),
/* --- src/api/filesystem.ts --- */
"src/api/filesystem.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.ensureDir = ensureDir;
exports.exists = exists;
exports.isDir = isDir;
exports.isLink = isLink;
exports.readFile = readFile;
exports.remove = remove;
exports.writeFile = writeFile;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var os = _interopRequireWildcard(_kame_require_("external:os"));
var _basename = _kame_require_("src/api/commands/basename.ts");
var _paths = _kame_require_("src/api/paths.ts");
var _errorWithProperties = _kame_require_("src/error-with-properties.ts");
var _traceAll = _interopRequireDefault(_kame_require_("src/api/traceAll.ts"));
var _all = _kame_require_("src/api/commands/_all.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function readFile(path) {
  return std.loadFile(path);
}
function writeFile(path, data) {
  const file = std.open(path, "w");
  try {
    if (typeof data === "string") {
      file.puts(data);
    } else {
      file.write(data, 0, data.byteLength);
    }
  } finally {
    file.close();
  }
}
function isDir(path) {
  try {
    const stats = os.lstat(path);
    if (Boolean((os.S_IFMT & stats.mode) === os.S_IFLNK)) {
      return isDir(os.realpath(path));
    }
    return Boolean((os.S_IFMT & stats.mode) === os.S_IFDIR);
  } catch {
    return false;
  }
}
function isLink(path) {
  try {
    const stats = os.lstat(path);
    return Boolean((os.S_IFMT & stats.mode) === os.S_IFLNK);
  } catch {
    return false;
  }
}
function remove(path) {
  if (isDir(path)) {
    const children = os.readdir(path).filter(child => child !== "." && child !== "..").map(child => path + "/" + child);
    for (const child of children) {
      remove(child);
    }
  }
  os.remove(path);
}
function exists(path) {
  try {
    os.access(path, os.F_OK);
    return true;
  } catch (err) {
    return false;
  }
}
function getPathInfo(path) {
  if (isLink(path)) {
    try {
      const linkedPath = os.realpath(path);
      if (!exists(linkedPath)) return "nonexistent";
      if (isDir(linkedPath)) return "dir";
      return "file";
    } catch {
      return "nonexistent";
    }
  }
  if (!exists(path)) return "nonexistent";
  if (isDir(path)) return "dir";
  return "file";
}
function ensureDir(path) {
  const components = _paths.paths.split(path);
  for (let i = 0; i < components.length; i++) {
    const componentsSoFar = components.slice(0, i + 1);
    const pathSoFar = componentsSoFar.join(_paths.paths.OS_PATH_SEPARATOR);
    if (pathSoFar === ".") continue;
    const info = getPathInfo(pathSoFar);
    switch (info) {
      case "nonexistent":
        {
          os.mkdir(pathSoFar, 0o775);
          break;
        }
      case "dir":
        {
          break;
        }
      case "file":
        {
          throw new Error(`Wanted to ensure that the directory path ${path} existed, but ${pathSoFar} was a file, not a directory`);
        }
    }
  }
}
function copyRaw(from, to, trace = _traceAll.default.getDefaultTrace()) {
  let filesToCloseLater = {};
  try {
    if (trace) {
      trace("opening", from, "(mode: rb)");
    }
    const fromFile = std.open(from, "rb");
    filesToCloseLater[from] = fromFile;
    if (trace) {
      trace("opening", to, "(mode: w)");
    }
    const toFile = std.open(to, "w");
    filesToCloseLater[to] = toFile;
    const chunkSize = 256 * 1024; // 256KB
    const buffer = new ArrayBuffer(chunkSize);
    const fromSize = os.stat(from).size;
    if (trace) {
      trace("copying data", {
        from,
        to,
        chunkSize
      });
    }
    while (!fromFile.eof()) {
      const amountRemaining = fromSize - fromFile.tell();
      if (trace) {
        trace(`${amountRemaining} bytes remaining`);
      }
      if (amountRemaining === 0) break;
      const amountToRead = Math.min(amountRemaining, chunkSize);
      const bytesRead = fromFile.read(buffer, 0, amountToRead);
      if (trace) {
        trace(`read ${bytesRead} bytes into buffer`);
      }
      if (bytesRead === 0) break;
      if (trace) {
        trace(`writing ${bytesRead} bytes from buffer into file`);
      }
      toFile.write(buffer, 0, bytesRead);
    }
    if (trace) {
      trace("reached eof");
    }
  } catch (err) {
    if (trace) {
      trace("copyRaw failed:", {
        from,
        to,
        err
      });
    }
    throw err;
  } finally {
    try {
      for (const [fileName, file] of Object.entries(filesToCloseLater)) {
        if (trace) {
          trace("closing", fileName);
        }
        file.close();
      }
      filesToCloseLater = {};
    } catch (err) {
      if (trace) {
        trace("copyRaw failed to close a file:", {
          from,
          to,
          err
        });
      }
      // ignored
    }
  }
}

function copy(from, to, {
  whenTargetExists = "error",
  trace
} = {}) {
  if (!exists(from)) {
    throw new Error(`Source path does not exist: ${from}`);
  }
  const sourceInfo = getPathInfo(from);
  const targetInfo = getPathInfo(to);
  if (trace) {
    trace("copy requested", {
      from,
      to
    });
  }
  switch (`${sourceInfo} -> ${targetInfo}`) {
    case "dir -> file":
      {
        // Invalid
        throw new Error(`Attempting to copy folder to path where file already exists: ${to}`);
      }
    case "file -> dir":
      {
        // Copy file into dir
        const filename = (0, _basename.basename)(from);
        const target = _paths.paths.join(to, filename);
        copyRaw(from, target, trace);
        return;
      }
    case "file -> nonexistent":
      {
        // Copy to file at target path
        copyRaw(from, to, trace);
        return;
      }
    case "file -> file":
      {
        // Either overwrite, error, or skip, depending on whenTargetExists
        if (whenTargetExists === "error") {
          throw new Error(`File already exists: ${JSON.stringify(to)}. To skip or overwrite existing files, pass 'whenTargetExists' as an option to 'copy', with a value of either "skip" or "overwrite".`);
        } else if (whenTargetExists === "skip") {
          return;
        } else if (whenTargetExists === "overwrite") {
          copyRaw(from, to, trace);
        } else {
          throw new Error(`Invalid whenTargetExists value: ${whenTargetExists}`);
        }
        return;
      }
    case "dir -> nonexistent":
      {
        // Create new dir at target path and copy contents into it recursively
        if (trace) {
          trace("ensuring dir", to);
        }
        ensureDir(to);
        const children = (0, _all.ls)(from);
        for (const child of children) {
          const filename = (0, _basename.basename)(child);
          const target = _paths.paths.join(to, filename);
          copy(child, target, {
            whenTargetExists,
            trace
          });
        }
        return;
      }
    case "dir -> dir":
      {
        // Create new dir within target path and copy contents into it recursively
        const dirname = (0, _basename.basename)(from);
        const targetDir = _paths.paths.join(to, dirname);
        if (trace) {
          trace("ensuring dir", targetDir);
        }
        ensureDir(targetDir);
        const children = (0, _all.ls)(from);
        for (const child of children) {
          const filename = (0, _basename.basename)(child);
          const target = _paths.paths.join(targetDir, filename);
          copy(child, target, {
            whenTargetExists,
            trace
          });
        }
        return;
      }
    case "nonexistent -> nonexistent":
    case "nonexistent -> dir":
    case "nonexistent -> file":
      {
        throw (0, _errorWithProperties.makeErrorWithProperties)("Attempting to copy a nonexistent file", {
          from,
          to
        });
      }
    default:
      {
        throw new Error(`Unhandled situation in 'copy' function: ${JSON.stringify({
          sourceInfo,
          targetInfo,
          from,
          to
        })}`);
      }
  }
}
}),
/* --- src/api/paths.ts --- */
"src/api/paths.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.paths = void 0;
var os = _interopRequireWildcard(_kame_require_("external:os"));
var _errorWithProperties = _kame_require_("src/error-with-properties.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const paths = {
  OS_PATH_SEPARATOR: os.platform === "win32" ? "\\" : "/",
  split(inputParts) {
    if (!Array.isArray(inputParts)) {
      inputParts = [inputParts];
    }
    return inputParts.map(part => part.split(/(?:\/|\\)+/g)).flat(1).filter((part, index) => {
      if (index === 0) return true;
      return Boolean(part);
    });
  },
  detectSeparator(input) {
    let testStr = input;
    if (Array.isArray(input)) {
      testStr = input.join("|");
    }
    return testStr.includes("\\") ? "\\" : "/";
  },
  join(...parts) {
    const separator = paths.detectSeparator(parts);
    return paths.split(parts).join(separator);
  },
  resolve(path, from = os.getcwd()) {
    const parts = paths.split(path);
    const newParts = [];
    let currentPart;
    while (parts.length > 0) {
      currentPart = parts.shift();
      if (currentPart === "." || currentPart === "..") {
        if (newParts.length === 0) {
          const fromParts = paths.split(from);
          newParts.push(...fromParts);
        }
        if (currentPart === "..") {
          if (newParts.length > 0) {
            newParts.pop();
          } else {
            throw (0, _errorWithProperties.makeErrorWithProperties)("Cannot resolve leading ..", {
              from,
              path
            });
          }
        }
      } else if (currentPart != null) {
        newParts.push(currentPart);
      }
    }
    return newParts.join(paths.OS_PATH_SEPARATOR);
  },
  isAbsolute(path) {
    const parts = paths.split(path);
    const firstPart = parts[0];

    // empty first component indicates that path starts with leading slash
    if (firstPart === "") return true;

    // windows drive
    if (/^[A-Za-z]:/.test(firstPart)) return true;

    // TODO: windows UNC paths (not supported very well by these path APIs at all, yet)

    return false;
  }
};
exports.paths = paths;
}),
/* --- src/api/glob.ts --- */
"src/api/glob.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glob = glob;
var os = _interopRequireWildcard(_kame_require_("external:os"));
var _minimatch = _interopRequireDefault(_kame_require_("node_modules/minimatch/minimatch.js"));
var _filesystem = _kame_require_("src/api/filesystem.ts");
var _pwd = _kame_require_("src/api/commands/pwd.ts");
var _paths = _kame_require_("src/api/paths.ts");
var _errorWithProperties = _kame_require_("src/error-with-properties.ts");
var _traceAll = _interopRequireDefault(_kame_require_("src/api/traceAll.ts"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function compile(pattern, startingDir) {
  let prefix = "";
  if (pattern.startsWith("!")) {
    prefix = "!";
    pattern = pattern.slice(1);
  }
  const normalized = prefix + (_paths.paths.isAbsolute(pattern) ? pattern : _paths.paths.resolve("./" + pattern, startingDir));
  const regexp = _minimatch.default.makeRe(normalized);
  if (!regexp) {
    throw (0, _errorWithProperties.makeErrorWithProperties)("Invalid glob pattern", {
      pattern
    });
  }
  return regexp;
}
function glob(patterns, options = {}) {
  const dir = options.dir ?? (0, _pwd.pwd)();
  const trace = options.trace ?? _traceAll.default.getDefaultTrace();
  const patternsArray = Array.isArray(patterns) ? patterns : [patterns];
  if (!(0, _filesystem.exists)(dir)) {
    throw new Error(`No such directory: ${dir} (from ${(0, _pwd.pwd)()})`);
  }
  const startingDir = _paths.paths.resolve(dir);
  const allPatterns = patternsArray.map(pattern => {
    return {
      negated: pattern.startsWith("!"),
      pattern,
      regexp: compile(pattern, startingDir)
    };
  });
  const negatedPatterns = allPatterns.filter(({
    negated
  }) => negated);
  const matches = [];
  function find(searchDir) {
    if (trace) {
      trace(`reading children of ${searchDir}`);
    }
    const children = os.readdir(searchDir);
    if (trace) {
      trace(`found ${children.length} children of ${searchDir}`);
    }
    for (const child of children) {
      if (child === ".") continue;
      if (child === "..") continue;
      const fullName = searchDir + "/" + child;
      if (trace) {
        trace(`checking ${fullName}`);
      }
      try {
        let stat;
        if (options.followSymlinks) {
          stat = os.stat(fullName);
        } else {
          stat = os.lstat(fullName);
        }
        if (allPatterns.every(({
          pattern,
          negated,
          regexp
        }) => {
          let didMatch = regexp.test(fullName);
          if (trace) {
            trace("match info:", JSON.stringify({
              didMatch,
              pattern,
              negated,
              fullName
            }));
          }
          return didMatch;
        })) {
          matches.push(fullName);
        }
        if (os.S_IFDIR & stat.mode) {
          // Only traverse deeper dirs if this one doesn't match a negated
          // pattern.
          //
          // TODO: it'd be better if it also avoided traversing deeper when
          // it'd be impossible for deeper dirs to ever match the patterns.
          //
          // Honestly, it'd be great to just have a c globstar library that
          // took care of all of this for us... because you end up needing
          // to be aware of the glob pattern parsing and syntax in order to
          // know the optimal traversal path.
          let shouldGoDeeper = true;
          for (const {
            regexp,
            pattern
          } of negatedPatterns) {
            const matchesNegated = !regexp.test(fullName);
            if (matchesNegated) {
              if (trace) {
                trace(`not traversing deeper into dir as it matches a negated pattern: ${JSON.stringify({
                  dir: fullName,
                  pattern
                })}`);
              }
              shouldGoDeeper = false;
              break;
            }
          }
          if (shouldGoDeeper) {
            find(fullName);
          }
        }
      } catch (err) {
        try {
          const message = `glob encountered error: ${err.message}`;
          if (trace) {
            trace(message);
          }
          console.warn(message);
        } catch (err2) {
          // ignore
        }
      }
    }
  }
  find(startingDir);
  return matches;
}
}),
/* --- src/api/is.ts --- */
"src/api/is.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.is = void 0;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _is = _kame_require_("node_modules/@suchipi/is/dist/index.js");
var _jsx = _kame_require_("src/api/jsx.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const is = {
  ..._is.is,
  FILE(value) {
    return std.isFILE(value);
  },
  Module(value) {
    return value instanceof Module;
  },
  JSX: {
    Element(value) {
      return is.object(value) && value.$$typeof === _jsx.JSX.Element;
    },
    Fragment(value) {
      return is.JSX.Element(value) && value.type === _jsx.JSX.Fragment;
    }
  }
};
exports.is = is;
}),
/* --- src/api/repo.ts --- */
"src/api/repo.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isGitignored = isGitignored;
exports.repoRoot = repoRoot;
var _exec = _kame_require_("src/api/exec/index.ts");
var _pwd = _kame_require_("src/api/commands/pwd.ts");
var _dirname = _kame_require_("src/api/commands/dirname.ts");
var _filesystem = _kame_require_("src/api/filesystem.ts");
function repoRoot(relativeTo = (0, _pwd.pwd)()) {
  if ((0, _filesystem.exists)(relativeTo) && !(0, _filesystem.isDir)(relativeTo)) {
    relativeTo = (0, _dirname.dirname)(relativeTo);
  }
  try {
    const gitRootRun = (0, _exec.exec)(["git", "rev-parse", "--show-toplevel"], {
      captureOutput: true,
      failOnNonZeroStatus: false,
      cwd: relativeTo
    });
    if (gitRootRun.status === 0) {
      return gitRootRun.stdout.trim();
    }
  } catch (err) {}
  try {
    const hgRootRun = (0, _exec.exec)(["hg", "root"], {
      captureOutput: true,
      failOnNonZeroStatus: false,
      cwd: relativeTo
    });
    if (hgRootRun.status === 0) {
      return hgRootRun.stdout.trim();
    }
  } catch (err) {}
  throw new Error(`Fatal: ${relativeTo} is not within a git or hg repo, or git/hg were not found in PATH`);
}
function isGitignored(path) {
  const result = (0, _exec.exec)(["git", "check-ignore", path], {
    failOnNonZeroStatus: false,
    captureOutput: true
  });
  if (result.status !== 0 && result.status !== 1) {
    throw new Error("git check-ignore failed: " + result.stderr.trim());
  }
  return result.status === 0;
}
}),
/* --- src/api/console.ts --- */
"src/api/console.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.print = exports.console = void 0;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _makeInspectLog = _kame_require_("src/api/shared/make-inspect-log.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
// To overwrite the quickjs console object
const console = {
  log: (0, _makeInspectLog.makeInspectLog)(std.out),
  info: (0, _makeInspectLog.makeInspectLog)(std.out),
  warn: (0, _makeInspectLog.makeInspectLog)(std.err),
  error: (0, _makeInspectLog.makeInspectLog)(std.err)
};

// To overwrite the quickjs globalThis.print
exports.console = console;
const print = (0, _makeInspectLog.makeInspectLog)(std.out);
exports.print = print;
}),
/* --- src/api/pipe.ts --- */
"src/api/pipe.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pipe = void 0;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _byte = _kame_require_("src/api/byte.ts");
var _is = _kame_require_("src/api/is.ts");
var _errorWithProperties = _kame_require_("src/error-with-properties.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function getReadable(from) {
  let source = null;
  let maxLength = Infinity;
  let until = null;
  let shouldCloseFile = false;
  if (_is.is.string(from)) {
    throw new Error("It is ambiguous whether you want to read from the string's contents or from the file at the path contained within the string. Pass an object with a 'data' or 'path' property, instead.");
  }
  if (_is.is.object(from)) {
    if (_is.is.number(from.maxLength)) {
      maxLength = from.maxLength;
    }
    if (_is.is.string(from.until)) {
      if (from.until.length !== 1) {
        const received = from.until;
        throw (0, _errorWithProperties.makeErrorWithProperties)("Only single-byte strings or integers from 0 to 255 may be used as 'until'", {
          received
        });
      }
      until = from.until.charCodeAt(0);
    }
    if (_is.is.number(from.until)) {
      const isInteger = from.until % 1 === 0;
      if (from.until < 0 || !isInteger || from.until > 255) {
        const received = from.until;
        throw (0, _errorWithProperties.makeErrorWithProperties)("Only single-byte strings or integers from 0 to 255 may be used as 'until'", {
          received
        });
      }
      until = from.until;
    }
    if (from.data != null) {
      source = from.data;
    } else if (typeof from.path === "string") {
      source = std.open(from.path, "rb");
      shouldCloseFile = true;
    } else if (typeof from.fd === "number") {
      source = std.fdopen(from.fd, "rb");
      shouldCloseFile = true;
    } else {
      source = from;
    }
  }
  if (source == null) {
    throw (0, _errorWithProperties.makeErrorWithProperties)("Invalid argument", {
      from
    });
  }
  if (_is.is.TypedArray(source) || _is.is.ArrayBuffer(source) || _is.is.SharedArrayBuffer(source) || _is.is.DataView(source)) {
    const view = _is.is.DataView(source) ? source : _is.is.TypedArray(source) ? new DataView(source.buffer) : new DataView(source);
    let offset = 0;
    let reachedUntil = false;
    return {
      close() {},
      read() {
        if (offset === view.byteLength || offset === maxLength || reachedUntil) {
          return null;
        }
        const byte = view.getUint8(offset);
        offset++;
        if (until !== null && byte === until) {
          reachedUntil = true;
        }
        return byte;
      }
    };
  } else if (_is.is.FILE(source)) {
    const file = source;
    let offset = 0;
    let reachedUntil = false;
    return {
      close() {
        if (shouldCloseFile) {
          file.close();
        }
      },
      read() {
        if (offset === maxLength || reachedUntil) {
          return null;
        }
        const byte = file.getByte();
        offset++;
        if (byte === -1) {
          return null;
        }
        if (until !== null && byte === until) {
          reachedUntil = true;
        }
        return byte;
      }
    };
  } else if (typeof source === "string") {
    const str = source;
    let offset = 0;
    let reachedUntil = false;
    return {
      close() {},
      read() {
        if (offset === maxLength || reachedUntil) {
          return null;
        }
        const byte = str.charCodeAt(offset);
        offset++;
        if (_is.is.NaN(byte)) {
          return null;
        }
        if (until !== null && byte === until) {
          reachedUntil = true;
        }
        return byte;
      }
    };
  } else {
    throw (0, _errorWithProperties.makeErrorWithProperties)("Invalid readable source", {
      from
    });
  }
}
function resizeBuffer(inputBuffer, newSize) {
  const newBuffer = _is.is.ArrayBuffer(inputBuffer) ? new ArrayBuffer(newSize) : new SharedArrayBuffer(newSize);
  const oldView = new DataView(inputBuffer);
  const newView = new DataView(newBuffer);
  const byteCount = Math.min(newSize, inputBuffer.byteLength);
  for (let i = 0; i < byteCount; i++) {
    newView.setUint8(i, oldView.getUint8(i));
  }
  return newBuffer;
}
function getWritable(to) {
  if (!(_is.is.object(to) || _is.is.function(to))) {
    throw (0, _errorWithProperties.makeErrorWithProperties)("'to' must be a function or object, but received something else", {
      to
    });
  }
  const filesToClose = [];
  try {
    let target;
    if (_is.is.string(to.path)) {
      const file = std.open(to.path, "w");
      filesToClose.push(file);
      target = file;
    } else if (_is.is.number(to.fd)) {
      const file = std.fdopen(to.fd, "w");
      filesToClose.push(file);
      target = file;
    } else if (_is.is.ArrayBuffer(to) || _is.is.SharedArrayBuffer(to) || _is.is.DataView(to) || _is.is.TypedArray(to) || _is.is.FILE(to)) {
      target = to;
      if (_is.is.ArrayBuffer(target) || _is.is.SharedArrayBuffer(target) || _is.is.DataView(target) || _is.is.TypedArray(target)) {
        let offset = 0;
        let limit = target.byteLength;
        const view = _is.is.DataView(target) ? target : _is.is.TypedArray(target) ? new DataView(target.buffer) : new DataView(target);
        return {
          write(byte) {
            if (offset === limit) {
              return false;
            }
            view.setUint8(offset, byte);
            offset++;
            return true;
          },
          result() {
            return target;
          }
        };
      } else if (_is.is.FILE(target)) {
        return {
          write(byte) {
            try {
              target.putByte(byte);
              return true;
            } catch {
              return false;
            }
          },
          result() {
            for (const file of filesToClose) {
              file.close();
            }
            if (filesToClose.length > 0) {
              return to;
            } else {
              return target;
            }
          }
        };
      }
    } else if (_is.is.function(to)) {
      const targetConstructor = to;
      switch (targetConstructor) {
        case String:
          {
            let target = "";
            return {
              write(byte) {
                target += String.fromCharCode(byte);
                return true;
              },
              result() {
                return target;
              }
            };
          }
        default:
          {
            let offset = 0;
            let buffer = targetConstructor === SharedArrayBuffer ? new SharedArrayBuffer(0) : new ArrayBuffer(0);
            let view = new DataView(buffer);
            return {
              write(byte) {
                if (offset === buffer.byteLength) {
                  buffer = resizeBuffer(buffer, Math.max(buffer.byteLength, 1) * 2);
                  view = new DataView(buffer);
                }
                view.setUint8(offset, byte);
                offset++;
                return true;
              },
              result() {
                switch (targetConstructor) {
                  case ArrayBuffer:
                  case SharedArrayBuffer:
                    {
                      buffer = resizeBuffer(buffer, offset);
                      return buffer;
                    }
                  case DataView:
                    {
                      return view;
                    }
                  // String is not reachable here because it was handled in an
                  // earlier switch statement
                  default:
                    {
                      buffer = resizeBuffer(buffer, offset);
                      return new targetConstructor(buffer);
                    }
                }
              }
            };
          }
      }
    } else {
      throw (0, _errorWithProperties.makeErrorWithProperties)("Invalid argument", {
        to
      });
    }
  } catch (err) {
    for (const file of filesToClose) {
      file.close();
    }
    throw err;
  }

  // Shouldn't be possible to get here, but...
  throw (0, _errorWithProperties.makeErrorWithProperties)("Internal error: Unhandled destination", {
    to
  });
}

// TODO: child process stdio should be pipeable; would need to introduce child
// type to return from exec
const pipe = (from, to) => {
  const readable = getReadable(from);
  const writable = getWritable(to);
  let bytesTransferred = 0;
  let byte;
  while (byte = readable.read(), byte != null) {
    const wrote = writable.write(byte);
    if (!wrote) break;
    bytesTransferred++;
  }
  readable.close();
  return {
    bytesTransferred,
    target: writable.result()
  };
};
exports.pipe = pipe;
}),
/* --- src/api/others.ts --- */
"src/api/others.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.symbol = exports.string = exports.number = exports.boolean = exports.bigint = void 0;
// Convenience aliases for parity with TypeScript primitive types
const bigint = BigInt;
exports.bigint = bigint;
const boolean = Boolean;
exports.boolean = boolean;
const number = Number;
exports.number = number;
const string = String;
exports.string = string;
const symbol = Symbol;
exports.symbol = symbol;
}),
/* --- src/api/jsx.ts --- */
"src/api/jsx.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JSX = void 0;
const Fragment = Symbol("JSX.Fragment");
const Element = Symbol("JSX.Element");
const JSX = {
  pragma: "JSX.createElement",
  pragmaFrag: "JSX.Fragment",
  Fragment,
  Element,
  createElement(type, props, ...children) {
    if (children.length > 0) {
      props = props ?? {};
      props.children = children;
    }
    let key = null;
    if (props != null) {
      key = props.key ?? null;
    }
    return {
      $$typeof: Element,
      type,
      props,
      key
    };
  }
};
exports.JSX = JSX;
}),
/* --- src/api/csv.ts --- */
"src/api/csv.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CSV = void 0;
var _papaparse = _interopRequireDefault(_kame_require_("node_modules/papaparse/papaparse.js"));
const CSV = {
  parse(input) {
    const {
      data,
      errors
    } = _papaparse.default.parse(input, {
      header: false
    });
    if (errors.length > 0) {
      const messageParts = ["CSV parse failed:", ...errors.map(error => {
        return `Row ${error.row + 1}: ${error.code}: ${error.message}`;
      })];
      let message;
      if (messageParts.length <= 2) {
        message = messageParts.join(" ");
      } else {
        message = [messageParts[0], ...messageParts.slice(1).map(part => "- " + part)].join("\n");
      }
      throw new Error(message);
    }
    return data;
  },
  stringify(input) {
    return _papaparse.default.unparse(input);
  }
};
exports.CSV = CSV;
}),
/* --- src/api/yaml.ts --- */
"src/api/yaml.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.YAML = void 0;
var _yaml = _kame_require_("node_modules/yaml/dist/index.js");
const YAML = {
  parse(input, reviver) {
    return (0, _yaml.parse)(input, reviver);
  },
  stringify(input, replacer, indent) {
    return (0, _yaml.stringify)(input, replacer, indent);
  }
};
exports.YAML = YAML;
}),
/* --- src/api/traceAll.ts --- */
"src/api/traceAll.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
let defaultTrace = undefined;
var _default = Object.assign(function traceAll(trace) {
  if (typeof trace === "boolean") {
    if (trace) {
      defaultTrace = console.error;
    } else {
      defaultTrace = undefined;
    }
  } else {
    defaultTrace = trace;
  }
}, {
  getDefaultTrace() {
    return defaultTrace;
  }
});
exports.default = _default;
}),
/* --- src/api/__filename-and-__dirname.ts --- */
"src/api/__filename-and-__dirname.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get__dirname = get__dirname;
exports.get__filename = get__filename;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var os = _interopRequireWildcard(_kame_require_("external:os"));
var _dirname = _kame_require_("src/api/commands/dirname.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
// Not public API; exported for __filename, which *is* a public API
function get__filename(depth) {
  return os.realpath(std.getFileNameFromStack(depth));
}

// Not public API; exported for __dirname, which *is* a public API
function get__dirname(depth) {
  const filename = os.realpath(std.getFileNameFromStack(depth));
  return (0, _dirname.dirname)(filename);
}
}),
/* --- src/api/parse-script-args.ts --- */
"src/api/parse-script-args.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var clefParse = _interopRequireWildcard(_kame_require_("node_modules/clef-parse/dist/index.js"));
var _paths = _kame_require_("src/api/paths.ts");
var _pwd = _kame_require_("src/api/commands/pwd.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function parseScriptArgs(hints = {}, args = scriptArgs.slice(2)) {
  // clef-parse calls `shift` on this
  const argsClone = args.slice();
  const {
    options,
    positionalArgs
  } = clefParse.parseArgv(argsClone, hints, {
    isAbsolute: _paths.paths.isAbsolute,
    resolvePath: _paths.paths.resolve,
    getCwd: _pwd.pwd
  });
  return {
    flags: options,
    args: positionalArgs
  };
}
var _default = Object.assign(parseScriptArgs, {
  Path: clefParse.Path
});
exports.default = _default;
}),
/* --- src/api/start-repl.ts --- */
"src/api/start-repl.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startRepl = startRepl;
var _repl = _interopRequireDefault(_kame_require_("src/targets/repl/index.ts"));
var _langs = _kame_require_("src/langs.ts");
const validLangs = Array.from(_langs.LANGS);
function startRepl(context = {}, lang = "javascript") {
  if (!_langs.LANGS.has(lang)) {
    throw new Error(`Invalid lang: '${lang}'. Valid langs are: ${validLangs.slice(0, -1).join(", ")} or ${validLangs[validLangs.length - 1]}`);
  }
  Object.assign(globalThis, context);
  (0, _repl.default)(lang);
}
}),
/* --- src/extension-handlers/coffee.ts --- */
"src/extension-handlers/coffee.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _compilers = _interopRequireDefault(_kame_require_("src/compilers.ts"));
Module.compilers[".coffee"] = (filename, content) => {
  const compiled = _compilers.default.coffee(content, {
    filename
  });
  return compiled;
};
}),
/* --- src/extension-handlers/empty.ts --- */
"src/extension-handlers/empty.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _compilers = _interopRequireDefault(_kame_require_("src/compilers.ts"));
Module.compilers[""] = (filename, content) => {
  try {
    return _compilers.default.jsx(content, {
      filename
    });
  } catch (err) {
    try {
      return _compilers.default.tsx(content, {
        filename
      });
    } catch (err2) {
      try {
        return _compilers.default.coffee(content, {
          filename
        });
      } catch (err3) {
        return content;
      }
    }
  }
};
}),
/* --- src/extension-handlers/json.ts --- */
"src/extension-handlers/json.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Module.compilers[".json"] = (filename, content) => {
  return "export default " + content;
};
}),
/* --- src/extension-handlers/jsx.ts --- */
"src/extension-handlers/jsx.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _compilers = _interopRequireDefault(_kame_require_("src/compilers.ts"));
Module.compilers[".jsx"] = (filename, content) => {
  const compiled = _compilers.default.jsx(content, {
    filename
  });
  return compiled;
};
}),
/* --- src/extension-handlers/ts.ts --- */
"src/extension-handlers/ts.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _compilers = _interopRequireDefault(_kame_require_("src/compilers.ts"));
Module.compilers[".ts"] = (filename, content) => {
  const compiled = _compilers.default.ts(content, {
    filename
  });
  return compiled;
};
}),
/* --- src/extension-handlers/tsx.ts --- */
"src/extension-handlers/tsx.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _compilers = _interopRequireDefault(_kame_require_("src/compilers.ts"));
Module.compilers[".tsx"] = (filename, content) => {
  const compiled = _compilers.default.tsx(content, {
    filename
  });
  return compiled;
};
}),
/* --- src/compilers.ts --- */
"src/compilers.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var Sucrase = _interopRequireWildcard(_kame_require_("node_modules/sucrase/dist/index.js"));
var CoffeeScript = _interopRequireWildcard(_kame_require_("node_modules/coffeescript/lib/coffeescript/index.js"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function stripShebangs(input) {
  let shebangs = 0;
  const lines = input.split(/\r\n|\r|\n/g);
  while (lines[0] != null && lines[0].startsWith("#!")) {
    shebangs += 1;
    lines.shift();
  }
  const newBlankLines = Array(shebangs).fill("");
  return newBlankLines.concat(lines).join("\n");
}
function compileUsingSucrase(code, options, sucraseOptions) {
  if (options !== null && options !== void 0 && options.filename) {
    sucraseOptions.filePath = options.filename;
  }

  // All this does is make jsx elements not have __self and __fileName,
  // which imho is better for yavascript itself since __self will often
  // be the global, which makes logging JSX elements really obnoxious
  sucraseOptions.production = true;
  if (options !== null && options !== void 0 && options.expression) {
    // TODO: sucrase doesn't have transform expression; would need to
    // do parseExpression + transformAst + generate + get node from body's
    // first expression statement.
    const result = Sucrase.transform("(" + code + ")", sucraseOptions);
    const withoutTrailingSemi = result.code.replace(/;$/, "");
    if (withoutTrailingSemi[0] === "(" && withoutTrailingSemi[withoutTrailingSemi.length - 1] === ")") {
      // unwrap parens we added
      return withoutTrailingSemi.slice(1, -1);
    } else {
      return withoutTrailingSemi;
    }
  } else {
    const result = Sucrase.transform(code, sucraseOptions);
    return result.code;
  }
}
const compilers = {
  js(code, options) {
    return code;
  },
  tsx(code, options) {
    return compileUsingSucrase(stripShebangs(code), options, {
      transforms: ["typescript", "jsx"],
      // We read this from the global because the user is allowed to
      // change JSX.pragma to change this.
      jsxPragma: globalThis.JSX.pragma,
      // We read this from the global because the user is allowed to
      // change JSX.pragmaFrag to change this.
      jsxFragmentPragma: globalThis.JSX.pragmaFrag
    });
  },
  ts(code, options) {
    return compileUsingSucrase(stripShebangs(code), options, {
      transforms: ["typescript"]
    });
  },
  jsx(code, options) {
    return compileUsingSucrase(stripShebangs(code), options, {
      transforms: ["jsx"],
      // We read this from the global because the user is allowed to
      // change JSX.pragma to change this.
      jsxPragma: globalThis.JSX.pragma,
      // We read this from the global because the user is allowed to
      // change JSX.pragmaFrag to change this.
      jsxFragmentPragma: globalThis.JSX.pragmaFrag
    });
  },
  coffee(code, options) {
    const compiled = CoffeeScript.compile(stripShebangs(code), {
      bare: true,
      filename: options === null || options === void 0 ? void 0 : options.filename
    });
    return compiled;
  }
};
var _default = compilers;
exports.default = _default;
}),
/* --- src/api/commands/basename.ts --- */
"src/api/commands/basename.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basename = basename;
var _paths = _kame_require_("src/api/paths.ts");
function basename(path) {
  const parts = _paths.paths.split(path);
  return parts[parts.length - 1];
}
}),
/* --- node_modules/ansi-regex/index.js --- */
"node_modules/ansi-regex/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

module.exports = ({
  onlyFirst = false
} = {}) => {
  const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
  return new RegExp(pattern, onlyFirst ? undefined : 'g');
};
}),
/* --- src/api/commands/cat.ts --- */
"src/api/commands/cat.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cat = cat;
var std = _interopRequireWildcard(_kame_require_("external:std"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function cat(...paths) {
  let content = "";
  for (const path of paths) {
    const newContent = std.loadFile(path);
    content += newContent;
    std.out.puts(newContent);
  }
  return content;
}
}),
/* --- src/api/commands/cd.ts --- */
"src/api/commands/cd.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cd = cd;
var os = _interopRequireWildcard(_kame_require_("external:os"));
var _env = _kame_require_("src/api/env.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function cd(path) {
  if (path == null) {
    path = _env.env.HOME;
  }
  if (path == null) {
    throw new Error("Please either specify a path or set the HOME environment variable");
  }
  os.chdir(path);
}
}),
/* --- src/api/commands/dirname.ts --- */
"src/api/commands/dirname.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirname = dirname;
var _paths = _kame_require_("src/api/paths.ts");
function dirname(path) {
  const separator = _paths.paths.detectSeparator(path);
  return _paths.paths.split(path).slice(0, -1).join(separator);
}
}),
/* --- src/api/commands/echo.ts --- */
"src/api/commands/echo.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.echo = void 0;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var _makeInspectLog = _kame_require_("src/api/shared/make-inspect-log.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const echo = (0, _makeInspectLog.makeInspectLog)(std.out);
exports.echo = echo;
}),
/* --- src/api/commands/ls.ts --- */
"src/api/commands/ls.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ls = ls;
var os = _interopRequireWildcard(_kame_require_("external:os"));
var _pwd = _kame_require_("src/api/commands/pwd.ts");
var _paths = _kame_require_("src/api/paths.ts");
var _filesystem = _kame_require_("src/api/filesystem.ts");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function ls(dir = (0, _pwd.pwd)(), options = {
  relativePaths: false
}) {
  if (!(0, _filesystem.isDir)(dir)) {
    throw new Error(`Not a directory: ${dir}`);
  }
  let children = os.readdir(dir).filter(child => child !== "." && child !== "..");
  if (!options.relativePaths) {
    const parent = os.realpath(dir);
    children = children.map(child => _paths.paths.join(parent, child));
  }
  return children;
}
}),
/* --- src/api/commands/printf.ts --- */
"src/api/commands/printf.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printf = printf;
var std = _interopRequireWildcard(_kame_require_("external:std"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function printf(format, ...args) {
  std.out.printf(format, ...args);
}
}),
/* --- src/api/commands/pwd.ts --- */
"src/api/commands/pwd.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pwd = pwd;
var os = _interopRequireWildcard(_kame_require_("external:os"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function pwd() {
  return os.getcwd();
}
}),
/* --- src/api/commands/readlink.ts --- */
"src/api/commands/readlink.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readlink = readlink;
var os = _interopRequireWildcard(_kame_require_("external:os"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function readlink(path) {
  if (os.readlink == null) {
    throw new Error(`readlink is not yet supported in ${os.platform}`);
  } else {
    return os.readlink(path);
  }
}
}),
/* --- src/api/commands/realpath.ts --- */
"src/api/commands/realpath.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.realpath = realpath;
var os = _interopRequireWildcard(_kame_require_("external:os"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function realpath(path) {
  return os.realpath(path);
}
}),
/* --- src/api/exec/exec.ts --- */
"src/api/exec/exec.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var _interopRequireDefault = _kame_require_("node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.$ = $;
exports.exec = exports.ChildProcess = void 0;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var os = _interopRequireWildcard(_kame_require_("external:os"));
var _parseArgString = _kame_require_("src/api/exec/parse-arg-string.ts");
var _pwd = _kame_require_("src/api/commands/pwd.ts");
var _env = _kame_require_("src/api/env.ts");
var _errorWithProperties = _kame_require_("src/error-with-properties.ts");
var _traceAll = _interopRequireDefault(_kame_require_("src/api/traceAll.ts"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
class ChildProcess {
  pid = null;
  constructor(args, options = {}) {
    var _options$stdio, _options$stdio2, _options$stdio3;
    this.args = typeof args === "string" ? (0, _parseArgString.parseArgString)(args) : args;
    this.cwd = options.cwd || (0, _pwd.pwd)();
    const baseEnv = options.env || _env.env;
    this.env = {};
    for (const [key, value] of Object.entries(baseEnv)) {
      if (value != null) {
        this.env[String(key)] = String(value);
      }
    }
    this.stdio = {
      in: (options === null || options === void 0 ? void 0 : (_options$stdio = options.stdio) === null || _options$stdio === void 0 ? void 0 : _options$stdio.in) ?? std.in,
      out: (options === null || options === void 0 ? void 0 : (_options$stdio2 = options.stdio) === null || _options$stdio2 === void 0 ? void 0 : _options$stdio2.out) ?? std.out,
      err: (options === null || options === void 0 ? void 0 : (_options$stdio3 = options.stdio) === null || _options$stdio3 === void 0 ? void 0 : _options$stdio3.err) ?? std.err
    };
    this.trace = options.trace ?? _traceAll.default.getDefaultTrace();
  }

  /** returns pid */
  start() {
    if (this.trace) {
      this.trace.call(null, "ChildProcess.start:", this.args);
    }
    this.pid = os.exec(this.args, {
      block: false,
      cwd: this.cwd,
      env: this.env,
      stdin: this.stdio.in.fileno(),
      stdout: this.stdio.out.fileno(),
      stderr: this.stdio.err.fileno()
    });
    return this.pid;
  }
  waitUntilComplete() {
    const pid = this.pid;
    if (pid == null) {
      throw new Error("Cannot wait for a child process that hasn't yet been started");
    }
    while (true) {
      const [ret, status] = os.waitpid(pid);
      if (ret == pid) {
        if (os.WIFEXITED(status)) {
          const ret = {
            status: os.WEXITSTATUS(status),
            signal: undefined
          };
          if (this.trace) {
            this.trace.call(null, "ChildProcess result:", this.args, "->", ret);
          }
          return ret;
        } else if (os.WIFSIGNALED(status)) {
          const ret = {
            status: undefined,
            signal: os.WTERMSIG(status)
          };
          if (this.trace) {
            this.trace.call(null, "ChildProcess result:", this.args, "->");
          }
          return ret;
        }
      }
    }
  }
}
exports.ChildProcess = ChildProcess;
const exec = (args, options = {}) => {
  const {
    failOnNonZeroStatus = true,
    captureOutput = false,
    cwd,
    env,
    trace = _traceAll.default.getDefaultTrace()
  } = options;
  if (typeof args === "string") {
    args = (0, _parseArgString.parseArgString)(args);
  }
  const child = new ChildProcess(args, {
    cwd,
    env,
    trace
  });
  let tmpOut = null;
  let tmpErr = null;
  if (captureOutput) {
    tmpOut = std.tmpfile();
    child.stdio.out = tmpOut;
    tmpErr = std.tmpfile();
    child.stdio.err = tmpErr;
  }
  let result = null;
  try {
    child.start();
    result = child.waitUntilComplete();
    if (failOnNonZeroStatus && result.status !== 0) {
      throw (0, _errorWithProperties.makeErrorWithProperties)(`Command failed: ${JSON.stringify(args)}`, result);
    }
    if (!captureOutput) {
      if (failOnNonZeroStatus) {
        return undefined;
      } else {
        return result;
      }
    }
    if (tmpOut != null && tmpErr != null) {
      // need to seek to beginning to read the data that was written
      tmpOut.seek(0, std.SEEK_SET);
      tmpErr.seek(0, std.SEEK_SET);
      const stdout = tmpOut.readAsString();
      const stderr = tmpErr.readAsString();
      return {
        stdout,
        stderr,
        ...result
      };
    } else {
      throw new Error("Internal error: tmpOut and tmpErr weren't set, but attempted to return stdout and stderr. This indicates a bug in the exec function");
    }
  } catch (err) {
    if (trace) {
      trace("exec error:", err);
    }
    throw err;
  } finally {
    if (tmpOut != null) tmpOut.close();
    if (tmpErr != null) tmpErr.close();
  }
};
exports.exec = exec;
function $(args) {
  return exec(args, {
    captureOutput: true
  });
}
}),
/* --- src/error-with-properties.ts --- */
"src/error-with-properties.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeErrorWithProperties = makeErrorWithProperties;
var inspectOptions = _interopRequireWildcard(_kame_require_("src/inspect-options.ts"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const MAX_ERROR_MESSAGE_LENGTH = 1000 - 3; // minus 3 for ellipsis

function makeErrorWithProperties(message, properties) {
  let errorMessage = message;
  const entries = Object.entries(properties);
  if (entries.length > 0) {
    errorMessage += " (";
    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i];
      errorMessage += key;
      errorMessage += " = ";
      errorMessage += inspect(value, inspectOptions.forError).replace(/\n+/g, " ");
      if (i !== entries.length - 1) {
        errorMessage += ", ";
      }
    }
    errorMessage += ")";
  }
  if (errorMessage.length > MAX_ERROR_MESSAGE_LENGTH) {
    errorMessage = errorMessage.slice(0, MAX_ERROR_MESSAGE_LENGTH) + "...";
  }
  const err = new Error(errorMessage);
  return Object.assign(err, properties);
}
}),
/* --- node_modules/minimatch/minimatch.js --- */
"node_modules/minimatch/minimatch.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

const minimatch = module.exports = (p, pattern, options = {}) => {
  assertValidPattern(pattern);

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
module.exports = minimatch;
const path = _kame_require_("node_modules/minimatch/lib/path.js");
minimatch.sep = path.sep;
const GLOBSTAR = Symbol('globstar **');
minimatch.GLOBSTAR = GLOBSTAR;
const expand = _kame_require_("node_modules/brace-expansion/index.js");
const plTypes = {
  '!': {
    open: '(?:(?!(?:',
    close: '))[^/]*?)'
  },
  '?': {
    open: '(?:',
    close: ')?'
  },
  '+': {
    open: '(?:',
    close: ')+'
  },
  '*': {
    open: '(?:',
    close: ')*'
  },
  '@': {
    open: '(?:',
    close: ')'
  }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';

// * => any number of characters
const star = qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// "abc" -> { a:true, b:true, c:true }
const charSet = s => s.split('').reduce((set, c) => {
  set[c] = true;
  return set;
}, {});

// characters that need to be escaped in RegExp.
const reSpecials = charSet('().*{}+?[]^$\\!');

// characters that indicate we have to add the pattern start
const addPatternStartSet = charSet('[.(');

// normalizes slashes.
const slashSplit = /\/+/;
minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
const ext = (a, b = {}) => {
  const t = {};
  Object.keys(a).forEach(k => t[k] = a[k]);
  Object.keys(b).forEach(k => t[k] = b[k]);
  return t;
};
minimatch.defaults = def => {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
  m.Minimatch = class Minimatch extends orig.Minimatch {
    constructor(pattern, options) {
      super(pattern, ext(def, options));
    }
  };
  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch;
  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
  m.defaults = options => orig.defaults(ext(def, options));
  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
  return m;
};

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
const braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern];
  }
  return expand(pattern);
};
const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = pattern => {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern');
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long');
  }
};

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const SUBPARSE = Symbol('subparse');
minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
minimatch.match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter(f => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};

// replace stuff like \* with *
const globUnescape = s => s.replace(/\\(.)/g, '$1');
const regExpEscape = s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
  constructor(pattern, options) {
    assertValidPattern(pattern);
    if (!options) options = {};
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, '/');
    }
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;

    // make the set of regexps etc.
    this.make();
  }
  debug() {}
  make() {
    const pattern = this.pattern;
    const options = this.options;

    // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }

    // step 1: figure out negation, etc.
    this.parseNegate();

    // step 2: expand braces
    let set = this.globSet = this.braceExpand();
    if (options.debug) this.debug = (...args) => console.error(...args);
    this.debug(this.pattern, set);

    // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of "**", which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters
    set = this.globParts = set.map(s => s.split(slashSplit));
    this.debug(this.pattern, set);

    // glob --> regexps
    set = set.map((s, si, set) => s.map(this.parse, this));
    this.debug(this.pattern, set);

    // filter out everything that didn't compile properly.
    set = set.filter(s => s.indexOf(false) === -1);
    this.debug(this.pattern, set);
    this.set = set;
  }
  parseNegate() {
    if (this.options.nonegate) return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset) this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }

  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial) {
    var options = this.options;
    this.debug('matchOne', {
      'this': this,
      file: file,
      pattern: pattern
    });
    this.debug('matchOne', file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug('matchOne loop');
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);

      // should be impossible.
      // some invalid regexp stuff in the set.
      /* istanbul ignore if */
      if (p === false) return false;
      if (p === GLOBSTAR) {
        this.debug('GLOBSTAR', [pattern, p, f]);

        // "**"
        // a/**/b/**/c would match the following:
        // a/b/x/y/z/c
        // a/x/y/z/b/c
        // a/b/x/b/x/c
        // a/b/c
        // To do this, take the rest of the pattern after
        // the **, and see if it would match the file remainder.
        // If so, return success.
        // If not, the ** "swallows" a segment, and try again.
        // This is recursively awful.
        //
        // a/**/b/**/c matching a/b/x/y/z/c
        // - a matches a
        // - doublestar
        //   - matchOne(b/x/y/z/c, b/**/c)
        //     - b matches b
        //     - doublestar
        //       - matchOne(x/y/z/c, c) -> no
        //       - matchOne(y/z/c, c) -> no
        //       - matchOne(z/c, c) -> no
        //       - matchOne(c, c) yes, hit
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug('** at the end');
          // a ** at the end will just swallow the rest.
          // We have found a match.
          // however, it will not swallow /.x, unless
          // options.dot is set.
          // . and .. are *never* matched by **, for explosively
          // exponential reasons.
          for (; fi < fl; fi++) {
            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
          }
          return true;
        }

        // ok, let's see if we can swallow whatever we can.
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

          // XXX remove this slice.  Just pass the start index.
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug('globstar found match!', fr, fl, swallowee);
            // found a match.
            return true;
          } else {
            // can't swallow "." or ".." ever.
            // can only swallow ".foo" when explicitly asked.
            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
              this.debug('dot detected!', file, fr, pattern, pr);
              break;
            }

            // ** swallows a segment, and continue.
            this.debug('globstar swallow a segment, and continue');
            fr++;
          }
        }

        // no match was found.
        // However, in partial mode, we can't say this is necessarily over.
        // If there's more *pattern* left, then
        /* istanbul ignore if */
        if (partial) {
          // ran out of file
          this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
          if (fr === fl) return true;
        }
        return false;
      }

      // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.
      var hit;
      if (typeof p === 'string') {
        hit = f === p;
        this.debug('string match', p, f, hit);
      } else {
        hit = f.match(p);
        this.debug('pattern match', p, f, hit);
      }
      if (!hit) return false;
    }

    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*

    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true;
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we're doing the match as part of
      // a glob fs traversal.
      return partial;
    } else /* istanbul ignore else */if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        return fi === fl - 1 && file[fi] === '';
      }

    // should be unreachable.
    /* istanbul ignore next */
    throw new Error('wtf?');
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern, isSub) {
    assertValidPattern(pattern);
    const options = this.options;

    // shortcuts
    if (pattern === '**') {
      if (!options.noglobstar) return GLOBSTAR;else pattern = '*';
    }
    if (pattern === '') return '';
    let re = '';
    let hasMagic = !!options.nocase;
    let escaping = false;
    // ? => one single character
    const patternListStack = [];
    const negativeLists = [];
    let stateChar;
    let inClass = false;
    let reClassStart = -1;
    let classStart = -1;
    let cs;
    let pl;
    let sp;
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.
    const patternStart = pattern.charAt(0) === '.' ? '' // anything
    // not (start or / followed by . or .. followed by / or end)
    : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
    const clearStateChar = () => {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn't consumed by this pass.
        switch (stateChar) {
          case '*':
            re += star;
            hasMagic = true;
            break;
          case '?':
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += '\\' + stateChar;
            break;
        }
        this.debug('clearStateChar %j %j', stateChar, re);
        stateChar = false;
      }
    };
    for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
      this.debug('%s\t%s %s %j', pattern, i, re, c);

      // skip over any that are escaped.
      if (escaping) {
        /* istanbul ignore next - completely not allowed, even escaped. */
        if (c === '/') {
          return false;
        }
        if (reSpecials[c]) {
          re += '\\';
        }
        re += c;
        escaping = false;
        continue;
      }
      switch (c) {
        /* istanbul ignore next */
        case '/':
          {
            // Should already be path-split by now.
            return false;
          }
        case '\\':
          clearStateChar();
          escaping = true;
          continue;

        // the various stateChar values
        // for the "extglob" stuff.
        case '?':
        case '*':
        case '+':
        case '@':
        case '!':
          this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

          // all of those are literals inside a class, except that
          // the glob [!a] means [^a] in regexp
          if (inClass) {
            this.debug('  in class');
            if (c === '!' && i === classStart + 1) c = '^';
            re += c;
            continue;
          }

          // if we already have a stateChar, then it means
          // that there was something like ** or +? in there.
          // Handle the stateChar, then proceed with this one.
          this.debug('call clearStateChar %j', stateChar);
          clearStateChar();
          stateChar = c;
          // if extglob is disabled, then +(asdf|foo) isn't a thing.
          // just clear the statechar *now*, rather than even diving into
          // the patternList stuff.
          if (options.noext) clearStateChar();
          continue;
        case '(':
          if (inClass) {
            re += '(';
            continue;
          }
          if (!stateChar) {
            re += '\\(';
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          // negation is (?:(?!js)[^/]*)
          re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
          this.debug('plType %j %j', stateChar, re);
          stateChar = false;
          continue;
        case ')':
          if (inClass || !patternListStack.length) {
            re += '\\)';
            continue;
          }
          clearStateChar();
          hasMagic = true;
          pl = patternListStack.pop();
          // negation is (?:(?!js)[^/]*)
          // The others are (?:<pattern>)<type>
          re += pl.close;
          if (pl.type === '!') {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case '|':
          if (inClass || !patternListStack.length) {
            re += '\\|';
            continue;
          }
          clearStateChar();
          re += '|';
          continue;

        // these are mostly the same in regexp and glob
        case '[':
          // swallow any state-tracking char before the [
          clearStateChar();
          if (inClass) {
            re += '\\' + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case ']':
          //  a right bracket shall lose its special
          //  meaning and represent itself in
          //  a bracket expression if it occurs
          //  first in the list.  -- POSIX.2 2.8.3.2
          if (i === classStart + 1 || !inClass) {
            re += '\\' + c;
            continue;
          }

          // handle the case where we left a class open.
          // "[z-a]" is valid, equivalent to "\[z-a\]"
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          cs = pattern.substring(classStart + 1, i);
          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }

          // finish up the class.
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          // swallow any state char that wasn't consumed
          clearStateChar();
          if (reSpecials[c] && !(c === '^' && inClass)) {
            re += '\\';
          }
          re += c;
          break;
      } // switch
    } // for

    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + '\\[' + sp[0];
      hasMagic = hasMagic || sp[1];
    }

    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail;
      tail = re.slice(pl.reStart + pl.open.length);
      this.debug('setting tail', re, pl);
      // maybe some even number of \, then maybe 1 \, followed by a |
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
        /* istanbul ignore else - should already be done */
        if (!$2) {
          // the | isn't already escaped, so escape it.
          $2 = '\\';
        }

        // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That's why this trick works.
        //
        // I am sorry that you have to see this.
        return $1 + $1 + $2 + '|';
      });
      this.debug('tail=%j\n   %s', tail, tail, pl, re);
      const t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + '\\(' + tail;
    }

    // handle trailing things that only matter at the very end.
    clearStateChar();
    if (escaping) {
      // trailing \\
      re += '\\\\';
    }

    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    const addPatternStart = addPatternStartSet[re.charAt(0)];

    // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like 'a.xyz.yz' doesn't match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.
    for (let n = negativeLists.length - 1; n > -1; n--) {
      const nl = negativeLists[n];
      const nlBefore = re.slice(0, nl.reStart);
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      let nlAfter = re.slice(nl.reEnd);
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;

      // Handle nested stuff like *(*.js|!(*.json)), where open parens
      // mean that we should *not* include the ) in the bit that is considered
      // "after" the negated section.
      const openParensBefore = nlBefore.split('(').length - 1;
      let cleanAfter = nlAfter;
      for (let i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
      }
      nlAfter = cleanAfter;
      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '$' : '';
      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    }

    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== '' && hasMagic) {
      re = '(?=.)' + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }

    // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }

    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    const flags = options.nocase ? 'i' : '';
    try {
      return Object.assign(new RegExp('^' + re + '$', flags), {
        _glob: pattern,
        _src: re
      });
    } catch (er) /* istanbul ignore next - should be impossible */{
      // If it was an invalid regular expression, then it can't match
      // anything.  This trick looks for a character after the end of
      // the string, which is of course impossible, except in multi-line
      // mode, but it's not a /m regex.
      return new RegExp('$.');
    }
  }
  makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;

    // at this point, this.set is a 2d array of partial
    // pattern strings, or "**".
    //
    // It's better to use .match().  This function shouldn't
    // be used, really, but it's pretty convenient sometimes,
    // when you just want to work with a regex.
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    const flags = options.nocase ? 'i' : '';

    // coalesce globstars and regexpify non-globstar patterns
    // if it's the only item, then we just do one twoStar
    // if it's the first, and there are more, prepend (\/|twoStar\/)? to next
    // if it's the last, append (\/twoStar|) to previous
    // if it's in the middle, append (\/|\/twoStar\/) to previous
    // then filter out GLOBSTAR symbols
    let re = set.map(pattern => {
      pattern = pattern.map(p => typeof p === 'string' ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set, p) => {
        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
          set.push(p);
        }
        return set;
      }, []);
      pattern.forEach((p, i) => {
        if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
          return;
        }
        if (i === 0) {
          if (pattern.length > 1) {
            pattern[i + 1] = '(?:\\\/|' + twoStar + '\\\/)?' + pattern[i + 1];
          } else {
            pattern[i] = twoStar;
          }
        } else if (i === pattern.length - 1) {
          pattern[i - 1] += '(?:\\\/|' + twoStar + ')?';
        } else {
          pattern[i - 1] += '(?:\\\/|\\\/' + twoStar + '\\\/)' + pattern[i + 1];
          pattern[i + 1] = GLOBSTAR;
        }
      });
      return pattern.filter(p => p !== GLOBSTAR).join('/');
    }).join('|');

    // must match entire pattern
    // ending in a * or ** will make it less strict.
    re = '^(?:' + re + ')$';

    // can match anything, as long as it's not this.
    if (this.negate) re = '^(?!' + re + ').*$';
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) /* istanbul ignore next - should be impossible */{
      this.regexp = false;
    }
    return this.regexp;
  }
  match(f, partial = this.partial) {
    this.debug('match', f, this.pattern);
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false;
    if (this.empty) return f === '';
    if (f === '/' && partial) return true;
    const options = this.options;

    // windows: need to use /, not \
    if (path.sep !== '/') {
      f = f.split(path.sep).join('/');
    }

    // treat the test path as a set of pathparts.
    f = f.split(slashSplit);
    this.debug(this.pattern, 'split', f);

    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    const set = this.set;
    this.debug(this.pattern, 'set', set);

    // Find the basename of the path by looking for the last non-empty segment
    let filename;
    for (let i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename) break;
    }
    for (let i = 0; i < set.length; i++) {
      const pattern = set[i];
      let file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) return true;
        return !this.negate;
      }
    }

    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false;
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
}
minimatch.Minimatch = Minimatch;
}),
/* --- node_modules/@suchipi/is/dist/index.js --- */
"node_modules/@suchipi/is/dist/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.is = void 0;
const ObjectPrototypeToString = Object.prototype.toString;
function getTag(value) {
  return value[Symbol.toStringTag] || ObjectPrototypeToString.call(value).slice(8, -1);
}
const gen = function* () {};
const Generator = gen().constructor;
const GeneratorFunction = gen.constructor;
const AsyncFunction = async function () {}.constructor;
const asgen = async function* () {};
const AsyncGenerator = asgen().constructor;
const AsyncGeneratorFunction = asgen.constructor;
exports.is = {
  ["string"](value) {
    return typeof value === "string";
  },
  ["String"](value) {
    return typeof value === "string";
  },
  ["number"](value) {
    return typeof value === "number" && !exports.is.NaN(value);
  },
  ["Number"](value) {
    return typeof value === "number" && !exports.is.NaN(value);
  },
  ["boolean"](value) {
    return typeof value === "boolean";
  },
  ["Boolean"](value) {
    return typeof value === "boolean";
  },
  ["bigint"](value) {
    return typeof value === "bigint";
  },
  ["BigInt"](value) {
    return typeof value === "bigint";
  },
  ["symbol"](value) {
    return typeof value === "symbol";
  },
  ["Symbol"](value) {
    return typeof value === "symbol";
  },
  ["null"](value) {
    return value === null;
  },
  ["undefined"](value) {
    return typeof value === "undefined";
  },
  ["void"](value) {
    return value == null;
  },
  ["object"](value) {
    return typeof value === "object" && value != null;
  },
  ["Object"](value) {
    return typeof value === "object" && value != null;
  },
  ["Array"](value) {
    return Array.isArray(value);
  },
  ["function"](value) {
    return typeof value === "function";
  },
  ["Function"](value) {
    return typeof value === "function";
  },
  ["tagged"](value, tag) {
    const valueTag = getTag(value);
    return tag === valueTag;
  },
  ["instanceOf"](value, klass) {
    return value instanceof klass;
  },
  ["Error"](value) {
    return value instanceof Error || exports.is.object(value) && exports.is.string(value.message) && exports.is.string(value.name) && value.name.endsWith("Error") && getTag(value) === value.name;
  },
  ["Infinity"](value) {
    return value === Infinity;
  },
  ["NegativeInfinity"](value) {
    return value === -Infinity;
  },
  ["NaN"](value) {
    return Number.isNaN(value);
  },
  ["Date"](value) {
    return value instanceof Date || exports.is.tagged(value, "Date");
  },
  ["RegExp"](value) {
    return value instanceof RegExp || exports.is.tagged(value, "RegExp");
  },
  ["Map"](value) {
    return value instanceof Map || exports.is.tagged(value, "Map");
  },
  ["Set"](value) {
    return value instanceof Set || exports.is.tagged(value, "Set");
  },
  ["WeakMap"](value) {
    return value instanceof Map || exports.is.tagged(value, "Map");
  },
  ["WeakSet"](value) {
    return value instanceof Set || exports.is.tagged(value, "Set");
  },
  ["ArrayBuffer"](value) {
    return value instanceof ArrayBuffer || exports.is.tagged(value, "ArrayBuffer");
  },
  ["SharedArrayBuffer"](value) {
    return value instanceof SharedArrayBuffer || exports.is.tagged(value, "SharedArrayBuffer");
  },
  ["DataView"](value) {
    return value instanceof DataView || exports.is.tagged(value, "DataView");
  },
  ["TypedArray"](value) {
    return ArrayBuffer.isView(value) && !exports.is.DataView(value);
  },
  ["Int8Array"](value) {
    return value instanceof Int8Array || exports.is.tagged(value, "Int8Array");
  },
  ["Uint8Array"](value) {
    return value instanceof Uint8Array || exports.is.tagged(value, "Uint8Array");
  },
  ["Uint8ClampedArray"](value) {
    return value instanceof Uint8ClampedArray || exports.is.tagged(value, "Uint8ClampedArray");
  },
  ["Int16Array"](value) {
    return value instanceof Int16Array || exports.is.tagged(value, "Int16Array");
  },
  ["Uint16Array"](value) {
    return value instanceof Uint16Array || exports.is.tagged(value, "Uint16Array");
  },
  ["Int32Array"](value) {
    return value instanceof Int32Array || exports.is.tagged(value, "Int32Array");
  },
  ["Uint32Array"](value) {
    return value instanceof Uint32Array || exports.is.tagged(value, "Uint32Array");
  },
  ["Float32Array"](value) {
    return value instanceof Float32Array || exports.is.tagged(value, "Float32Array");
  },
  ["Float64Array"](value) {
    return value instanceof Float64Array || exports.is.tagged(value, "Float64Array");
  },
  ["Promise"](value) {
    return exports.is.object(value) && exports.is.function(value.then);
  },
  ["Generator"](value) {
    return value instanceof Generator || exports.is.tagged(value, "Generator");
  },
  ["GeneratorFunction"](value) {
    return value instanceof GeneratorFunction || exports.is.tagged(value, "GeneratorFunction");
  },
  ["AsyncFunction"](value) {
    return value instanceof AsyncFunction || exports.is.tagged(value, "AsyncFunction");
  },
  ["AsyncGenerator"](value) {
    return value instanceof AsyncGenerator || exports.is.tagged(value, "AsyncGenerator");
  },
  ["AsyncGeneratorFunction"](value) {
    return value instanceof AsyncGeneratorFunction || exports.is.tagged(value, "AsyncGeneratorFunction");
  }
};
}),
/* --- src/api/shared/make-inspect-log.ts --- */
"src/api/shared/make-inspect-log.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeInspectLog = void 0;
var std = _interopRequireWildcard(_kame_require_("external:std"));
var inspectOptions = _interopRequireWildcard(_kame_require_("src/inspect-options.ts"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const makeInspectLog = file => (...args) => {
  for (let i = 0; i < args.length; i++) {
    if (i !== 0) {
      file.puts(" ");
    }
    const arg = args[i];
    let str;
    if (typeof arg === "string") {
      str = arg;
    } else {
      try {
        str = inspect(arg, inspectOptions.forPrint);
      } catch (err) {
        try {
          std.err.puts(err.message + "\n");
        } catch (err) {
          // I give up
        }
        str = String(arg);
      }
    }
    file.puts(str);
  }
  file.puts("\n");
};
exports.makeInspectLog = makeInspectLog;
}),
/* --- src/api/byte.ts --- */
"src/api/byte.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";
}),
/* --- node_modules/papaparse/papaparse.js --- */
"node_modules/papaparse/papaparse.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

/* @license
Papa Parse
v5.3.2
https://github.com/mholt/PapaParse
License: MIT
*/
(function (root, factory) {
  /* globals define */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof module === 'object' && typeof exports !== 'undefined') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.Papa = factory();
  }
  // in strict mode we cannot access arguments.callee, so we need a named reference to
  // stringify the factory method for the blob worker
  // eslint-disable-next-line func-name
})(void 0, function moduleFactory() {
  'use strict';

  var global = function () {
    // alternative method, similar to `Function('return this')()`
    // but without using `eval` (which is disabled when
    // using Content Security Policy).

    if (typeof self !== 'undefined') {
      return self;
    }
    if (typeof window !== 'undefined') {
      return window;
    }
    if (typeof global !== 'undefined') {
      return global;
    }

    // When running tests none of the above have been defined
    return {};
  }();
  function getWorkerBlob() {
    var URL = global.URL || global.webkitURL || null;
    var code = moduleFactory.toString();
    return Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {
      type: 'text/javascript'
    })));
  }
  var IS_WORKER = !global.document && !!global.postMessage,
    IS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);
  var workers = {},
    workerIdCounter = 0;
  var Papa = {};
  Papa.parse = CsvToJson;
  Papa.unparse = JsonToCsv;
  Papa.RECORD_SEP = String.fromCharCode(30);
  Papa.UNIT_SEP = String.fromCharCode(31);
  Papa.BYTE_ORDER_MARK = '\ufeff';
  Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
  Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;
  Papa.NODE_STREAM_INPUT = 1;

  // Configurable chunk sizes for local and remote files, respectively
  Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB
  Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB
  Papa.DefaultDelimiter = ','; // Used if not specified and detection fails

  // Exposed for testing and development only
  Papa.Parser = Parser;
  Papa.ParserHandle = ParserHandle;
  Papa.NetworkStreamer = NetworkStreamer;
  Papa.FileStreamer = FileStreamer;
  Papa.StringStreamer = StringStreamer;
  Papa.ReadableStreamStreamer = ReadableStreamStreamer;
  if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
    Papa.DuplexStreamStreamer = DuplexStreamStreamer;
  }
  if (global.jQuery) {
    var $ = global.jQuery;
    $.fn.parse = function (options) {
      var config = options.config || {};
      var queue = [];
      this.each(function (idx) {
        var supported = $(this).prop('tagName').toUpperCase() === 'INPUT' && $(this).attr('type').toLowerCase() === 'file' && global.FileReader;
        if (!supported || !this.files || this.files.length === 0) return true; // continue to next input element

        for (var i = 0; i < this.files.length; i++) {
          queue.push({
            file: this.files[i],
            inputElem: this,
            instanceConfig: $.extend({}, config)
          });
        }
      });
      parseNextFile(); // begin parsing
      return this; // maintains chainability

      function parseNextFile() {
        if (queue.length === 0) {
          if (isFunction(options.complete)) options.complete();
          return;
        }
        var f = queue[0];
        if (isFunction(options.before)) {
          var returned = options.before(f.file, f.inputElem);
          if (typeof returned === 'object') {
            if (returned.action === 'abort') {
              error('AbortError', f.file, f.inputElem, returned.reason);
              return; // Aborts all queued files immediately
            } else if (returned.action === 'skip') {
              fileComplete(); // parse the next file in the queue, if any
              return;
            } else if (typeof returned.config === 'object') f.instanceConfig = $.extend(f.instanceConfig, returned.config);
          } else if (returned === 'skip') {
            fileComplete(); // parse the next file in the queue, if any
            return;
          }
        }

        // Wrap up the user's complete callback, if any, so that ours also gets executed
        var userCompleteFunc = f.instanceConfig.complete;
        f.instanceConfig.complete = function (results) {
          if (isFunction(userCompleteFunc)) userCompleteFunc(results, f.file, f.inputElem);
          fileComplete();
        };
        Papa.parse(f.file, f.instanceConfig);
      }
      function error(name, file, elem, reason) {
        if (isFunction(options.error)) options.error({
          name: name
        }, file, elem, reason);
      }
      function fileComplete() {
        queue.splice(0, 1);
        parseNextFile();
      }
    };
  }
  if (IS_PAPA_WORKER) {
    global.onmessage = workerThreadReceivedMessage;
  }
  function CsvToJson(_input, _config) {
    _config = _config || {};
    var dynamicTyping = _config.dynamicTyping || false;
    if (isFunction(dynamicTyping)) {
      _config.dynamicTypingFunction = dynamicTyping;
      // Will be filled on first row call
      dynamicTyping = {};
    }
    _config.dynamicTyping = dynamicTyping;
    _config.transform = isFunction(_config.transform) ? _config.transform : false;
    if (_config.worker && Papa.WORKERS_SUPPORTED) {
      var w = newWorker();
      w.userStep = _config.step;
      w.userChunk = _config.chunk;
      w.userComplete = _config.complete;
      w.userError = _config.error;
      _config.step = isFunction(_config.step);
      _config.chunk = isFunction(_config.chunk);
      _config.complete = isFunction(_config.complete);
      _config.error = isFunction(_config.error);
      delete _config.worker; // prevent infinite loop

      w.postMessage({
        input: _input,
        config: _config,
        workerId: w.id
      });
      return;
    }
    var streamer = null;
    if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {
      // create a node Duplex stream for use
      // with .pipe
      streamer = new DuplexStreamStreamer(_config);
      return streamer.getStream();
    } else if (typeof _input === 'string') {
      if (_config.download) streamer = new NetworkStreamer(_config);else streamer = new StringStreamer(_config);
    } else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {
      streamer = new ReadableStreamStreamer(_config);
    } else if (global.File && _input instanceof File || _input instanceof Object)
      // ...Safari. (see issue #106)
      streamer = new FileStreamer(_config);
    return streamer.stream(_input);
  }
  function JsonToCsv(_input, _config) {
    // Default configuration

    /** whether to surround every datum with quotes */
    var _quotes = false;

    /** whether to write headers */
    var _writeHeader = true;

    /** delimiting character(s) */
    var _delimiter = ',';

    /** newline character(s) */
    var _newline = '\r\n';

    /** quote character */
    var _quoteChar = '"';

    /** escaped quote character, either "" or <config.escapeChar>" */
    var _escapedQuote = _quoteChar + _quoteChar;

    /** whether to skip empty lines */
    var _skipEmptyLines = false;

    /** the columns (keys) we expect when we unparse objects */
    var _columns = null;

    /** whether to prevent outputting cells that can be parsed as formulae by spreadsheet software (Excel and LibreOffice) */
    var _escapeFormulae = false;
    unpackConfig();
    var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');
    if (typeof _input === 'string') _input = JSON.parse(_input);
    if (Array.isArray(_input)) {
      if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);else if (typeof _input[0] === 'object') return serialize(_columns || Object.keys(_input[0]), _input, _skipEmptyLines);
    } else if (typeof _input === 'object') {
      if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);
      if (Array.isArray(_input.data)) {
        if (!_input.fields) _input.fields = _input.meta && _input.meta.fields || _columns;
        if (!_input.fields) _input.fields = Array.isArray(_input.data[0]) ? _input.fields : typeof _input.data[0] === 'object' ? Object.keys(_input.data[0]) : [];
        if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object') _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']
      }

      return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
    }

    // Default (any valid paths should return before this)
    throw new Error('Unable to serialize unrecognized input');
    function unpackConfig() {
      if (typeof _config !== 'object') return;
      if (typeof _config.delimiter === 'string' && !Papa.BAD_DELIMITERS.filter(function (value) {
        return _config.delimiter.indexOf(value) !== -1;
      }).length) {
        _delimiter = _config.delimiter;
      }
      if (typeof _config.quotes === 'boolean' || typeof _config.quotes === 'function' || Array.isArray(_config.quotes)) _quotes = _config.quotes;
      if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string') _skipEmptyLines = _config.skipEmptyLines;
      if (typeof _config.newline === 'string') _newline = _config.newline;
      if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;
      if (typeof _config.header === 'boolean') _writeHeader = _config.header;
      if (Array.isArray(_config.columns)) {
        if (_config.columns.length === 0) throw new Error('Option columns is empty');
        _columns = _config.columns;
      }
      if (_config.escapeChar !== undefined) {
        _escapedQuote = _config.escapeChar + _quoteChar;
      }
      if (typeof _config.escapeFormulae === 'boolean' || _config.escapeFormulae instanceof RegExp) {
        _escapeFormulae = _config.escapeFormulae instanceof RegExp ? _config.escapeFormulae : /^[=+\-@\t\r].*$/;
      }
    }

    /** The double for loop that iterates the data and writes out a CSV string including header row */
    function serialize(fields, data, skipEmptyLines) {
      var csv = '';
      if (typeof fields === 'string') fields = JSON.parse(fields);
      if (typeof data === 'string') data = JSON.parse(data);
      var hasHeader = Array.isArray(fields) && fields.length > 0;
      var dataKeyedByField = !Array.isArray(data[0]);

      // If there a header row, write it first
      if (hasHeader && _writeHeader) {
        for (var i = 0; i < fields.length; i++) {
          if (i > 0) csv += _delimiter;
          csv += safe(fields[i], i);
        }
        if (data.length > 0) csv += _newline;
      }

      // Then write out the data
      for (var row = 0; row < data.length; row++) {
        var maxCol = hasHeader ? fields.length : data[row].length;
        var emptyLine = false;
        var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
        if (skipEmptyLines && !hasHeader) {
          emptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;
        }
        if (skipEmptyLines === 'greedy' && hasHeader) {
          var line = [];
          for (var c = 0; c < maxCol; c++) {
            var cx = dataKeyedByField ? fields[c] : c;
            line.push(data[row][cx]);
          }
          emptyLine = line.join('').trim() === '';
        }
        if (!emptyLine) {
          for (var col = 0; col < maxCol; col++) {
            if (col > 0 && !nullLine) csv += _delimiter;
            var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
            csv += safe(data[row][colIdx], col);
          }
          if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {
            csv += _newline;
          }
        }
      }
      return csv;
    }

    /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
    function safe(str, col) {
      if (typeof str === 'undefined' || str === null) return '';
      if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);
      var needsQuotes = false;
      if (_escapeFormulae && typeof str === "string" && _escapeFormulae.test(str)) {
        str = "'" + str;
        needsQuotes = true;
      }
      var escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);
      needsQuotes = needsQuotes || _quotes === true || typeof _quotes === 'function' && _quotes(str, col) || Array.isArray(_quotes) && _quotes[col] || hasAny(escapedQuoteStr, Papa.BAD_DELIMITERS) || escapedQuoteStr.indexOf(_delimiter) > -1 || escapedQuoteStr.charAt(0) === ' ' || escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === ' ';
      return needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;
    }
    function hasAny(str, substrings) {
      for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;
      return false;
    }
  }

  /** ChunkStreamer is the base prototype for various streamer implementations. */
  function ChunkStreamer(config) {
    this._handle = null;
    this._finished = false;
    this._completed = false;
    this._halted = false;
    this._input = null;
    this._baseIndex = 0;
    this._partialLine = '';
    this._rowCount = 0;
    this._start = 0;
    this._nextChunk = null;
    this.isFirstChunk = true;
    this._completeResults = {
      data: [],
      errors: [],
      meta: {}
    };
    replaceConfig.call(this, config);
    this.parseChunk = function (chunk, isFakeChunk) {
      // First chunk pre-processing
      if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {
        var modifiedChunk = this._config.beforeFirstChunk(chunk);
        if (modifiedChunk !== undefined) chunk = modifiedChunk;
      }
      this.isFirstChunk = false;
      this._halted = false;

      // Rejoin the line we likely just split in two by chunking the file
      var aggregate = this._partialLine + chunk;
      this._partialLine = '';
      var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);
      if (this._handle.paused() || this._handle.aborted()) {
        this._halted = true;
        return;
      }
      var lastIndex = results.meta.cursor;
      if (!this._finished) {
        this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
        this._baseIndex = lastIndex;
      }
      if (results && results.data) this._rowCount += results.data.length;
      var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;
      if (IS_PAPA_WORKER) {
        global.postMessage({
          results: results,
          workerId: Papa.WORKER_ID,
          finished: finishedIncludingPreview
        });
      } else if (isFunction(this._config.chunk) && !isFakeChunk) {
        this._config.chunk(results, this._handle);
        if (this._handle.paused() || this._handle.aborted()) {
          this._halted = true;
          return;
        }
        results = undefined;
        this._completeResults = undefined;
      }
      if (!this._config.step && !this._config.chunk) {
        this._completeResults.data = this._completeResults.data.concat(results.data);
        this._completeResults.errors = this._completeResults.errors.concat(results.errors);
        this._completeResults.meta = results.meta;
      }
      if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {
        this._config.complete(this._completeResults, this._input);
        this._completed = true;
      }
      if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();
      return results;
    };
    this._sendError = function (error) {
      if (isFunction(this._config.error)) this._config.error(error);else if (IS_PAPA_WORKER && this._config.error) {
        global.postMessage({
          workerId: Papa.WORKER_ID,
          error: error,
          finished: false
        });
      }
    };
    function replaceConfig(config) {
      // Deep-copy the config so we can edit it
      var configCopy = copy(config);
      configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!
      if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196
      this._handle = new ParserHandle(configCopy);
      this._handle.streamer = this;
      this._config = configCopy; // persist the copy to the caller
    }
  }

  function NetworkStreamer(config) {
    config = config || {};
    if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;
    ChunkStreamer.call(this, config);
    var xhr;
    if (IS_WORKER) {
      this._nextChunk = function () {
        this._readChunk();
        this._chunkLoaded();
      };
    } else {
      this._nextChunk = function () {
        this._readChunk();
      };
    }
    this.stream = function (url) {
      this._input = url;
      this._nextChunk(); // Starts streaming
    };

    this._readChunk = function () {
      if (this._finished) {
        this._chunkLoaded();
        return;
      }
      xhr = new XMLHttpRequest();
      if (this._config.withCredentials) {
        xhr.withCredentials = this._config.withCredentials;
      }
      if (!IS_WORKER) {
        xhr.onload = bindFunction(this._chunkLoaded, this);
        xhr.onerror = bindFunction(this._chunkError, this);
      }
      xhr.open(this._config.downloadRequestBody ? 'POST' : 'GET', this._input, !IS_WORKER);
      // Headers can only be set when once the request state is OPENED
      if (this._config.downloadRequestHeaders) {
        var headers = this._config.downloadRequestHeaders;
        for (var headerName in headers) {
          xhr.setRequestHeader(headerName, headers[headerName]);
        }
      }
      if (this._config.chunkSize) {
        var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive
        xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);
      }
      try {
        xhr.send(this._config.downloadRequestBody);
      } catch (err) {
        this._chunkError(err.message);
      }
      if (IS_WORKER && xhr.status === 0) this._chunkError();
    };
    this._chunkLoaded = function () {
      if (xhr.readyState !== 4) return;
      if (xhr.status < 200 || xhr.status >= 400) {
        this._chunkError();
        return;
      }

      // Use chunckSize as it may be a diference on reponse lentgh due to characters with more than 1 byte
      this._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;
      this._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);
      this.parseChunk(xhr.responseText);
    };
    this._chunkError = function (errorMessage) {
      var errorText = xhr.statusText || errorMessage;
      this._sendError(new Error(errorText));
    };
    function getFileSize(xhr) {
      var contentRange = xhr.getResponseHeader('Content-Range');
      if (contentRange === null) {
        // no content range, then finish!
        return -1;
      }
      return parseInt(contentRange.substring(contentRange.lastIndexOf('/') + 1));
    }
  }
  NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
  NetworkStreamer.prototype.constructor = NetworkStreamer;
  function FileStreamer(config) {
    config = config || {};
    if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;
    ChunkStreamer.call(this, config);
    var reader, slice;

    // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
    // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
    var usingAsyncReader = typeof FileReader !== 'undefined'; // Safari doesn't consider it a function - see issue #105

    this.stream = function (file) {
      this._input = file;
      slice = file.slice || file.webkitSlice || file.mozSlice;
      if (usingAsyncReader) {
        reader = new FileReader(); // Preferred method of reading files, even in workers
        reader.onload = bindFunction(this._chunkLoaded, this);
        reader.onerror = bindFunction(this._chunkError, this);
      } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox

      this._nextChunk(); // Starts streaming
    };

    this._nextChunk = function () {
      if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview)) this._readChunk();
    };
    this._readChunk = function () {
      var input = this._input;
      if (this._config.chunkSize) {
        var end = Math.min(this._start + this._config.chunkSize, this._input.size);
        input = slice.call(input, this._start, end);
      }
      var txt = reader.readAsText(input, this._config.encoding);
      if (!usingAsyncReader) this._chunkLoaded({
        target: {
          result: txt
        }
      }); // mimic the async signature
    };

    this._chunkLoaded = function (event) {
      // Very important to increment start each time before handling results
      this._start += this._config.chunkSize;
      this._finished = !this._config.chunkSize || this._start >= this._input.size;
      this.parseChunk(event.target.result);
    };
    this._chunkError = function () {
      this._sendError(reader.error);
    };
  }
  FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
  FileStreamer.prototype.constructor = FileStreamer;
  function StringStreamer(config) {
    config = config || {};
    ChunkStreamer.call(this, config);
    var remaining;
    this.stream = function (s) {
      remaining = s;
      return this._nextChunk();
    };
    this._nextChunk = function () {
      if (this._finished) return;
      var size = this._config.chunkSize;
      var chunk;
      if (size) {
        chunk = remaining.substring(0, size);
        remaining = remaining.substring(size);
      } else {
        chunk = remaining;
        remaining = '';
      }
      this._finished = !remaining;
      return this.parseChunk(chunk);
    };
  }
  StringStreamer.prototype = Object.create(StringStreamer.prototype);
  StringStreamer.prototype.constructor = StringStreamer;
  function ReadableStreamStreamer(config) {
    config = config || {};
    ChunkStreamer.call(this, config);
    var queue = [];
    var parseOnData = true;
    var streamHasEnded = false;
    this.pause = function () {
      ChunkStreamer.prototype.pause.apply(this, arguments);
      this._input.pause();
    };
    this.resume = function () {
      ChunkStreamer.prototype.resume.apply(this, arguments);
      this._input.resume();
    };
    this.stream = function (stream) {
      this._input = stream;
      this._input.on('data', this._streamData);
      this._input.on('end', this._streamEnd);
      this._input.on('error', this._streamError);
    };
    this._checkIsFinished = function () {
      if (streamHasEnded && queue.length === 1) {
        this._finished = true;
      }
    };
    this._nextChunk = function () {
      this._checkIsFinished();
      if (queue.length) {
        this.parseChunk(queue.shift());
      } else {
        parseOnData = true;
      }
    };
    this._streamData = bindFunction(function (chunk) {
      try {
        queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));
        if (parseOnData) {
          parseOnData = false;
          this._checkIsFinished();
          this.parseChunk(queue.shift());
        }
      } catch (error) {
        this._streamError(error);
      }
    }, this);
    this._streamError = bindFunction(function (error) {
      this._streamCleanUp();
      this._sendError(error);
    }, this);
    this._streamEnd = bindFunction(function () {
      this._streamCleanUp();
      streamHasEnded = true;
      this._streamData('');
    }, this);
    this._streamCleanUp = bindFunction(function () {
      this._input.removeListener('data', this._streamData);
      this._input.removeListener('end', this._streamEnd);
      this._input.removeListener('error', this._streamError);
    }, this);
  }
  ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
  ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;
  function DuplexStreamStreamer(_config) {
    var Duplex = _kame_require_("external:stream").Duplex;
    var config = copy(_config);
    var parseOnWrite = true;
    var writeStreamHasFinished = false;
    var parseCallbackQueue = [];
    var stream = null;
    this._onCsvData = function (results) {
      var data = results.data;
      if (!stream.push(data) && !this._handle.paused()) {
        // the writeable consumer buffer has filled up
        // so we need to pause until more items
        // can be processed
        this._handle.pause();
      }
    };
    this._onCsvComplete = function () {
      // node will finish the read stream when
      // null is pushed
      stream.push(null);
    };
    config.step = bindFunction(this._onCsvData, this);
    config.complete = bindFunction(this._onCsvComplete, this);
    ChunkStreamer.call(this, config);
    this._nextChunk = function () {
      if (writeStreamHasFinished && parseCallbackQueue.length === 1) {
        this._finished = true;
      }
      if (parseCallbackQueue.length) {
        parseCallbackQueue.shift()();
      } else {
        parseOnWrite = true;
      }
    };
    this._addToParseQueue = function (chunk, callback) {
      // add to queue so that we can indicate
      // completion via callback
      // node will automatically pause the incoming stream
      // when too many items have been added without their
      // callback being invoked
      parseCallbackQueue.push(bindFunction(function () {
        this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));
        if (isFunction(callback)) {
          return callback();
        }
      }, this));
      if (parseOnWrite) {
        parseOnWrite = false;
        this._nextChunk();
      }
    };
    this._onRead = function () {
      if (this._handle.paused()) {
        // the writeable consumer can handle more data
        // so resume the chunk parsing
        this._handle.resume();
      }
    };
    this._onWrite = function (chunk, encoding, callback) {
      this._addToParseQueue(chunk, callback);
    };
    this._onWriteComplete = function () {
      writeStreamHasFinished = true;
      // have to write empty string
      // so parser knows its done
      this._addToParseQueue('');
    };
    this.getStream = function () {
      return stream;
    };
    stream = new Duplex({
      readableObjectMode: true,
      decodeStrings: false,
      read: bindFunction(this._onRead, this),
      write: bindFunction(this._onWrite, this)
    });
    stream.once('finish', bindFunction(this._onWriteComplete, this));
  }
  if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
    DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
    DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;
  }

  // Use one ParserHandle per entire CSV file or string
  function ParserHandle(_config) {
    // One goal is to minimize the use of regular expressions...
    var MAX_FLOAT = Math.pow(2, 53);
    var MIN_FLOAT = -MAX_FLOAT;
    var FLOAT = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/;
    var ISO_DATE = /^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/;
    var self = this;
    var _stepCounter = 0; // Number of times step was called (number of rows parsed)
    var _rowCounter = 0; // Number of rows that have been parsed so far
    var _input; // The input being parsed
    var _parser; // The core parser being used
    var _paused = false; // Whether we are paused or not
    var _aborted = false; // Whether the parser has aborted or not
    var _delimiterError; // Temporary state between delimiter detection and processing results
    var _fields = []; // Fields are from the header row of the input, if there is one
    var _results = {
      // The last results returned from the parser
      data: [],
      errors: [],
      meta: {}
    };
    if (isFunction(_config.step)) {
      var userStep = _config.step;
      _config.step = function (results) {
        _results = results;
        if (needsHeaderRow()) processResults();else
          // only call user's step function after header row
          {
            processResults();

            // It's possbile that this line was empty and there's no row here after all
            if (_results.data.length === 0) return;
            _stepCounter += results.data.length;
            if (_config.preview && _stepCounter > _config.preview) _parser.abort();else {
              _results.data = _results.data[0];
              userStep(_results, self);
            }
          }
      };
    }

    /**
     * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
     * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
     * when an input comes in multiple chunks, like from a file.
     */
    this.parse = function (input, baseIndex, ignoreLastRow) {
      var quoteChar = _config.quoteChar || '"';
      if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);
      _delimiterError = false;
      if (!_config.delimiter) {
        var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);
        if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;else {
          _delimiterError = true; // add error after parsing (otherwise it would be overwritten)
          _config.delimiter = Papa.DefaultDelimiter;
        }
        _results.meta.delimiter = _config.delimiter;
      } else if (isFunction(_config.delimiter)) {
        _config.delimiter = _config.delimiter(input);
        _results.meta.delimiter = _config.delimiter;
      }
      var parserConfig = copy(_config);
      if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row

      _input = input;
      _parser = new Parser(parserConfig);
      _results = _parser.parse(_input, baseIndex, ignoreLastRow);
      processResults();
      return _paused ? {
        meta: {
          paused: true
        }
      } : _results || {
        meta: {
          paused: false
        }
      };
    };
    this.paused = function () {
      return _paused;
    };
    this.pause = function () {
      _paused = true;
      _parser.abort();

      // If it is streaming via "chunking", the reader will start appending correctly already so no need to substring,
      // otherwise we can get duplicate content within a row
      _input = isFunction(_config.chunk) ? "" : _input.substring(_parser.getCharIndex());
    };
    this.resume = function () {
      if (self.streamer._halted) {
        _paused = false;
        self.streamer.parseChunk(_input, true);
      } else {
        // Bugfix: #636 In case the processing hasn't halted yet
        // wait for it to halt in order to resume
        setTimeout(self.resume, 3);
      }
    };
    this.aborted = function () {
      return _aborted;
    };
    this.abort = function () {
      _aborted = true;
      _parser.abort();
      _results.meta.aborted = true;
      if (isFunction(_config.complete)) _config.complete(_results);
      _input = '';
    };
    function testEmptyLine(s) {
      return _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;
    }
    function testFloat(s) {
      if (FLOAT.test(s)) {
        var floatValue = parseFloat(s);
        if (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {
          return true;
        }
      }
      return false;
    }
    function processResults() {
      if (_results && _delimiterError) {
        addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \'' + Papa.DefaultDelimiter + '\'');
        _delimiterError = false;
      }
      if (_config.skipEmptyLines) {
        _results.data = _results.data.filter(function (d) {
          return !testEmptyLine(d);
        });
      }
      if (needsHeaderRow()) fillHeaderFields();
      return applyHeaderAndDynamicTypingAndTransformation();
    }
    function needsHeaderRow() {
      return _config.header && _fields.length === 0;
    }
    function fillHeaderFields() {
      if (!_results) return;
      function addHeader(header, i) {
        if (isFunction(_config.transformHeader)) header = _config.transformHeader(header, i);
        _fields.push(header);
      }
      if (Array.isArray(_results.data[0])) {
        for (var i = 0; needsHeaderRow() && i < _results.data.length; i++) _results.data[i].forEach(addHeader);
        _results.data.splice(0, 1);
      }
      // if _results.data[0] is not an array, we are in a step where _results.data is the row.
      else _results.data.forEach(addHeader);
    }
    function shouldApplyDynamicTyping(field) {
      // Cache function values to avoid calling it for each row
      if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
        _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
      }
      return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
    }
    function parseDynamic(field, value) {
      if (shouldApplyDynamicTyping(field)) {
        if (value === 'true' || value === 'TRUE') return true;else if (value === 'false' || value === 'FALSE') return false;else if (testFloat(value)) return parseFloat(value);else if (ISO_DATE.test(value)) return new Date(value);else return value === '' ? null : value;
      }
      return value;
    }
    function applyHeaderAndDynamicTypingAndTransformation() {
      if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;
      function processRow(rowSource, i) {
        var row = _config.header ? {} : [];
        var j;
        for (j = 0; j < rowSource.length; j++) {
          var field = j;
          var value = rowSource[j];
          if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];
          if (_config.transform) value = _config.transform(value, field);
          value = parseDynamic(field, value);
          if (field === '__parsed_extra') {
            row[field] = row[field] || [];
            row[field].push(value);
          } else row[field] = value;
        }
        if (_config.header) {
          if (j > _fields.length) addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);else if (j < _fields.length) addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);
        }
        return row;
      }
      var incrementBy = 1;
      if (!_results.data.length || Array.isArray(_results.data[0])) {
        _results.data = _results.data.map(processRow);
        incrementBy = _results.data.length;
      } else _results.data = processRow(_results.data, 0);
      if (_config.header && _results.meta) _results.meta.fields = _fields;
      _rowCounter += incrementBy;
      return _results;
    }
    function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
      var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;
      delimitersToGuess = delimitersToGuess || [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];
      for (var i = 0; i < delimitersToGuess.length; i++) {
        var delim = delimitersToGuess[i];
        var delta = 0,
          avgFieldCount = 0,
          emptyLinesCount = 0;
        fieldCountPrevRow = undefined;
        var preview = new Parser({
          comments: comments,
          delimiter: delim,
          newline: newline,
          preview: 10
        }).parse(input);
        for (var j = 0; j < preview.data.length; j++) {
          if (skipEmptyLines && testEmptyLine(preview.data[j])) {
            emptyLinesCount++;
            continue;
          }
          var fieldCount = preview.data[j].length;
          avgFieldCount += fieldCount;
          if (typeof fieldCountPrevRow === 'undefined') {
            fieldCountPrevRow = fieldCount;
            continue;
          } else if (fieldCount > 0) {
            delta += Math.abs(fieldCount - fieldCountPrevRow);
            fieldCountPrevRow = fieldCount;
          }
        }
        if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;
        if ((typeof bestDelta === 'undefined' || delta <= bestDelta) && (typeof maxFieldCount === 'undefined' || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {
          bestDelta = delta;
          bestDelim = delim;
          maxFieldCount = avgFieldCount;
        }
      }
      _config.delimiter = bestDelim;
      return {
        successful: !!bestDelim,
        bestDelimiter: bestDelim
      };
    }
    function guessLineEndings(input, quoteChar) {
      input = input.substring(0, 1024 * 1024); // max length 1 MB
      // Replace all the text inside quotes
      var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');
      input = input.replace(re, '');
      var r = input.split('\r');
      var n = input.split('\n');
      var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;
      if (r.length === 1 || nAppearsFirst) return '\n';
      var numWithN = 0;
      for (var i = 0; i < r.length; i++) {
        if (r[i][0] === '\n') numWithN++;
      }
      return numWithN >= r.length / 2 ? '\r\n' : '\r';
    }
    function addError(type, code, msg, row) {
      var error = {
        type: type,
        code: code,
        message: msg
      };
      if (row !== undefined) {
        error.row = row;
      }
      _results.errors.push(error);
    }
  }

  /** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
  }

  /** The core parser implements speedy and correct CSV parsing */
  function Parser(config) {
    // Unpack the config object
    config = config || {};
    var delim = config.delimiter;
    var newline = config.newline;
    var comments = config.comments;
    var step = config.step;
    var preview = config.preview;
    var fastMode = config.fastMode;
    var quoteChar;
    if (config.quoteChar === undefined || config.quoteChar === null) {
      quoteChar = '"';
    } else {
      quoteChar = config.quoteChar;
    }
    var escapeChar = quoteChar;
    if (config.escapeChar !== undefined) {
      escapeChar = config.escapeChar;
    }

    // Delimiter must be valid
    if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';

    // Comment character must be valid
    if (comments === delim) throw new Error('Comment character same as delimiter');else if (comments === true) comments = '#';else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1) comments = false;

    // Newline must be valid: \r, \n, or \r\n
    if (newline !== '\n' && newline !== '\r' && newline !== '\r\n') newline = '\n';

    // We're gonna need these at the Parser scope
    var cursor = 0;
    var aborted = false;
    this.parse = function (input, baseIndex, ignoreLastRow) {
      // For some reason, in Chrome, this speeds things up (!?)
      if (typeof input !== 'string') throw new Error('Input must be a string');

      // We don't need to compute some of these every time parse() is called,
      // but having them in a more local scope seems to perform better
      var inputLen = input.length,
        delimLen = delim.length,
        newlineLen = newline.length,
        commentsLen = comments.length;
      var stepIsFunction = isFunction(step);

      // Establish starting state
      cursor = 0;
      var data = [],
        errors = [],
        row = [],
        lastCursor = 0;
      if (!input) return returnable();
      if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {
        var rows = input.split(newline);
        for (var i = 0; i < rows.length; i++) {
          row = rows[i];
          cursor += row.length;
          if (i !== rows.length - 1) cursor += newline.length;else if (ignoreLastRow) return returnable();
          if (comments && row.substring(0, commentsLen) === comments) continue;
          if (stepIsFunction) {
            data = [];
            pushRow(row.split(delim));
            doStep();
            if (aborted) return returnable();
          } else pushRow(row.split(delim));
          if (preview && i >= preview) {
            data = data.slice(0, preview);
            return returnable(true);
          }
        }
        return returnable();
      }
      var nextDelim = input.indexOf(delim, cursor);
      var nextNewline = input.indexOf(newline, cursor);
      var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');
      var quoteSearch = input.indexOf(quoteChar, cursor);

      // Parser loop
      for (;;) {
        // Field has opening quote
        if (input[cursor] === quoteChar) {
          // Start our search for the closing quote where the cursor is
          quoteSearch = cursor;

          // Skip the opening quote
          cursor++;
          for (;;) {
            // Find closing quote
            quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

            //No other quotes are found - no other delimiters
            if (quoteSearch === -1) {
              if (!ignoreLastRow) {
                // No closing quote... what a pity
                errors.push({
                  type: 'Quotes',
                  code: 'MissingQuotes',
                  message: 'Quoted field unterminated',
                  row: data.length,
                  // row has yet to be inserted
                  index: cursor
                });
              }
              return finish();
            }

            // Closing quote at EOF
            if (quoteSearch === inputLen - 1) {
              var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
              return finish(value);
            }

            // If this quote is escaped, it's part of the data; skip it
            // If the quote character is the escape character, then check if the next character is the escape character
            if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
              quoteSearch++;
              continue;
            }

            // If the quote character is not the escape character, then check if the previous character was the escape character
            if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {
              continue;
            }
            if (nextDelim !== -1 && nextDelim < quoteSearch + 1) {
              nextDelim = input.indexOf(delim, quoteSearch + 1);
            }
            if (nextNewline !== -1 && nextNewline < quoteSearch + 1) {
              nextNewline = input.indexOf(newline, quoteSearch + 1);
            }
            // Check up to nextDelim or nextNewline, whichever is closest
            var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
            var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);

            // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'
            if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndDelimiter, delimLen) === delim) {
              row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
              cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;

              // If char after following delimiter is not quoteChar, we find next quote char position
              if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar) {
                quoteSearch = input.indexOf(quoteChar, cursor);
              }
              nextDelim = input.indexOf(delim, cursor);
              nextNewline = input.indexOf(newline, cursor);
              break;
            }
            var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

            // Closing quote followed by newline or 'unnecessary spaces + newLine'
            if (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline) {
              row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
              saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
              nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field
              quoteSearch = input.indexOf(quoteChar, cursor); // we search for first quote in next line

              if (stepIsFunction) {
                doStep();
                if (aborted) return returnable();
              }
              if (preview && data.length >= preview) return returnable(true);
              break;
            }

            // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string
            errors.push({
              type: 'Quotes',
              code: 'InvalidQuotes',
              message: 'Trailing quote on quoted field is malformed',
              row: data.length,
              // row has yet to be inserted
              index: cursor
            });
            quoteSearch++;
            continue;
          }
          continue;
        }

        // Comment found at start of new line
        if (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments) {
          if (nextNewline === -1)
            // Comment ends at EOF
            return returnable();
          cursor = nextNewline + newlineLen;
          nextNewline = input.indexOf(newline, cursor);
          nextDelim = input.indexOf(delim, cursor);
          continue;
        }

        // Next delimiter comes before next newline, so we've reached end of field
        if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
          row.push(input.substring(cursor, nextDelim));
          cursor = nextDelim + delimLen;
          // we look for next delimiter char
          nextDelim = input.indexOf(delim, cursor);
          continue;
        }

        // End of row
        if (nextNewline !== -1) {
          row.push(input.substring(cursor, nextNewline));
          saveRow(nextNewline + newlineLen);
          if (stepIsFunction) {
            doStep();
            if (aborted) return returnable();
          }
          if (preview && data.length >= preview) return returnable(true);
          continue;
        }
        break;
      }
      return finish();
      function pushRow(row) {
        data.push(row);
        lastCursor = cursor;
      }

      /**
                * checks if there are extra spaces after closing quote and given index without any text
                * if Yes, returns the number of spaces
                */
      function extraSpaces(index) {
        var spaceLength = 0;
        if (index !== -1) {
          var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
          if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
            spaceLength = textBetweenClosingQuoteAndIndex.length;
          }
        }
        return spaceLength;
      }

      /**
       * Appends the remaining input from cursor to the end into
       * row, saves the row, calls step, and returns the results.
       */
      function finish(value) {
        if (ignoreLastRow) return returnable();
        if (typeof value === 'undefined') value = input.substring(cursor);
        row.push(value);
        cursor = inputLen; // important in case parsing is paused
        pushRow(row);
        if (stepIsFunction) doStep();
        return returnable();
      }

      /**
       * Appends the current row to the results. It sets the cursor
       * to newCursor and finds the nextNewline. The caller should
       * take care to execute user's step function and check for
       * preview and end parsing if necessary.
       */
      function saveRow(newCursor) {
        cursor = newCursor;
        pushRow(row);
        row = [];
        nextNewline = input.indexOf(newline, cursor);
      }

      /** Returns an object with the results, errors, and meta. */
      function returnable(stopped) {
        return {
          data: data,
          errors: errors,
          meta: {
            delimiter: delim,
            linebreak: newline,
            aborted: aborted,
            truncated: !!stopped,
            cursor: lastCursor + (baseIndex || 0)
          }
        };
      }

      /** Executes the user's step function and resets data & errors. */
      function doStep() {
        step(returnable());
        data = [];
        errors = [];
      }
    };

    /** Sets the abort flag */
    this.abort = function () {
      aborted = true;
    };

    /** Gets the cursor position */
    this.getCharIndex = function () {
      return cursor;
    };
  }
  function newWorker() {
    if (!Papa.WORKERS_SUPPORTED) return false;
    var workerUrl = getWorkerBlob();
    var w = new global.Worker(workerUrl);
    w.onmessage = mainThreadReceivedMessage;
    w.id = workerIdCounter++;
    workers[w.id] = w;
    return w;
  }

  /** Callback when main thread receives a message */
  function mainThreadReceivedMessage(e) {
    var msg = e.data;
    var worker = workers[msg.workerId];
    var aborted = false;
    if (msg.error) worker.userError(msg.error, msg.file);else if (msg.results && msg.results.data) {
      var abort = function () {
        aborted = true;
        completeWorker(msg.workerId, {
          data: [],
          errors: [],
          meta: {
            aborted: true
          }
        });
      };
      var handle = {
        abort: abort,
        pause: notImplemented,
        resume: notImplemented
      };
      if (isFunction(worker.userStep)) {
        for (var i = 0; i < msg.results.data.length; i++) {
          worker.userStep({
            data: msg.results.data[i],
            errors: msg.results.errors,
            meta: msg.results.meta
          }, handle);
          if (aborted) break;
        }
        delete msg.results; // free memory ASAP
      } else if (isFunction(worker.userChunk)) {
        worker.userChunk(msg.results, handle, msg.file);
        delete msg.results;
      }
    }
    if (msg.finished && !aborted) completeWorker(msg.workerId, msg.results);
  }
  function completeWorker(workerId, results) {
    var worker = workers[workerId];
    if (isFunction(worker.userComplete)) worker.userComplete(results);
    worker.terminate();
    delete workers[workerId];
  }
  function notImplemented() {
    throw new Error('Not implemented.');
  }

  /** Callback when worker thread receives a message */
  function workerThreadReceivedMessage(e) {
    var msg = e.data;
    if (typeof Papa.WORKER_ID === 'undefined' && msg) Papa.WORKER_ID = msg.workerId;
    if (typeof msg.input === 'string') {
      global.postMessage({
        workerId: Papa.WORKER_ID,
        results: Papa.parse(msg.input, msg.config),
        finished: true
      });
    } else if (global.File && msg.input instanceof File || msg.input instanceof Object)
      // thank you, Safari (see issue #106)
      {
        var results = Papa.parse(msg.input, msg.config);
        if (results) global.postMessage({
          workerId: Papa.WORKER_ID,
          results: results,
          finished: true
        });
      }
  }

  /** Makes a deep copy of an array or object (mostly) */
  function copy(obj) {
    if (typeof obj !== 'object' || obj === null) return obj;
    var cpy = Array.isArray(obj) ? [] : {};
    for (var key in obj) cpy[key] = copy(obj[key]);
    return cpy;
  }
  function bindFunction(f, self) {
    return function () {
      f.apply(self, arguments);
    };
  }
  function isFunction(func) {
    return typeof func === 'function';
  }
  return Papa;
});
}),
/* --- node_modules/yaml/dist/index.js --- */
"node_modules/yaml/dist/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var composer = _kame_require_("node_modules/yaml/dist/compose/composer.js");
var Document = _kame_require_("node_modules/yaml/dist/doc/Document.js");
var Schema = _kame_require_("node_modules/yaml/dist/schema/Schema.js");
var errors = _kame_require_("node_modules/yaml/dist/errors.js");
var Alias = _kame_require_("node_modules/yaml/dist/nodes/Alias.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Pair = _kame_require_("node_modules/yaml/dist/nodes/Pair.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var YAMLMap = _kame_require_("node_modules/yaml/dist/nodes/YAMLMap.js");
var YAMLSeq = _kame_require_("node_modules/yaml/dist/nodes/YAMLSeq.js");
var cst = _kame_require_("node_modules/yaml/dist/parse/cst.js");
var lexer = _kame_require_("node_modules/yaml/dist/parse/lexer.js");
var lineCounter = _kame_require_("node_modules/yaml/dist/parse/line-counter.js");
var parser = _kame_require_("node_modules/yaml/dist/parse/parser.js");
var publicApi = _kame_require_("node_modules/yaml/dist/public-api.js");
var visit = _kame_require_("node_modules/yaml/dist/visit.js");
exports.Composer = composer.Composer;
exports.Document = Document.Document;
exports.Schema = Schema.Schema;
exports.YAMLError = errors.YAMLError;
exports.YAMLParseError = errors.YAMLParseError;
exports.YAMLWarning = errors.YAMLWarning;
exports.Alias = Alias.Alias;
exports.isAlias = Node.isAlias;
exports.isCollection = Node.isCollection;
exports.isDocument = Node.isDocument;
exports.isMap = Node.isMap;
exports.isNode = Node.isNode;
exports.isPair = Node.isPair;
exports.isScalar = Node.isScalar;
exports.isSeq = Node.isSeq;
exports.Pair = Pair.Pair;
exports.Scalar = Scalar.Scalar;
exports.YAMLMap = YAMLMap.YAMLMap;
exports.YAMLSeq = YAMLSeq.YAMLSeq;
exports.CST = cst;
exports.Lexer = lexer.Lexer;
exports.LineCounter = lineCounter.LineCounter;
exports.Parser = parser.Parser;
exports.parse = publicApi.parse;
exports.parseAllDocuments = publicApi.parseAllDocuments;
exports.parseDocument = publicApi.parseDocument;
exports.stringify = publicApi.stringify;
exports.visit = visit.visit;
exports.visitAsync = visit.visitAsync;
}),
/* --- node_modules/clef-parse/dist/index.js --- */
"node_modules/clef-parse/dist/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseArgv = exports.Path = void 0;
const path_1 = __importDefault(_kame_require_("src/kame-module-stub.js"));
const convert_case_1 = _kame_require_("node_modules/clef-parse/dist/convert-case.js");
exports.Path = Symbol("Path");
function bestGuess(nextValue) {
  if (nextValue === "true" || nextValue === "false") {
    return Boolean;
  } else if (nextValue == null || nextValue.startsWith("-")) {
    return Boolean;
  } else if (nextValue === String(Number(nextValue))) {
    return Number;
  } else {
    return String;
  }
}
function parseArgv(argv = process.argv.slice(2), hints = {}, {
  isAbsolute = path_1.default.isAbsolute,
  resolvePath = path_1.default.resolve,
  getCwd = process.cwd
} = {}) {
  const options = {};
  const positionalArgs = [];
  let isAfterDoubleDash = false;
  while (argv.length > 0) {
    let item = argv.shift();
    if (item == null) break;
    if (item === "--") {
      isAfterDoubleDash = true;
      continue;
    }
    if (item.startsWith("-")) {
      if (isAfterDoubleDash) {
        positionalArgs.push(item);
      } else {
        let propertyName;
        if (item.length === 2) {
          propertyName = item[1];
        } else {
          if (!item.startsWith("--")) {
            throw new Error(`Invalid command-line flag: '${item}'. Single-character command-line flags should only have one dash before them, and multi-character command-line flags should have two dashes before them. If you want to pass '${item}' as a positional argument, place it after a '--'.`);
          }
          propertyName = (0, convert_case_1.convertToCamelCase)(item.replace(/^--/, ""));
        }
        let propertyValue;
        let propertyHint = hints[propertyName];
        const nextValue = argv[0];
        if (propertyHint == null) {
          propertyHint = bestGuess(nextValue);
        }
        switch (propertyHint) {
          case Boolean:
            {
              if (nextValue === "false") {
                argv.shift();
                propertyValue = false;
              } else {
                if (nextValue === "true") {
                  argv.shift();
                }
                propertyValue = true;
              }
              break;
            }
          case Number:
            {
              argv.shift();
              propertyValue = Number(nextValue);
              break;
            }
          case String:
            {
              argv.shift();
              propertyValue = nextValue;
              break;
            }
          case exports.Path:
            {
              argv.shift();
              propertyValue = isAbsolute(nextValue) ? nextValue : resolvePath(getCwd(), nextValue);
              break;
            }
          default:
            {
              throw new Error(`Invalid option hint: ${propertyHint}`);
            }
        }
        options[propertyName] = propertyValue;
      }
    } else {
      positionalArgs.push(item);
    }
  }
  return {
    options,
    positionalArgs
  };
}
exports.parseArgv = parseArgv;
}),
/* --- node_modules/sucrase/dist/index.js --- */
"node_modules/sucrase/dist/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _CJSImportProcessor = _kame_require_("node_modules/sucrase/dist/CJSImportProcessor.js");
var _CJSImportProcessor2 = _interopRequireDefault(_CJSImportProcessor);
var _computeSourceMap = _kame_require_("node_modules/sucrase/dist/computeSourceMap.js");
var _computeSourceMap2 = _interopRequireDefault(_computeSourceMap);
var _HelperManager = _kame_require_("node_modules/sucrase/dist/HelperManager.js");
var _identifyShadowedGlobals = _kame_require_("node_modules/sucrase/dist/identifyShadowedGlobals.js");
var _identifyShadowedGlobals2 = _interopRequireDefault(_identifyShadowedGlobals);
var _NameManager = _kame_require_("node_modules/sucrase/dist/NameManager.js");
var _NameManager2 = _interopRequireDefault(_NameManager);
var _Options = _kame_require_("node_modules/sucrase/dist/Options.js");
var _parser = _kame_require_("node_modules/sucrase/dist/parser/index.js");
var _TokenProcessor = _kame_require_("node_modules/sucrase/dist/TokenProcessor.js");
var _TokenProcessor2 = _interopRequireDefault(_TokenProcessor);
var _RootTransformer = _kame_require_("node_modules/sucrase/dist/transformers/RootTransformer.js");
var _RootTransformer2 = _interopRequireDefault(_RootTransformer);
var _formatTokens = _kame_require_("node_modules/sucrase/dist/util/formatTokens.js");
var _formatTokens2 = _interopRequireDefault(_formatTokens);
var _getTSImportedNames = _kame_require_("node_modules/sucrase/dist/util/getTSImportedNames.js");
var _getTSImportedNames2 = _interopRequireDefault(_getTSImportedNames);
function getVersion() {
  /* istanbul ignore next */
  return "3.29.0";
}
exports.getVersion = getVersion;
function transform(code, options) {
  _Options.validateOptions.call(void 0, options);
  try {
    const sucraseContext = getSucraseContext(code, options);
    const transformer = new (0, _RootTransformer2.default)(sucraseContext, options.transforms, Boolean(options.enableLegacyBabel5ModuleInterop), options);
    let result = {
      code: transformer.transform()
    };
    if (options.sourceMapOptions) {
      if (!options.filePath) {
        throw new Error("filePath must be specified when generating a source map.");
      }
      result = {
        ...result,
        sourceMap: _computeSourceMap2.default.call(void 0, result.code, options.filePath, options.sourceMapOptions)
      };
    }
    return result;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (e) {
    if (options.filePath) {
      e.message = `Error transforming ${options.filePath}: ${e.message}`;
    }
    throw e;
  }
}
exports.transform = transform;

/**
 * Return a string representation of the sucrase tokens, mostly useful for
 * diagnostic purposes.
 */
function getFormattedTokens(code, options) {
  const tokens = getSucraseContext(code, options).tokenProcessor.tokens;
  return _formatTokens2.default.call(void 0, code, tokens);
}
exports.getFormattedTokens = getFormattedTokens;

/**
 * Call into the parser/tokenizer and do some further preprocessing:
 * - Come up with a set of used names so that we can assign new names.
 * - Preprocess all import/export statements so we know which globals we are interested in.
 * - Compute situations where any of those globals are shadowed.
 *
 * In the future, some of these preprocessing steps can be skipped based on what actual work is
 * being done.
 */
function getSucraseContext(code, options) {
  const isJSXEnabled = options.transforms.includes("jsx");
  const isTypeScriptEnabled = options.transforms.includes("typescript");
  const isFlowEnabled = options.transforms.includes("flow");
  const disableESTransforms = options.disableESTransforms === true;
  const file = _parser.parse.call(void 0, code, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);
  const tokens = file.tokens;
  const scopes = file.scopes;
  const nameManager = new (0, _NameManager2.default)(code, tokens);
  const helperManager = new (0, _HelperManager.HelperManager)(nameManager);
  const tokenProcessor = new (0, _TokenProcessor2.default)(code, tokens, isFlowEnabled, disableESTransforms, helperManager);
  const enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);
  let importProcessor = null;
  if (options.transforms.includes("imports")) {
    importProcessor = new (0, _CJSImportProcessor2.default)(nameManager, tokenProcessor, enableLegacyTypeScriptModuleInterop, options, options.transforms.includes("typescript"), helperManager);
    importProcessor.preprocessTokens();
    // We need to mark shadowed globals after processing imports so we know that the globals are,
    // but before type-only import pruning, since that relies on shadowing information.
    _identifyShadowedGlobals2.default.call(void 0, tokenProcessor, scopes, importProcessor.getGlobalNames());
    if (options.transforms.includes("typescript")) {
      importProcessor.pruneTypeOnlyImports();
    }
  } else if (options.transforms.includes("typescript")) {
    _identifyShadowedGlobals2.default.call(void 0, tokenProcessor, scopes, _getTSImportedNames2.default.call(void 0, tokenProcessor));
  }
  return {
    tokenProcessor,
    scopes,
    nameManager,
    importProcessor,
    helperManager
  };
}
}),
/* --- node_modules/coffeescript/lib/coffeescript/index.js --- */
"node_modules/coffeescript/lib/coffeescript/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  // Node.js Implementation
  var CoffeeScript,
    ext,
    fs,
    helpers,
    i,
    len,
    path,
    ref,
    universalCompile,
    vm,
    hasProp = {}.hasOwnProperty;
  CoffeeScript = _kame_require_("node_modules/coffeescript/lib/coffeescript/coffeescript.js");
  fs = _kame_require_("src/kame-module-stub.js");
  vm = _kame_require_("src/kame-module-stub.js");
  path = _kame_require_("src/kame-module-stub.js");
  helpers = CoffeeScript.helpers;
  CoffeeScript.transpile = function (js, options) {
    var babel;
    try {
      babel = _kame_require_("external:@babel/core");
    } catch (error) {
      try {
        babel = _kame_require_("external:babel-core");
      } catch (error) {
        // This error is only for Node, as CLI users will see a different error
        // earlier if they dont have Babel installed.
        throw new Error('To use the transpile option, you must have the \'@babel/core\' module installed');
      }
    }
    return babel.transform(js, options);
  };

  // The `compile` method shared by the CLI, Node and browser APIs.
  universalCompile = CoffeeScript.compile;

  // The `compile` method particular to the Node API.
  CoffeeScript.compile = function (code, options) {
    // Pass a reference to Babel into the compiler, so that the transpile option
    // is available in the Node API. We need to do this so that tools like Webpack
    // can `require('coffeescript')` and build correctly, without trying to
    // require Babel.
    if (options != null ? options.transpile : void 0) {
      options.transpile.transpile = CoffeeScript.transpile;
    }
    return universalCompile.call(CoffeeScript, code, options);
  };

  // Compile and execute a string of CoffeeScript (on the server), correctly
  // setting `__filename`, `__dirname`, and relative `require()`.
  CoffeeScript.run = function (code, options = {}) {
    var answer, dir, mainModule, ref;
    mainModule = require.main;
    // Set the filename.
    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : helpers.anonymousFileName();
    // Clear the module cache.
    mainModule.moduleCache && (mainModule.moduleCache = {});
    // Assign paths for node_modules loading
    dir = options.filename != null ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');
    mainModule.paths = _kame_require_("external:module")._nodeModulePaths(dir);
    // Save the options for compiling child imports.
    mainModule.options = options;
    options.filename = mainModule.filename;
    options.inlineMap = true;
    // Compile.
    answer = CoffeeScript.compile(code, options);
    code = (ref = answer.js) != null ? ref : answer;
    return mainModule._compile(code, mainModule.filename);
  };

  // Compile and evaluate a string of CoffeeScript (in a Node.js-like environment).
  // The CoffeeScript REPL uses this to run the input.
  CoffeeScript.eval = function (code, options = {}) {
    var Module, _module, _require, createContext, i, isContext, js, k, len, o, r, ref, ref1, ref2, ref3, sandbox, v;
    if (!(code = code.trim())) {
      return;
    }
    createContext = (ref = vm.Script.createContext) != null ? ref : vm.createContext;
    isContext = (ref1 = vm.isContext) != null ? ref1 : function (ctx) {
      return options.sandbox instanceof createContext().constructor;
    };
    if (createContext) {
      if (options.sandbox != null) {
        if (isContext(options.sandbox)) {
          sandbox = options.sandbox;
        } else {
          sandbox = createContext();
          ref2 = options.sandbox;
          for (k in ref2) {
            if (!hasProp.call(ref2, k)) continue;
            v = ref2[k];
            sandbox[k] = v;
          }
        }
        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
      } else {
        sandbox = global;
      }
      sandbox.__filename = options.filename || 'eval';
      sandbox.__dirname = path.dirname(sandbox.__filename);
      // define module/require only if they chose not to specify their own
      if (!(sandbox !== global || sandbox.module || sandbox.require)) {
        Module = _kame_require_("external:module");
        sandbox.module = _module = new Module(options.modulename || 'eval');
        sandbox.require = _require = function (path) {
          return Module._load(path, _module, true);
        };
        _module.filename = sandbox.__filename;
        ref3 = Object.getOwnPropertyNames(require);
        for (i = 0, len = ref3.length; i < len; i++) {
          r = ref3[i];
          if (r !== 'paths' && r !== 'arguments' && r !== 'caller') {
            _require[r] = require[r];
          }
        }
        // use the same hack node currently uses for their own REPL
        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
        _require.resolve = function (request) {
          return Module._resolveFilename(request, _module);
        };
      }
    }
    o = {};
    for (k in options) {
      if (!hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true; // ensure return value
    js = CoffeeScript.compile(code, o);
    if (sandbox === global) {
      return vm.runInThisContext(js);
    } else {
      return vm.runInContext(js, sandbox);
    }
  };
  CoffeeScript.register = function () {
    return _kame_require_("node_modules/coffeescript/lib/coffeescript/register.js");
  };

  // Throw error with deprecation warning when depending upon implicit `require.extensions` registration
  if (require.extensions) {
    ref = CoffeeScript.FILE_EXTENSIONS;
    for (i = 0, len = ref.length; i < len; i++) {
      ext = ref[i];
      (function (ext) {
        var base;
        return (base = require.extensions)[ext] != null ? base[ext] : base[ext] = function () {
          throw new Error(`Use CoffeeScript.register() or require the coffeescript/register module to require ${ext} files.`);
        };
      })(ext);
    }
  }
  CoffeeScript._compileRawFileContent = function (raw, filename, options = {}) {
    var answer, err, stripped;
    // Strip the Unicode byte order mark, if this file begins with one.
    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    options = Object.assign({}, options, {
      filename: filename,
      literate: helpers.isLiterate(filename),
      sourceFiles: [filename]
    });
    try {
      answer = CoffeeScript.compile(stripped, options);
    } catch (error) {
      err = error;
      // As the filename and code of a dynamically loaded file will be different
      // from the original file compiled with CoffeeScript.run, add that
      // information to error so it can be pretty-printed later.
      throw helpers.updateSyntaxError(err, stripped, filename);
    }
    return answer;
  };
  CoffeeScript._compileFile = function (filename, options = {}) {
    var raw;
    raw = fs.readFileSync(filename, 'utf8');
    return CoffeeScript._compileRawFileContent(raw, filename, options);
  };
  module.exports = CoffeeScript;

  // Explicitly define all named exports so that Nodes automatic detection of
  // named exports from CommonJS packages finds all of them. This enables consuming
  // packages to write code like `import { compile } from 'coffeescript'`.
  // Dont simplify this into a loop or similar; the `module.exports.name` part is
  // essential for Nodes algorithm to successfully detect the name.
  module.exports.VERSION = CoffeeScript.VERSION;
  module.exports.FILE_EXTENSIONS = CoffeeScript.FILE_EXTENSIONS;
  module.exports.helpers = CoffeeScript.helpers;
  module.exports.registerCompiled = CoffeeScript.registerCompiled;
  module.exports.compile = CoffeeScript.compile;
  module.exports.tokens = CoffeeScript.tokens;
  module.exports.nodes = CoffeeScript.nodes;
  module.exports.register = CoffeeScript.register;
  module.exports.eval = CoffeeScript.eval;
  module.exports.run = CoffeeScript.run;
  module.exports.transpile = CoffeeScript.transpile;
  module.exports.patchStackTrace = CoffeeScript.patchStackTrace;
  module.exports._compileRawFileContent = CoffeeScript._compileRawFileContent;
  module.exports._compileFile = CoffeeScript._compileFile;
}).call(void 0);
}),
/* --- src/api/exec/parse-arg-string.ts --- */
"src/api/exec/parse-arg-string.ts": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseArgString = parseArgString;
// Used internally by `exec`. Exported from a separate file for testing purposes

function parseArgString(args) {
  const result = [];
  let mode = "DEFAULT";
  let argBeingBuilt = "";
  const chars = args.split("");
  for (let i = 0; i < chars.length; i++) {
    const prevChar = chars[i - 1] ?? null;
    const char = chars[i];
    const nextChar = chars[i + 1] ?? null;
    switch (`${char} during ${mode}`) {
      case `" during DEFAULT`:
        {
          mode = "IN_DOUBLE_STRING";
          break;
        }
      case `' during DEFAULT`:
        {
          mode = "IN_SINGLE_STRING";
          break;
        }
      case `${" "} during DEFAULT`:
      case `\t during DEFAULT`:
      case `\v during DEFAULT`:
      case `\n during DEFAULT`:
      case `\r during DEFAULT`:
        {
          if (argBeingBuilt.length > 0) {
            result.push(argBeingBuilt);
            argBeingBuilt = "";
          }
          break;
        }
      case `\\ during DEFAULT`:
        {
          if (nextChar === "\n" || nextChar === "\r") {
            // They are trying to escape the next newline like in bash.
            // They don't need to, but support this case in the way
            // they'd expect.
            break;
          } else {
            argBeingBuilt += "\\";
            break;
          }
        }
      case `" during IN_DOUBLE_STRING`:
        {
          if (prevChar === "\\") {
            argBeingBuilt += `"`;
          } else {
            // in order to support string gluing
            if (nextChar !== `'` && nextChar !== `"`) {
              result.push(argBeingBuilt);
              argBeingBuilt = "";
            }
            mode = "DEFAULT";
          }
          break;
        }
      case `' during IN_SINGLE_STRING`:
        {
          if (prevChar === "\\") {
            argBeingBuilt += `'`;
          } else {
            // in order to support string gluing
            if (nextChar !== `'` && nextChar !== `"`) {
              result.push(argBeingBuilt);
              argBeingBuilt = "";
            }
            mode = "DEFAULT";
          }
          break;
        }
      case `\\ during IN_DOUBLE_STRING`:
      case `\\ during IN_SINGLE_STRING`:
        {
          const escapedChars = {
            n: "\n",
            r: "\r",
            t: "\t",
            v: "\v",
            "0": String.fromCharCode(0),
            "\\": "\\"
          };
          if (escapedChars[nextChar]) {
            argBeingBuilt += escapedChars[nextChar];
            i++; // skip next char
          } else {
            // They used backslash to escape something but it wasn't an escape sequence.
            // Ignore this `\` and let the escaped char get picked up via normal means.
          }
          break;
        }
      default:
        {
          argBeingBuilt += char;
        }
    }
  }
  if (mode === "DEFAULT" && argBeingBuilt.length > 0) {
    result.push(argBeingBuilt);
  } else if (mode === "IN_DOUBLE_STRING") {
    throw new Error(`Invalid command string: unterminated double-quote: ${args}`);
  } else if (mode === "IN_SINGLE_STRING") {
    throw new Error(`Invalid command string: unterminated single-quote: ${args}`);
  }
  return result;
}
}),
/* --- node_modules/minimatch/lib/path.js --- */
"node_modules/minimatch/lib/path.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

const isWindows = typeof process === 'object' && process && process.platform === 'win32';
module.exports = isWindows ? {
  sep: '\\'
} : {
  sep: '/'
};
}),
/* --- node_modules/brace-expansion/index.js --- */
"node_modules/brace-expansion/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

var balanced = _kame_require_("node_modules/balanced-match/index.js");
module.exports = expandTop;
var escSlash = '\0SLASH' + Math.random() + '\0';
var escOpen = '\0OPEN' + Math.random() + '\0';
var escClose = '\0CLOSE' + Math.random() + '\0';
var escComma = '\0COMMA' + Math.random() + '\0';
var escPeriod = '\0PERIOD' + Math.random() + '\0';
function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
}
function unescapeBraces(str) {
  return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
}

// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str) return [''];
  var parts = [];
  var m = balanced('{', '}', str);
  if (!m) return str.split(',');
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');
  p[p.length - 1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop(str) {
  if (!str) return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }
  return expand(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand(str, isTop) {
  var expansions = [];
  var m = balanced('{', '}', str);
  if (!m) return [str];

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length ? expand(m.post, false) : [''];
  if (/\$$/.test(m.pre)) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + '{' + m.body + '}' + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,.*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map(function (p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }

    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\') c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];
      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand(n[j], false));
      }
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion) expansions.push(expansion);
      }
    }
  }
  return expansions;
}
}),
/* --- external:stream --- */
"external:stream": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
if (typeof require === "function") {
	module.exports = require("stream");
} else if (typeof stream !== "undefined") {
	module.exports = stream;
} else if (typeof Stream !== "undefined") {
	module.exports = Stream;
} else {
	if ("production" !== "production") {
		console.warn("Failed to load external " + "stream" + ". An empty module will be used instead, but this might cause problems in your code. Consider using a custom resolver to shim this external.");
	}
	module.exports = {};
}
}),
/* --- node_modules/yaml/dist/compose/composer.js --- */
"node_modules/yaml/dist/compose/composer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var directives = _kame_require_("node_modules/yaml/dist/doc/directives.js");
var Document = _kame_require_("node_modules/yaml/dist/doc/Document.js");
var errors = _kame_require_("node_modules/yaml/dist/errors.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var composeDoc = _kame_require_("node_modules/yaml/dist/compose/compose-doc.js");
var resolveEnd = _kame_require_("node_modules/yaml/dist/compose/resolve-end.js");
function getErrorPos(src) {
  if (typeof src === 'number') return [src, src + 1];
  if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];
  const {
    offset,
    source
  } = src;
  return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _prelude;
  let comment = '';
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case '#':
        comment += (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') + (source.substring(1) || ' ');
        atComment = true;
        afterEmptyLine = false;
        break;
      case '%':
        if (((_prelude = prelude[i + 1]) === null || _prelude === void 0 ? void 0 : _prelude[0]) !== '#') i += 1;
        atComment = false;
        break;
      default:
        // This may be wrong after doc-end, but in that case it doesn't matter
        if (!atComment) afterEmptyLine = true;
        atComment = false;
    }
  }
  return {
    comment,
    afterEmptyLine
  };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning) this.warnings.push(new errors.YAMLWarning(pos, code, message));else this.errors.push(new errors.YAMLParseError(pos, code, message));
    };
    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
    this.directives = new directives.Directives({
      version: options.version || '1.2'
    });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const {
      comment,
      afterEmptyLine
    } = parsePrelude(this.prelude);
    //console.log({ dc: doc.comment, prelude, comment })
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (Node.isPair(it)) it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}\n${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens) yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    if (process.env.LOG_STREAM) console.dir(token, {
      depth: null
    });
    switch (token.type) {
      case 'directive':
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, 'BAD_DIRECTIVE', message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case 'document':
        {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart) this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
          this.decorate(doc, false);
          if (this.doc) yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
      case 'byte-order-mark':
      case 'space':
        break;
      case 'comment':
      case 'newline':
        this.prelude.push(token.source);
        break;
      case 'error':
        {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
          if (this.atDirectives || !this.doc) this.errors.push(error);else this.doc.errors.push(error);
          break;
        }
      case 'doc-end':
        {
          if (!this.doc) {
            const msg = 'Unexpected doc-end without preceding document';
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
      default:
        this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({
        _directives: this.directives
      }, this.options);
      const doc = new Document.Document(undefined, opts);
      if (this.atDirectives) this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
}
exports.Composer = Composer;
}),
/* --- node_modules/yaml/dist/doc/Document.js --- */
"node_modules/yaml/dist/doc/Document.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Alias = _kame_require_("node_modules/yaml/dist/nodes/Alias.js");
var Collection = _kame_require_("node_modules/yaml/dist/nodes/Collection.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Pair = _kame_require_("node_modules/yaml/dist/nodes/Pair.js");
var toJS = _kame_require_("node_modules/yaml/dist/nodes/toJS.js");
var Schema = _kame_require_("node_modules/yaml/dist/schema/Schema.js");
var stringify = _kame_require_("node_modules/yaml/dist/stringify/stringify.js");
var stringifyDocument = _kame_require_("node_modules/yaml/dist/stringify/stringifyDocument.js");
var anchors = _kame_require_("node_modules/yaml/dist/doc/anchors.js");
var applyReviver = _kame_require_("node_modules/yaml/dist/doc/applyReviver.js");
var createNode = _kame_require_("node_modules/yaml/dist/doc/createNode.js");
var directives = _kame_require_("node_modules/yaml/dist/doc/directives.js");
class Document {
  constructor(value, replacer, options) {
    var _options;
    /** A comment before this Document */
    this.commentBefore = null;
    /** A comment immediately after this Document */
    this.comment = null;
    /** Errors encountered during parsing. */
    this.errors = [];
    /** Warnings encountered during parsing. */
    this.warnings = [];
    Object.defineProperty(this, Node.NODE_TYPE, {
      value: Node.DOC
    });
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
      replacer = undefined;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: 'warn',
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: '1.2'
    }, options);
    this.options = opt;
    let {
      version
    } = opt;
    if ((_options = options) !== null && _options !== void 0 && _options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit) version = this.directives.yaml.version;
    } else this.directives = new directives.Directives({
      version
    });
    this.setSchema(version, options);
    if (value === undefined) this.contents = null;else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document.prototype, {
      [Node.NODE_TYPE]: {
        value: Node.DOC
      }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives) copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = Node.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range) copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents)) this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents)) this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchors.anchorNames(this);
      node.anchor =
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
    }
    return new Alias.Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = undefined;
    if (typeof replacer === 'function') {
      value = replacer.call({
        '': value
      }, '', value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = v => typeof v === 'number' || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0) replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
      replacer = undefined;
    }
    const {
      aliasDuplicateObjects,
      anchorPrefix,
      flow,
      keepUndefined,
      onTagObj,
      tag
    } = options ?? {};
    const {
      onAnchor,
      setAnchors,
      sourceObjects
    } = anchors.createNodeAnchors(this,
    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
    anchorPrefix || 'a');
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode.createNode(value, tag, ctx);
    if (flow && Node.isCollection(node)) node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair.Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (Collection.isEmptyPath(path)) {
      if (this.contents == null) return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return Node.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (Collection.isEmptyPath(path)) return !keepScalar && Node.isScalar(this.contents) ? this.contents.value : this.contents;
    return Node.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return Node.isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (Collection.isEmptyPath(path)) return this.contents !== undefined;
    return Node.isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = Collection.collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (Collection.isEmptyPath(path)) this.contents = value;else if (this.contents == null) {
      this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === 'number') version = String(version);
    let opt;
    switch (version) {
      case '1.1':
        if (this.directives) this.directives.yaml.version = '1.1';else this.directives = new directives.Directives({
          version: '1.1'
        });
        opt = {
          merge: true,
          resolveKnownTags: false,
          schema: 'yaml-1.1'
        };
        break;
      case '1.2':
      case 'next':
        if (this.directives) this.directives.yaml.version = version;else this.directives = new directives.Directives({
          version
        });
        opt = {
          merge: false,
          resolveKnownTags: true,
          schema: 'core'
        };
        break;
      case null:
        if (this.directives) delete this.directives;
        opt = null;
        break;
      default:
        {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
    }
    // Not using `instanceof Schema` to allow for duck typing
    if (options.schema instanceof Object) this.schema = options.schema;else if (opt) this.schema = new Schema.Schema(Object.assign(opt, options));else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({
    json,
    jsonArg,
    mapAsMap,
    maxAliasCount,
    onAnchor,
    reviver
  } = {}) {
    const ctx = {
      anchors: new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,
      stringify: stringify.stringify
    };
    const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);
    if (typeof onAnchor === 'function') for (const {
      count,
      res
    } of ctx.anchors.values()) onAnchor(res, count);
    return typeof reviver === 'function' ? applyReviver.applyReviver(reviver, {
      '': res
    }, '', res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({
      json: true,
      jsonArg,
      mapAsMap: false,
      onAnchor
    });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
    if ('indent' in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument.stringifyDocument(this, options);
  }
}
function assertCollection(contents) {
  if (Node.isCollection(contents)) return true;
  throw new Error('Expected a YAML collection as document contents');
}
exports.Document = Document;
}),
/* --- node_modules/yaml/dist/schema/Schema.js --- */
"node_modules/yaml/dist/schema/Schema.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var map = _kame_require_("node_modules/yaml/dist/schema/common/map.js");
var seq = _kame_require_("node_modules/yaml/dist/schema/common/seq.js");
var string = _kame_require_("node_modules/yaml/dist/schema/common/string.js");
var tags = _kame_require_("node_modules/yaml/dist/schema/tags.js");
const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
  constructor({
    compat,
    customTags,
    merge,
    resolveKnownTags,
    schema,
    sortMapEntries,
    toStringDefaults
  }) {
    this.compat = Array.isArray(compat) ? tags.getTags(compat, 'compat') : compat ? tags.getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema === 'string' && schema || 'core';
    this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
    this.tags = tags.getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, Node.MAP, {
      value: map.map
    });
    Object.defineProperty(this, Node.SCALAR, {
      value: string.string
    });
    Object.defineProperty(this, Node.SEQ, {
      value: seq.seq
    });
    // Used by createMap()
    this.sortMapEntries = typeof sortMapEntries === 'function' ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
}
exports.Schema = Schema;
}),
/* --- node_modules/yaml/dist/errors.js --- */
"node_modules/yaml/dist/errors.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

class YAMLError extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
}
class YAMLParseError extends YAMLError {
  constructor(pos, code, message) {
    super('YAMLParseError', pos, code, message);
  }
}
class YAMLWarning extends YAMLError {
  constructor(pos, code, message) {
    super('YAMLWarning', pos, code, message);
  }
}
const prettifyError = (src, lc) => error => {
  if (error.pos[0] === -1) return;
  error.linePos = error.pos.map(pos => lc.linePos(pos));
  const {
    line,
    col
  } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, '');
  // Trim to max 80 chars, keeping col position near the middle
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = '' + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + '';
  // Include previous line in context if pointing at line start
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    // Regexp won't match if start is trimmed
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80) prev = prev.substring(0, 79) + '\n';
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = ' '.repeat(ci) + '^'.repeat(count);
    error.message += `:\n\n${lineStr}\n${pointer}\n`;
  }
};
exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;
}),
/* --- node_modules/yaml/dist/nodes/Alias.js --- */
"node_modules/yaml/dist/nodes/Alias.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var anchors = _kame_require_("node_modules/yaml/dist/doc/anchors.js");
var visit = _kame_require_("node_modules/yaml/dist/visit.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
class Alias extends Node.NodeBase {
  constructor(source) {
    super(Node.ALIAS);
    this.source = source;
    Object.defineProperty(this, 'tag', {
      set() {
        throw new Error('Alias nodes cannot have tags');
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = undefined;
    visit.visit(doc, {
      Node: (_key, node) => {
        if (node === this) return visit.visit.BREAK;
        if (node.anchor === this.source) found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx) return {
      source: this.source
    };
    const {
      anchors,
      doc,
      maxAliasCount
    } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data = anchors.get(source);
    /* istanbul ignore if */
    if (!data || data.res === undefined) {
      const msg = 'This should not happen: Alias anchor was not resolved?';
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = 'Excessive alias count indicates a resource exhaustion attack';
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchors.anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey) return `${src} `;
    }
    return src;
  }
}
function getAliasCount(doc, node, anchors) {
  if (Node.isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (Node.isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count) count = c;
    }
    return count;
  } else if (Node.isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
exports.Alias = Alias;
}),
/* --- node_modules/yaml/dist/nodes/Node.js --- */
"node_modules/yaml/dist/nodes/Node.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = node => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = node => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = node => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = node => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = node => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
const isSeq = node => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === 'object') switch (node[NODE_TYPE]) {
    case MAP:
    case SEQ:
      return true;
  }
  return false;
}
function isNode(node) {
  if (node && typeof node === 'object') switch (node[NODE_TYPE]) {
    case ALIAS:
    case MAP:
    case SCALAR:
    case SEQ:
      return true;
  }
  return false;
}
const hasAnchor = node => (isScalar(node) || isCollection(node)) && !!node.anchor;
class NodeBase {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, {
      value: type
    });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range) copy.range = this.range.slice();
    return copy;
  }
}
exports.ALIAS = ALIAS;
exports.DOC = DOC;
exports.MAP = MAP;
exports.NODE_TYPE = NODE_TYPE;
exports.NodeBase = NodeBase;
exports.PAIR = PAIR;
exports.SCALAR = SCALAR;
exports.SEQ = SEQ;
exports.hasAnchor = hasAnchor;
exports.isAlias = isAlias;
exports.isCollection = isCollection;
exports.isDocument = isDocument;
exports.isMap = isMap;
exports.isNode = isNode;
exports.isPair = isPair;
exports.isScalar = isScalar;
exports.isSeq = isSeq;
}),
/* --- node_modules/yaml/dist/nodes/Pair.js --- */
"node_modules/yaml/dist/nodes/Pair.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var createNode = _kame_require_("node_modules/yaml/dist/doc/createNode.js");
var stringifyPair = _kame_require_("node_modules/yaml/dist/stringify/stringifyPair.js");
var addPairToJSMap = _kame_require_("node_modules/yaml/dist/nodes/addPairToJSMap.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
function createPair(key, value, ctx) {
  const k = createNode.createNode(key, undefined, ctx);
  const v = createNode.createNode(value, undefined, ctx);
  return new Pair(k, v);
}
class Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, Node.NODE_TYPE, {
      value: Node.PAIR
    });
    this.key = key;
    this.value = value;
  }
  clone(schema) {
    let {
      key,
      value
    } = this;
    if (Node.isNode(key)) key = key.clone(schema);
    if (Node.isNode(value)) value = value.clone(schema);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx !== null && ctx !== void 0 && ctx.mapAsMap ? new Map() : {};
    return addPairToJSMap.addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx !== null && ctx !== void 0 && ctx.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
}
exports.Pair = Pair;
exports.createPair = createPair;
}),
/* --- node_modules/yaml/dist/nodes/Scalar.js --- */
"node_modules/yaml/dist/nodes/Scalar.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var toJS = _kame_require_("node_modules/yaml/dist/nodes/toJS.js");
const isScalarValue = value => !value || typeof value !== 'function' && typeof value !== 'object';
class Scalar extends Node.NodeBase {
  constructor(value) {
    super(Node.SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx !== null && ctx !== void 0 && ctx.keep ? this.value : toJS.toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';
exports.Scalar = Scalar;
exports.isScalarValue = isScalarValue;
}),
/* --- node_modules/yaml/dist/nodes/YAMLMap.js --- */
"node_modules/yaml/dist/nodes/YAMLMap.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var stringifyCollection = _kame_require_("node_modules/yaml/dist/stringify/stringifyCollection.js");
var addPairToJSMap = _kame_require_("node_modules/yaml/dist/nodes/addPairToJSMap.js");
var Collection = _kame_require_("node_modules/yaml/dist/nodes/Collection.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Pair = _kame_require_("node_modules/yaml/dist/nodes/Pair.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
function findPair(items, key) {
  const k = Node.isScalar(key) ? key.value : key;
  for (const it of items) {
    if (Node.isPair(it)) {
      if (it.key === key || it.key === k) return it;
      if (Node.isScalar(it.key) && it.key.value === k) return it;
    }
  }
  return undefined;
}
class YAMLMap extends Collection.Collection {
  constructor(schema) {
    super(Node.MAP, schema);
    this.items = [];
  }
  static get tagName() {
    return 'tag:yaml.org,2002:map';
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    var _this$schema;
    let _pair;
    if (Node.isPair(pair)) _pair = pair;else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
      // In TypeScript, this never happens.
      _pair = new Pair.Pair(pair, pair === null || pair === void 0 ? void 0 : pair.value);
    } else _pair = new Pair.Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_this$schema = this.schema) === null || _this$schema === void 0 ? void 0 : _this$schema.sortMapEntries;
    if (prev) {
      if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
      // For scalars, keep the old node & its comments and anchors
      if (Node.isScalar(prev.value) && Scalar.isScalarValue(_pair.value)) prev.value.value = _pair.value;else prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
      if (i === -1) this.items.push(_pair);else this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it) return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it === null || it === void 0 ? void 0 : it.value;
    return (!keepScalar && Node.isScalar(node) ? node.value : node) ?? undefined;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair.Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map = Type ? new Type() : ctx !== null && ctx !== void 0 && ctx.mapAsMap ? new Map() : {};
    if (ctx !== null && ctx !== void 0 && ctx.onCreate) ctx.onCreate(map);
    for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map, item);
    return map;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    for (const item of this.items) {
      if (!Node.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, {
      allNullValues: true
    });
    return stringifyCollection.stringifyCollection(this, ctx, {
      blockItemPrefix: '',
      flowChars: {
        start: '{',
        end: '}'
      },
      itemIndent: ctx.indent || '',
      onChompKeep,
      onComment
    });
  }
}
exports.YAMLMap = YAMLMap;
exports.findPair = findPair;
}),
/* --- node_modules/yaml/dist/nodes/YAMLSeq.js --- */
"node_modules/yaml/dist/nodes/YAMLSeq.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var stringifyCollection = _kame_require_("node_modules/yaml/dist/stringify/stringifyCollection.js");
var Collection = _kame_require_("node_modules/yaml/dist/nodes/Collection.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var toJS = _kame_require_("node_modules/yaml/dist/nodes/toJS.js");
class YAMLSeq extends Collection.Collection {
  constructor(schema) {
    super(Node.SEQ, schema);
    this.items = [];
  }
  static get tagName() {
    return 'tag:yaml.org,2002:seq';
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return undefined;
    const it = this.items[idx];
    return !keepScalar && Node.isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === 'number' && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (Node.isScalar(prev) && Scalar.isScalarValue(value)) prev.value = value;else this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq = [];
    if (ctx !== null && ctx !== void 0 && ctx.onCreate) ctx.onCreate(seq);
    let i = 0;
    for (const item of this.items) seq.push(toJS.toJS(item, String(i++), ctx));
    return seq;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    return stringifyCollection.stringifyCollection(this, ctx, {
      blockItemPrefix: '- ',
      flowChars: {
        start: '[',
        end: ']'
      },
      itemIndent: (ctx.indent || '') + '  ',
      onChompKeep,
      onComment
    });
  }
}
function asItemIndex(key) {
  let idx = Node.isScalar(key) ? key.value : key;
  if (idx && typeof idx === 'string') idx = Number(idx);
  return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
exports.YAMLSeq = YAMLSeq;
}),
/* --- node_modules/yaml/dist/parse/cst.js --- */
"node_modules/yaml/dist/parse/cst.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var cstScalar = _kame_require_("node_modules/yaml/dist/parse/cst-scalar.js");
var cstStringify = _kame_require_("node_modules/yaml/dist/parse/cst-stringify.js");
var cstVisit = _kame_require_("node_modules/yaml/dist/parse/cst-visit.js");

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = token => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = token => !!token && (token.type === 'scalar' || token.type === 'single-quoted-scalar' || token.type === 'double-quoted-scalar' || token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
  switch (token) {
    case BOM:
      return '<BOM>';
    case DOCUMENT:
      return '<DOC>';
    case FLOW_END:
      return '<FLOW_END>';
    case SCALAR:
      return '<SCALAR>';
    default:
      return JSON.stringify(token);
  }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
  switch (source) {
    case BOM:
      return 'byte-order-mark';
    case DOCUMENT:
      return 'doc-mode';
    case FLOW_END:
      return 'flow-error-end';
    case SCALAR:
      return 'scalar';
    case '---':
      return 'doc-start';
    case '...':
      return 'doc-end';
    case '':
    case '\n':
    case '\r\n':
      return 'newline';
    case '-':
      return 'seq-item-ind';
    case '?':
      return 'explicit-key-ind';
    case ':':
      return 'map-value-ind';
    case '{':
      return 'flow-map-start';
    case '}':
      return 'flow-map-end';
    case '[':
      return 'flow-seq-start';
    case ']':
      return 'flow-seq-end';
    case ',':
      return 'comma';
  }
  switch (source[0]) {
    case ' ':
    case '\t':
      return 'space';
    case '#':
      return 'comment';
    case '%':
      return 'directive-line';
    case '*':
      return 'alias';
    case '&':
      return 'anchor';
    case '!':
      return 'tag';
    case "'":
      return 'single-quoted-scalar';
    case '"':
      return 'double-quoted-scalar';
    case '|':
    case '>':
      return 'block-scalar-header';
  }
  return null;
}
exports.createScalarToken = cstScalar.createScalarToken;
exports.resolveAsScalar = cstScalar.resolveAsScalar;
exports.setScalarValue = cstScalar.setScalarValue;
exports.stringify = cstStringify.stringify;
exports.visit = cstVisit.visit;
exports.BOM = BOM;
exports.DOCUMENT = DOCUMENT;
exports.FLOW_END = FLOW_END;
exports.SCALAR = SCALAR;
exports.isCollection = isCollection;
exports.isScalar = isScalar;
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;
}),
/* --- node_modules/yaml/dist/parse/lexer.js --- */
"node_modules/yaml/dist/parse/lexer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var cst = _kame_require_("node_modules/yaml/dist/parse/cst.js");

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
  switch (ch) {
    case undefined:
    case ' ':
    case '\n':
    case '\r':
    case '\t':
      return true;
    default:
      return false;
  }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = ch => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
  constructor() {
    /**
     * Flag indicating whether the end of the current buffer marks the end of
     * all input
     */
    this.atEnd = false;
    /**
     * Explicit indent set in block scalar header, as an offset from the current
     * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
     * explicitly set.
     */
    this.blockScalarIndent = -1;
    /**
     * Block scalars that include a + (keep) chomping indicator in their header
     * include trailing empty lines, which are otherwise excluded from the
     * scalar's contents.
     */
    this.blockScalarKeep = false;
    /** Current input */
    this.buffer = '';
    /**
     * Flag noting whether the map value indicator : can immediately follow this
     * node within a flow context.
     */
    this.flowKey = false;
    /** Count of surrounding flow collection levels. */
    this.flowLevel = 0;
    /**
     * Minimum level of indentation required for next lines to be parsed as a
     * part of the current scalar value.
     */
    this.indentNext = 0;
    /** Indentation level of the current line. */
    this.indentValue = 0;
    /** Position of the next \n character. */
    this.lineEndPos = null;
    /** Stores the state of the lexer if reaching the end of incpomplete input */
    this.next = null;
    /** A pointer to `buffer`; the current position of the lexer. */
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next ?? 'stream';
    while (next && (incomplete || this.hasChars(1))) next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === ' ' || ch === '\t') ch = this.buffer[++i];
    if (!ch || ch === '#' || ch === '\n') return true;
    if (ch === '\r') return this.buffer[i + 1] === '\n';
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === ' ') ch = this.buffer[++indent + offset];
      if (ch === '\r') {
        const next = this.buffer[indent + offset + 1];
        if (next === '\n' || !next && !this.atEnd) return offset + indent + 1;
      }
      return ch === '\n' || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === '-' || ch === '.') {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3])) return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== 'number' || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf('\n', this.pos);
      this.lineEndPos = end;
    }
    if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === '\r') end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case 'stream':
        return yield* this.parseStream();
      case 'line-start':
        return yield* this.parseLineStart();
      case 'block-start':
        return yield* this.parseBlockStart();
      case 'doc':
        return yield* this.parseDocument();
      case 'flow':
        return yield* this.parseFlowCollection();
      case 'quoted-scalar':
        return yield* this.parseQuotedScalar();
      case 'block-scalar':
        return yield* this.parseBlockScalar();
      case 'plain-scalar':
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null) return this.setNext('stream');
    if (line[0] === cst.BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === '%') {
      let dirEnd = line.length;
      const cs = line.indexOf('#');
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === ' ' || ch === '\t') dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === ' ' || ch === '\t') dirEnd -= 1;else break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n); // possible comment
      this.pushNewline();
      return 'stream';
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return 'stream';
    }
    yield cst.DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd) return this.setNext('line-start');
    if (ch === '-' || ch === '.') {
      if (!this.atEnd && !this.hasChars(4)) return this.setNext('line-start');
      const s = this.peek(3);
      if (s === '---' && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return 'doc';
      } else if (s === '...' && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return 'stream';
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd) return this.setNext('block-start');
    if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return 'doc';
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null) return this.setNext('doc');
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case '#':
        yield* this.pushCount(line.length - n);
      // fallthrough
      case undefined:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case '{':
      case '[':
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return 'flow';
      case '}':
      case ']':
        // this is an error
        yield* this.pushCount(1);
        return 'doc';
      case '*':
        yield* this.pushUntil(isNotAnchorChar);
        return 'doc';
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case '|':
      case '>':
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null) return this.setNext('flow');
    if (indent !== -1 && indent < this.indentNext && line[0] !== '#' || indent === 0 && (line.startsWith('---') || line.startsWith('...')) && isEmpty(line[3])) {
      // Allowing for the terminal ] or } at the same (rather than greater)
      // indent level as the initial [ or { is technically invalid, but
      // failing here would be surprising to users.
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === ']' || line[0] === '}');
      if (!atFlowEndMarker) {
        // this is an error
        this.flowLevel = 0;
        yield cst.FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ',') {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case undefined:
        return 'flow';
      case '#':
        yield* this.pushCount(line.length - n);
        return 'flow';
      case '{':
      case '[':
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return 'flow';
      case '}':
      case ']':
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? 'flow' : 'doc';
      case '*':
        yield* this.pushUntil(isNotAnchorChar);
        return 'flow';
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ':':
        {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ',') {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return 'flow';
          }
        }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'") end = this.buffer.indexOf("'", end + 2);
    } else {
      // double-quote
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === '\\') n += 1;
        if (n % 2 === 0) break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    // Only looking for newlines within the quotes
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf('\n', this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1) break;
        nl = qb.indexOf('\n', cs);
      }
      if (nl !== -1) {
        // this is an error caused by an unexpected unindent
        end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd) return this.setNext('quoted-scalar');
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? 'flow' : 'doc';
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === '+') this.blockScalarKeep = true;else if (ch > '0' && ch <= '9') this.blockScalarIndent = Number(ch) - 1;else if (ch !== '-') break;
    }
    return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
  }
  *parseBlockScalar() {
    let nl = this.pos - 1; // may be -1 if this.pos === 0
    let indent = 0;
    let ch;
    loop: for (let i = this.pos; ch = this.buffer[i]; ++i) {
      switch (ch) {
        case ' ':
          indent += 1;
          break;
        case '\n':
          nl = i;
          indent = 0;
          break;
        case '\r':
          {
            const next = this.buffer[i + 1];
            if (!next && !this.atEnd) return this.setNext('block-scalar');
            if (next === '\n') break;
          }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd) return this.setNext('block-scalar');
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1) this.indentNext = indent;else this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1) break;
        nl = this.buffer.indexOf('\n', cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd) return this.setNext('block-scalar');
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i = nl - 1;
        let ch = this.buffer[i];
        if (ch === '\r') ch = this.buffer[--i];
        const lastChar = i; // Drop the line if last char not more indented
        while (ch === ' ' || ch === '\t') ch = this.buffer[--i];
        if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar) nl = i;else break;
      } while (true);
    }
    yield cst.SCALAR;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ':') {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && next === ',') break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === '\r') {
          if (next === '\n') {
            i += 1;
            ch = '\n';
            next = this.buffer[i + 1];
          } else end = i;
        }
        if (next === '#' || inFlow && invalidFlowScalarChars.includes(next)) break;
        if (ch === '\n') {
          const cs = this.continueScalar(i + 1);
          if (cs === -1) break;
          i = Math.max(i, cs - 2); // to advance, but still account for ' #'
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch)) break;
        end = i;
      }
    }
    if (!ch && !this.atEnd) return this.setNext('plain-scalar');
    yield cst.SCALAR;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? 'flow' : 'doc';
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty) yield '';
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case '!':
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case '&':
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case '-': // this is an error
      case '?': // this is an error outside flow collections
      case ':':
        {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
            if (!inFlow) this.indentNext = this.indentValue + 1;else if (this.flowKey) this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === '<') {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== '>') ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.includes(ch)) ch = this.buffer[++i];else if (ch === '%' && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === '\n') return yield* this.pushCount(1);else if (ch === '\r' && this.charAt(1) === '\n') return yield* this.pushCount(2);else return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === ' ' || allowTabs && ch === '\t');
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch)) ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
}
exports.Lexer = Lexer;
}),
/* --- node_modules/yaml/dist/parse/line-counter.js --- */
"node_modules/yaml/dist/parse/line-counter.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
  constructor() {
    this.lineStarts = [];
    /**
     * Should be called in ascending order. Otherwise, call
     * `lineCounter.lineStarts.sort()` before calling `linePos()`.
     */
    this.addNewLine = offset => this.lineStarts.push(offset);
    /**
     * Performs a binary search and returns the 1-indexed { line, col }
     * position of `offset`. If `line === 0`, `addNewLine` has never been
     * called or `offset` is before the first known newline.
     */
    this.linePos = offset => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1; // Math.floor((low + high) / 2)
        if (this.lineStarts[mid] < offset) low = mid + 1;else high = mid;
      }
      if (this.lineStarts[low] === offset) return {
        line: low + 1,
        col: 1
      };
      if (low === 0) return {
        line: 0,
        col: offset
      };
      const start = this.lineStarts[low - 1];
      return {
        line: low,
        col: offset - start + 1
      };
    };
  }
}
exports.LineCounter = LineCounter;
}),
/* --- node_modules/yaml/dist/parse/parser.js --- */
"node_modules/yaml/dist/parse/parser.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var cst = _kame_require_("node_modules/yaml/dist/parse/cst.js");
var lexer = _kame_require_("node_modules/yaml/dist/parse/lexer.js");
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i) if (list[i].type === type) return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case 'space':
      case 'comment':
      case 'newline':
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token === null || token === void 0 ? void 0 : token.type) {
    case 'alias':
    case 'scalar':
    case 'single-quoted-scalar':
    case 'double-quoted-scalar':
    case 'flow-collection':
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case 'document':
      return parent.start;
    case 'block-map':
      {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
    case 'block-seq':
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
  if (prev.length === 0) return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case 'doc-start':
      case 'explicit-key-ind':
      case 'map-value-ind':
      case 'seq-item-ind':
      case 'newline':
        break loop;
    }
  }
  while (((_prev$i = prev[++i]) === null || _prev$i === void 0 ? void 0 : _prev$i.type) === 'space') {
    var _prev$i;
  } /* loop */

  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === 'flow-seq-start') {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, 'explicit-key-ind') && !includesToken(it.sep, 'map-value-ind')) {
        if (it.key) it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);else it.value.end = it.sep;
        } else Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    /** If true, space and sequence indicators count as indentation */
    this.atNewLine = true;
    /** If true, next token is a scalar value */
    this.atScalar = false;
    /** Current indentation level */
    this.indent = 0;
    /** Current offset since the start of parsing */
    this.offset = 0;
    /** On the same line with a block map key */
    this.onKeyLine = false;
    /** Top indicates the node that's currently being built */
    this.stack = [];
    /** The source of the current token, set in parse() */
    this.source = '';
    /** The type of the current token, set in parse() */
    this.type = '';
    // Must be defined after `next()`
    this.lexer = new lexer.Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0) this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
    if (!incomplete) yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (process.env.LOG_TOKENS) console.log('|', cst.prettyToken(source));
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = cst.tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({
        type: 'error',
        offset: this.offset,
        message,
        source
      });
      this.offset += source.length;
    } else if (type === 'scalar') {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = 'scalar';
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case 'newline':
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) this.onNewLine(this.offset + source.length);
          break;
        case 'space':
          if (this.atNewLine && source[0] === ' ') this.indent += source.length;
          break;
        case 'explicit-key-ind':
        case 'map-value-ind':
        case 'seq-item-ind':
          if (this.atNewLine) this.indent += source.length;
          break;
        case 'doc-mode':
        case 'flow-error-end':
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0) yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
      while (this.stack.length > 0) yield* this.pop();
      this.stack.push({
        type: 'doc-end',
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top) return yield* this.stream();
    switch (top.type) {
      case 'document':
        return yield* this.document(top);
      case 'alias':
      case 'scalar':
      case 'single-quoted-scalar':
      case 'double-quoted-scalar':
        return yield* this.scalar(top);
      case 'block-scalar':
        return yield* this.blockScalar(top);
      case 'block-map':
        return yield* this.blockMap(top);
      case 'block-seq':
        return yield* this.blockSequence(top);
      case 'flow-collection':
        return yield* this.flowCollection(top);
      case 'doc-end':
        return yield* this.documentEnd(top);
    }
    /* istanbul ignore next should not happen */
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error ?? this.stack.pop();
    /* istanbul ignore if should not happen */
    if (!token) {
      const message = 'Tried to pop an empty stack';
      yield {
        type: 'error',
        offset: this.offset,
        source: '',
        message
      };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === 'block-scalar') {
        // Block scalars use their parent rather than header indent
        token.indent = 'indent' in top ? top.indent : 0;
      } else if (token.type === 'flow-collection' && top.type === 'document') {
        // Ignore all indent for top-level flow collections
        token.indent = 0;
      }
      if (token.type === 'flow-collection') fixFlowSeqItems(token);
      switch (top.type) {
        case 'document':
          top.value = token;
          break;
        case 'block-scalar':
          top.props.push(token); // error
          break;
        case 'block-map':
          {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({
                start: [],
                key: token,
                sep: []
              });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, {
                key: token,
                sep: []
              });
              this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
              return;
            }
            break;
          }
        case 'block-seq':
          {
            const it = top.items[top.items.length - 1];
            if (it.value) top.items.push({
              start: [],
              value: token
            });else it.value = token;
            break;
          }
        case 'flow-collection':
          {
            const it = top.items[top.items.length - 1];
            if (!it || it.value) top.items.push({
              start: [],
              key: token,
              sep: []
            });else if (it.sep) it.value = token;else Object.assign(it, {
              key: token,
              sep: []
            });
            return;
          }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === 'document' || top.type === 'block-map' || top.type === 'block-seq') && (token.type === 'block-map' || token.type === 'block-seq')) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
          if (top.type === 'document') top.end = last.start;else top.items.push({
            start: last.start
          });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case 'directive-line':
        yield {
          type: 'directive',
          offset: this.offset,
          source: this.source
        };
        return;
      case 'byte-order-mark':
      case 'space':
      case 'comment':
      case 'newline':
        yield this.sourceToken;
        return;
      case 'doc-mode':
      case 'doc-start':
        {
          const doc = {
            type: 'document',
            offset: this.offset,
            start: []
          };
          if (this.type === 'doc-start') doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
    }
    yield {
      type: 'error',
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value) return yield* this.lineEnd(doc);
    switch (this.type) {
      case 'doc-start':
        {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else doc.start.push(this.sourceToken);
          return;
        }
      case 'anchor':
      case 'tag':
      case 'space':
      case 'comment':
      case 'newline':
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv) this.stack.push(bv);else {
      yield {
        type: 'error',
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === 'map-value-ind') {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else sep = [this.sourceToken];
      const map = {
        type: 'block-map',
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{
          start,
          key: scalar,
          sep
        }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map;
    } else yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case 'space':
      case 'comment':
      case 'newline':
        scalar.props.push(this.sourceToken);
        return;
      case 'scalar':
        scalar.source = this.source;
        // block-scalar source includes trailing newline
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf('\n') + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf('\n', nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map) {
    const it = map.items[map.items.length - 1];
    // it.sep is true-ish if pair already has key or : separator
    switch (this.type) {
      case 'newline':
        this.onKeyLine = false;
        if (it.value) {
          const end = 'end' in it.value ? it.value.end : undefined;
          const last = Array.isArray(end) ? end[end.length - 1] : undefined;
          if ((last === null || last === void 0 ? void 0 : last.type) === 'comment') end === null || end === void 0 ? void 0 : end.push(this.sourceToken);else map.items.push({
            start: [this.sourceToken]
          });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case 'space':
      case 'comment':
        if (it.value) {
          map.items.push({
            start: [this.sourceToken]
          });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map.indent)) {
            var _prev$value;
            const prev = map.items[map.items.length - 2];
            const end = prev === null || prev === void 0 ? void 0 : (_prev$value = prev.value) === null || _prev$value === void 0 ? void 0 : _prev$value.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
      // For empty nodes, assign newline-separated not indented empty tokens to following node
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case 'newline':
              nl.push(i);
              break;
            case 'space':
              break;
            case 'comment':
              if (st.indent > map.indent) nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2) start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case 'anchor':
        case 'tag':
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map.items.push({
              start
            });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case 'explicit-key-ind':
          if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
            it.start.push(this.sourceToken);
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map.items.push({
              start
            });
          } else {
            this.stack.push({
              type: 'block-map',
              offset: this.offset,
              indent: this.indent,
              items: [{
                start: [this.sourceToken]
              }]
            });
          }
          this.onKeyLine = true;
          return;
        case 'map-value-ind':
          if (includesToken(it.start, 'explicit-key-ind')) {
            if (!it.sep) {
              if (includesToken(it.start, 'newline')) {
                Object.assign(it, {
                  key: null,
                  sep: [this.sourceToken]
                });
              } else {
                const start = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: 'block-map',
                  offset: this.offset,
                  indent: this.indent,
                  items: [{
                    start,
                    key: null,
                    sep: [this.sourceToken]
                  }]
                });
              }
            } else if (it.value) {
              map.items.push({
                start: [],
                key: null,
                sep: [this.sourceToken]
              });
            } else if (includesToken(it.sep, 'map-value-ind')) {
              this.stack.push({
                type: 'block-map',
                offset: this.offset,
                indent: this.indent,
                items: [{
                  start,
                  key: null,
                  sep: [this.sourceToken]
                }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, 'newline')) {
              const start = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              // @ts-expect-error type guard is wrong here
              delete it.key, delete it.sep;
              this.stack.push({
                type: 'block-map',
                offset: this.offset,
                indent: this.indent,
                items: [{
                  start,
                  key,
                  sep
                }]
              });
            } else if (start.length > 0) {
              // Not actually at next item
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, {
                key: null,
                sep: [this.sourceToken]
              });
            } else if (it.value || atNextItem) {
              map.items.push({
                start,
                key: null,
                sep: [this.sourceToken]
              });
            } else if (includesToken(it.sep, 'map-value-ind')) {
              this.stack.push({
                type: 'block-map',
                offset: this.offset,
                indent: this.indent,
                items: [{
                  start: [],
                  key: null,
                  sep: [this.sourceToken]
                }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
          {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map.items.push({
                start,
                key: fs,
                sep: []
              });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, {
                key: fs,
                sep: []
              });
              this.onKeyLine = true;
            }
            return;
          }
        default:
          {
            const bv = this.startBlockValue(map);
            if (bv) {
              if (atNextItem && bv.type !== 'block-seq' && includesToken(it.start, 'explicit-key-ind')) {
                map.items.push({
                  start
                });
              }
              this.stack.push(bv);
              return;
            }
          }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq) {
    const it = seq.items[seq.items.length - 1];
    switch (this.type) {
      case 'newline':
        if (it.value) {
          const end = 'end' in it.value ? it.value.end : undefined;
          const last = Array.isArray(end) ? end[end.length - 1] : undefined;
          if ((last === null || last === void 0 ? void 0 : last.type) === 'comment') end === null || end === void 0 ? void 0 : end.push(this.sourceToken);else seq.items.push({
            start: [this.sourceToken]
          });
        } else it.start.push(this.sourceToken);
        return;
      case 'space':
      case 'comment':
        if (it.value) seq.items.push({
          start: [this.sourceToken]
        });else {
          if (this.atIndentedComment(it.start, seq.indent)) {
            var _prev$value2;
            const prev = seq.items[seq.items.length - 2];
            const end = prev === null || prev === void 0 ? void 0 : (_prev$value2 = prev.value) === null || _prev$value2 === void 0 ? void 0 : _prev$value2.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case 'anchor':
      case 'tag':
        if (it.value || this.indent <= seq.indent) break;
        it.start.push(this.sourceToken);
        return;
      case 'seq-item-ind':
        if (this.indent !== seq.indent) break;
        if (it.value || includesToken(it.start, 'seq-item-ind')) seq.items.push({
          start: [this.sourceToken]
        });else it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq.indent) {
      const bv = this.startBlockValue(seq);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === 'flow-error-end') {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === 'flow-collection');
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case 'comma':
        case 'explicit-key-ind':
          if (!it || it.sep) fc.items.push({
            start: [this.sourceToken]
          });else it.start.push(this.sourceToken);
          return;
        case 'map-value-ind':
          if (!it || it.value) fc.items.push({
            start: [],
            key: null,
            sep: [this.sourceToken]
          });else if (it.sep) it.sep.push(this.sourceToken);else Object.assign(it, {
            key: null,
            sep: [this.sourceToken]
          });
          return;
        case 'space':
        case 'comment':
        case 'newline':
        case 'anchor':
        case 'tag':
          if (!it || it.value) fc.items.push({
            start: [this.sourceToken]
          });else if (it.sep) it.sep.push(this.sourceToken);else it.start.push(this.sourceToken);
          return;
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
          {
            const fs = this.flowScalar(this.type);
            if (!it || it.value) fc.items.push({
              start: [],
              key: fs,
              sep: []
            });else if (it.sep) this.stack.push(fs);else Object.assign(it, {
              key: fs,
              sep: []
            });
            return;
          }
        case 'flow-map-end':
        case 'flow-seq-end':
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      /* istanbul ignore else should not happen */
      if (bv) this.stack.push(bv);else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === 'block-map' && (this.type === 'map-value-ind' && parent.indent === fc.indent || this.type === 'newline' && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === 'map-value-ind' && parent.type !== 'flow-collection') {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map = {
          type: 'block-map',
          offset: fc.offset,
          indent: fc.indent,
          items: [{
            start,
            key: fc,
            sep
          }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf('\n') + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf('\n', nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case 'alias':
      case 'scalar':
      case 'single-quoted-scalar':
      case 'double-quoted-scalar':
        return this.flowScalar(this.type);
      case 'block-scalar-header':
        return {
          type: 'block-scalar',
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ''
        };
      case 'flow-map-start':
      case 'flow-seq-start':
        return {
          type: 'flow-collection',
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case 'seq-item-ind':
        return {
          type: 'block-seq',
          offset: this.offset,
          indent: this.indent,
          items: [{
            start: [this.sourceToken]
          }]
        };
      case 'explicit-key-ind':
        {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: 'block-map',
            offset: this.offset,
            indent: this.indent,
            items: [{
              start
            }]
          };
        }
      case 'map-value-ind':
        {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: 'block-map',
            offset: this.offset,
            indent: this.indent,
            items: [{
              start,
              key: null,
              sep: [this.sourceToken]
            }]
          };
        }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== 'comment') return false;
    if (this.indent <= indent) return false;
    return start.every(st => st.type === 'newline' || st.type === 'space');
  }
  *documentEnd(docEnd) {
    if (this.type !== 'doc-mode') {
      if (docEnd.end) docEnd.end.push(this.sourceToken);else docEnd.end = [this.sourceToken];
      if (this.type === 'newline') yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case 'comma':
      case 'doc-start':
      case 'doc-end':
      case 'flow-seq-end':
      case 'flow-map-end':
      case 'map-value-ind':
        yield* this.pop();
        yield* this.step();
        break;
      case 'newline':
        this.onKeyLine = false;
      // fallthrough
      case 'space':
      case 'comment':
      default:
        // all other values are errors
        if (token.end) token.end.push(this.sourceToken);else token.end = [this.sourceToken];
        if (this.type === 'newline') yield* this.pop();
    }
  }
}
exports.Parser = Parser;
}),
/* --- node_modules/yaml/dist/public-api.js --- */
"node_modules/yaml/dist/public-api.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var composer = _kame_require_("node_modules/yaml/dist/compose/composer.js");
var Document = _kame_require_("node_modules/yaml/dist/doc/Document.js");
var errors = _kame_require_("node_modules/yaml/dist/errors.js");
var log = _kame_require_("node_modules/yaml/dist/log.js");
var lineCounter = _kame_require_("node_modules/yaml/dist/parse/line-counter.js");
var parser = _kame_require_("node_modules/yaml/dist/parse/parser.js");
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
  return {
    lineCounter: lineCounter$1,
    prettyErrors
  };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
  const {
    lineCounter,
    prettyErrors
  } = parseOptions(options);
  const parser$1 = new parser.Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
  const composer$1 = new composer.Composer(options);
  const docs = Array.from(composer$1.compose(parser$1.parse(source)));
  if (prettyErrors && lineCounter) for (const doc of docs) {
    doc.errors.forEach(errors.prettifyError(source, lineCounter));
    doc.warnings.forEach(errors.prettifyError(source, lineCounter));
  }
  if (docs.length > 0) return docs;
  return Object.assign([], {
    empty: true
  }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
  const {
    lineCounter,
    prettyErrors
  } = parseOptions(options);
  const parser$1 = new parser.Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
  const composer$1 = new composer.Composer(options);
  // `doc` is always set by compose.end(true) at the very latest
  let doc = null;
  for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
    if (!doc) doc = _doc;else if (doc.options.logLevel !== 'silent') {
      doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(errors.prettifyError(source, lineCounter));
    doc.warnings.forEach(errors.prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = undefined;
  if (typeof reviver === 'function') {
    _reviver = reviver;
  } else if (options === undefined && reviver && typeof reviver === 'object') {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc) return null;
  doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== 'silent') throw doc.errors[0];else doc.errors = [];
  }
  return doc.toJS(Object.assign({
    reviver: _reviver
  }, options));
}
function stringify(value, replacer, options) {
  let _replacer = null;
  if (typeof replacer === 'function' || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === undefined && replacer) {
    options = replacer;
  }
  if (typeof options === 'string') options = options.length;
  if (typeof options === 'number') {
    const indent = Math.round(options);
    options = indent < 1 ? undefined : indent > 8 ? {
      indent: 8
    } : {
      indent
    };
  }
  if (value === undefined) {
    const {
      keepUndefined
    } = options ?? replacer ?? {};
    if (!keepUndefined) return undefined;
  }
  return new Document.Document(value, _replacer, options).toString(options);
}
exports.parse = parse;
exports.parseAllDocuments = parseAllDocuments;
exports.parseDocument = parseDocument;
exports.stringify = stringify;
}),
/* --- node_modules/yaml/dist/visit.js --- */
"node_modules/yaml/dist/visit.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (Node.isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE) node.contents = null;
  } else visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== 'symbol') {
    if (Node.isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === 'number') i = ci - 1;else if (ci === BREAK) return BREAK;else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (Node.isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_('key', node.key, visitor, path);
      if (ck === BREAK) return BREAK;else if (ck === REMOVE) node.key = null;
      const cv = visit_('value', node.value, visitor, path);
      if (cv === BREAK) return BREAK;else if (cv === REMOVE) node.value = null;
    }
  }
  return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (Node.isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE) node.contents = null;
  } else await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP;
/** Remove the current node */
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== 'symbol') {
    if (Node.isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path);
        if (typeof ci === 'number') i = ci - 1;else if (ci === BREAK) return BREAK;else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (Node.isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_('key', node.key, visitor, path);
      if (ck === BREAK) return BREAK;else if (ck === REMOVE) node.key = null;
      const cv = await visitAsync_('value', node.value, visitor, path);
      if (cv === BREAK) return BREAK;else if (cv === REMOVE) node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === 'object' && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  var _visitor$Map, _visitor$Seq, _visitor$Pair, _visitor$Scalar, _visitor$Alias;
  if (typeof visitor === 'function') return visitor(key, node, path);
  if (Node.isMap(node)) return (_visitor$Map = visitor.Map) === null || _visitor$Map === void 0 ? void 0 : _visitor$Map.call(visitor, key, node, path);
  if (Node.isSeq(node)) return (_visitor$Seq = visitor.Seq) === null || _visitor$Seq === void 0 ? void 0 : _visitor$Seq.call(visitor, key, node, path);
  if (Node.isPair(node)) return (_visitor$Pair = visitor.Pair) === null || _visitor$Pair === void 0 ? void 0 : _visitor$Pair.call(visitor, key, node, path);
  if (Node.isScalar(node)) return (_visitor$Scalar = visitor.Scalar) === null || _visitor$Scalar === void 0 ? void 0 : _visitor$Scalar.call(visitor, key, node, path);
  if (Node.isAlias(node)) return (_visitor$Alias = visitor.Alias) === null || _visitor$Alias === void 0 ? void 0 : _visitor$Alias.call(visitor, key, node, path);
  return undefined;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (Node.isCollection(parent)) {
    parent.items[key] = node;
  } else if (Node.isPair(parent)) {
    if (key === 'key') parent.key = node;else parent.value = node;
  } else if (Node.isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = Node.isAlias(parent) ? 'alias' : 'scalar';
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
exports.visit = visit;
exports.visitAsync = visitAsync;
}),
/* --- src/kame-module-stub.js --- */
"src/kame-module-stub.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

module.exports = {};
}),
/* --- node_modules/clef-parse/dist/convert-case.js --- */
"node_modules/clef-parse/dist/convert-case.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToCamelCase = void 0;
function convertToCamelCase(input) {
  const parts = input.split(/\b|_/g).map(part => part.toLowerCase()).filter(part => /[A-Za-z0-9]/.test(part));
  const [first, ...rest] = parts.filter(Boolean);
  const mappedParts = [first, ...rest.map(part => part[0].toUpperCase() + part.slice(1))];
  return mappedParts.join("");
}
exports.convertToCamelCase = convertToCamelCase;
}),
/* --- node_modules/sucrase/dist/CJSImportProcessor.js --- */
"node_modules/sucrase/dist/CJSImportProcessor.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _getImportExportSpecifierInfo = _kame_require_("node_modules/sucrase/dist/util/getImportExportSpecifierInfo.js");
var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = _kame_require_("node_modules/sucrase/dist/util/getNonTypeIdentifiers.js");

/**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */
class CJSImportProcessor {
  __init() {
    this.nonTypeIdentifiers = new Set();
  }
  __init2() {
    this.importInfoByPath = new Map();
  }
  __init3() {
    this.importsToReplace = new Map();
  }
  __init4() {
    this.identifierReplacements = new Map();
  }
  __init5() {
    this.exportBindingsByLocalName = new Map();
  }
  constructor(nameManager, tokens, enableLegacyTypeScriptModuleInterop, options, isTypeScriptTransformEnabled, helperManager) {
    ;
    this.nameManager = nameManager;
    this.tokens = tokens;
    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
    this.options = options;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.helperManager = helperManager;
    CJSImportProcessor.prototype.__init.call(this);
    CJSImportProcessor.prototype.__init2.call(this);
    CJSImportProcessor.prototype.__init3.call(this);
    CJSImportProcessor.prototype.__init4.call(this);
    CJSImportProcessor.prototype.__init5.call(this);
  }
  preprocessTokens() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (this.tokens.matches1AtIndex(i, _types.TokenType._import) && !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {
        this.preprocessImportAtIndex(i);
      }
      if (this.tokens.matches1AtIndex(i, _types.TokenType._export) && !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)) {
        this.preprocessExportAtIndex(i);
      }
    }
    this.generateImportReplacements();
  }

  /**
   * In TypeScript, import statements that only import types should be removed. This does not count
   * bare imports.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (importInfo.hasBareImport || importInfo.hasStarExport || importInfo.exportStarNames.length > 0 || importInfo.namedExports.length > 0) {
        continue;
      }
      const names = [...importInfo.defaultNames, ...importInfo.wildcardNames, ...importInfo.namedImports.map(({
        localName
      }) => localName)];
      if (names.every(name => this.isTypeName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }
  isTypeName(name) {
    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);
  }
  generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport
      } = importInfo;
      if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0 && namedExports.length === 0 && exportStarNames.length === 0 && !hasStarExport) {
        // Import is never used, so don't even assign a name.
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }
      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName = wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop ? primaryImportName : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName("interopRequireDefault")}(${primaryImportName});`;
      }
      for (const {
        importedName,
        localName
      } of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName("createNamedExportFrom")}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName("createStarExport")}(${primaryImportName});`;
      }
      this.importsToReplace.set(path, requireCode);
      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const {
        importedName,
        localName
      } of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }
  getFreeIdentifierForPath(path) {
    const components = path.split("/");
    const lastComponent = components[components.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }
  preprocessImportAtIndex(index) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];
    index++;
    if ((this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) || this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) && !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) && !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)) {
      // import type declaration, so no need to process anything.
      return;
    }
    if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) {
      // Dynamic import, so nothing to do
      return;
    }
    if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
      if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      }
    }
    if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {
      // * as
      index += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
    }
    if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
      const result = this.getNamedImports(index + 1);
      index = result.newIndex;
      for (const namedImport of result.namedImports) {
        // Treat {default as X} as a default import to ensure usage of require interop helper
        if (namedImport.importedName === "default") {
          defaultNames.push(namedImport.localName);
        } else {
          namedImports.push(namedImport);
        }
      }
    }
    if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) {
      index++;
    }
    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.defaultNames.push(...defaultNames);
    importInfo.wildcardNames.push(...wildcardNames);
    importInfo.namedImports.push(...namedImports);
    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {
      importInfo.hasBareImport = true;
    }
  }
  preprocessExportAtIndex(index) {
    if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._var) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._let) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._const)) {
      this.preprocessVarExportAtIndex(index);
    } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._function) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._class)) {
      const exportName = this.tokens.identifierNameAtIndex(index + 2);
      this.addExportBinding(exportName, exportName);
    } else if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.name, _types.TokenType._function)) {
      const exportName = this.tokens.identifierNameAtIndex(index + 3);
      this.addExportBinding(exportName, exportName);
    } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.braceL)) {
      this.preprocessNamedExportAtIndex(index);
    } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.star)) {
      this.preprocessExportStarAtIndex(index);
    }
  }
  preprocessVarExportAtIndex(index) {
    let depth = 0;
    // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.
    for (let i = index + 2;; i++) {
      if (this.tokens.matches1AtIndex(i, _types.TokenType.braceL) || this.tokens.matches1AtIndex(i, _types.TokenType.dollarBraceL) || this.tokens.matches1AtIndex(i, _types.TokenType.bracketL)) {
        depth++;
      } else if (this.tokens.matches1AtIndex(i, _types.TokenType.braceR) || this.tokens.matches1AtIndex(i, _types.TokenType.bracketR)) {
        depth--;
      } else if (depth === 0 && !this.tokens.matches1AtIndex(i, _types.TokenType.name)) {
        break;
      } else if (this.tokens.matches1AtIndex(1, _types.TokenType.eq)) {
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        i = endIndex - 1;
      } else {
        const token = this.tokens.tokens[i];
        if (_tokenizer.isDeclaration.call(void 0, token)) {
          const exportName = this.tokens.identifierNameAtIndex(i);
          this.identifierReplacements.set(exportName, `exports.${exportName}`);
        }
      }
    }
  }

  /**
   * Walk this export statement just in case it's an export...from statement.
   * If it is, combine it into the import info for that path. Otherwise, just
   * bail out; it'll be handled later.
   */
  preprocessNamedExportAtIndex(index) {
    // export {
    index += 2;
    const {
      newIndex,
      namedImports
    } = this.getNamedImports(index);
    index = newIndex;
    if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) {
      index++;
    } else {
      // Reinterpret "a as b" to be local/exported rather than imported/local.
      for (const {
        importedName: localName,
        localName: exportedName
      } of namedImports) {
        this.addExportBinding(localName, exportedName);
      }
      return;
    }
    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.namedExports.push(...namedImports);
  }
  preprocessExportStarAtIndex(index) {
    let exportedName = null;
    if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.star, _types.TokenType._as)) {
      // export * as
      index += 3;
      exportedName = this.tokens.identifierNameAtIndex(index);
      // foo from
      index += 2;
    } else {
      // export * from
      index += 3;
    }
    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of star export statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    if (exportedName !== null) {
      importInfo.exportStarNames.push(exportedName);
    } else {
      importInfo.hasStarExport = true;
    }
  }
  getNamedImports(index) {
    const namedImports = [];
    while (true) {
      if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      }
      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens, index);
      index = specifierInfo.endIndex;
      if (!specifierInfo.isType) {
        namedImports.push({
          importedName: specifierInfo.leftName,
          localName: specifierInfo.rightName
        });
      }
      if (this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {
        index += 2;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
      }
    }
    return {
      newIndex: index,
      namedImports
    };
  }

  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
  getImportInfo(path) {
    const existingInfo = this.importInfoByPath.get(path);
    if (existingInfo) {
      return existingInfo;
    }
    const newInfo = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: false,
      exportStarNames: [],
      hasStarExport: false
    };
    this.importInfoByPath.set(path, newInfo);
    return newInfo;
  }
  addExportBinding(localName, exportedName) {
    if (!this.exportBindingsByLocalName.has(localName)) {
      this.exportBindingsByLocalName.set(localName, []);
    }
    this.exportBindingsByLocalName.get(localName).push(exportedName);
  }

  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(importPath) {
    const result = this.importsToReplace.get(importPath);
    this.importsToReplace.set(importPath, "");
    return result || "";
  }
  getIdentifierReplacement(identifierName) {
    return this.identifierReplacements.get(identifierName) || null;
  }

  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(assignedName) {
    const exportedNames = this.exportBindingsByLocalName.get(assignedName);
    if (!exportedNames || exportedNames.length === 0) {
      return null;
    }
    return exportedNames.map(exportedName => `exports.${exportedName}`).join(" = ");
  }

  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return new Set([...this.identifierReplacements.keys(), ...this.exportBindingsByLocalName.keys()]);
  }
}
exports.default = CJSImportProcessor;
}),
/* --- node_modules/sucrase/dist/computeSourceMap.js --- */
"node_modules/sucrase/dist/computeSourceMap.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");

/**
 * Generate a simple source map indicating that each line maps directly to the original line.
 */
function computeSourceMap(code, filePath, {
  compiledFilename
}) {
  let mappings = "AAAA";
  for (let i = 0; i < code.length; i++) {
    if (code.charCodeAt(i) === _charcodes.charCodes.lineFeed) {
      mappings += ";AACA";
    }
  }
  return {
    version: 3,
    file: compiledFilename || "",
    sources: [filePath],
    mappings,
    names: []
  };
}
exports.default = computeSourceMap;
}),
/* --- node_modules/sucrase/dist/HelperManager.js --- */
"node_modules/sucrase/dist/HelperManager.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const HELPERS = {
  require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `,
  interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `,
  interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `,
  createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `,
  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence
  // check in the exports object and does a plain assignment, whereas Babel uses
  // defineProperty and builds an object of explicitly-exported names so that star exports can
  // always take lower precedence. For now, we do the easier TypeScript thing.
  createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `,
  nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `,
  asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `,
  optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `,
  asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `
};
class HelperManager {
  __init() {
    this.helperNames = {};
  }
  __init2() {
    this.createRequireName = null;
  }
  constructor(nameManager) {
    ;
    this.nameManager = nameManager;
    HelperManager.prototype.__init.call(this);
    HelperManager.prototype.__init2.call(this);
  }
  getHelperName(baseName) {
    let helperName = this.helperNames[baseName];
    if (helperName) {
      return helperName;
    }
    helperName = this.nameManager.claimFreeName(`_${baseName}`);
    this.helperNames[baseName] = helperName;
    return helperName;
  }
  emitHelpers() {
    let resultCode = "";
    if (this.helperNames.optionalChainDelete) {
      this.getHelperName("optionalChain");
    }
    if (this.helperNames.asyncOptionalChainDelete) {
      this.getHelperName("asyncOptionalChain");
    }
    for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)) {
      const helperName = this.helperNames[baseName];
      let helperCode = helperCodeTemplate;
      if (baseName === "optionalChainDelete") {
        helperCode = helperCode.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain);
      } else if (baseName === "asyncOptionalChainDelete") {
        helperCode = helperCode.replace("ASYNC_OPTIONAL_CHAIN_NAME", this.helperNames.asyncOptionalChain);
      } else if (baseName === "require") {
        if (this.createRequireName === null) {
          this.createRequireName = this.nameManager.claimFreeName("_createRequire");
        }
        helperCode = helperCode.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName);
      }
      if (helperName) {
        resultCode += " ";
        resultCode += helperCode.replace(baseName, helperName).replace(/\s+/g, " ").trim();
      }
    }
    return resultCode;
  }
}
exports.HelperManager = HelperManager;
}),
/* --- node_modules/sucrase/dist/identifyShadowedGlobals.js --- */
"node_modules/sucrase/dist/identifyShadowedGlobals.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");

/**
 * Traverse the given tokens and modify them if necessary to indicate that some names shadow global
 * variables.
 */
function identifyShadowedGlobals(tokens, scopes, globalNames) {
  if (!hasShadowedGlobals(tokens, globalNames)) {
    return;
  }
  markShadowedGlobals(tokens, scopes, globalNames);
}
exports.default = identifyShadowedGlobals;

/**
 * We can do a fast up-front check to see if there are any declarations to global names. If not,
 * then there's no point in computing scope assignments.
 */
// Exported for testing.
function hasShadowedGlobals(tokens, globalNames) {
  for (const token of tokens.tokens) {
    if (token.type === _types.TokenType.name && _tokenizer.isNonTopLevelDeclaration.call(void 0, token) && globalNames.has(tokens.identifierNameForToken(token))) {
      return true;
    }
  }
  return false;
}
exports.hasShadowedGlobals = hasShadowedGlobals;
function markShadowedGlobals(tokens, scopes, globalNames) {
  const scopeStack = [];
  let scopeIndex = scopes.length - 1;
  // Scopes were generated at completion time, so they're sorted by end index, so we can maintain a
  // good stack by going backwards through them.
  for (let i = tokens.tokens.length - 1;; i--) {
    while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i + 1) {
      scopeStack.pop();
    }
    while (scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i + 1) {
      scopeStack.push(scopes[scopeIndex]);
      scopeIndex--;
    }
    // Process scopes after the last iteration so we can make sure we pop all of them.
    if (i < 0) {
      break;
    }
    const token = tokens.tokens[i];
    const name = tokens.identifierNameForToken(token);
    if (scopeStack.length > 1 && token.type === _types.TokenType.name && globalNames.has(name)) {
      if (_tokenizer.isBlockScopedDeclaration.call(void 0, token)) {
        markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);
      } else if (_tokenizer.isFunctionScopedDeclaration.call(void 0, token)) {
        let stackIndex = scopeStack.length - 1;
        while (stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope) {
          stackIndex--;
        }
        if (stackIndex < 0) {
          throw new Error("Did not find parent function scope.");
        }
        markShadowedForScope(scopeStack[stackIndex], tokens, name);
      }
    }
  }
  if (scopeStack.length > 0) {
    throw new Error("Expected empty scope stack after processing file.");
  }
}
function markShadowedForScope(scope, tokens, name) {
  for (let i = scope.startTokenIndex; i < scope.endTokenIndex; i++) {
    const token = tokens.tokens[i];
    if ((token.type === _types.TokenType.name || token.type === _types.TokenType.jsxName) && tokens.identifierNameForToken(token) === name) {
      token.shadowsGlobal = true;
    }
  }
}
}),
/* --- node_modules/sucrase/dist/NameManager.js --- */
"node_modules/sucrase/dist/NameManager.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _getIdentifierNames = _kame_require_("node_modules/sucrase/dist/util/getIdentifierNames.js");
var _getIdentifierNames2 = _interopRequireDefault(_getIdentifierNames);
class NameManager {
  __init() {
    this.usedNames = new Set();
  }
  constructor(code, tokens) {
    ;
    NameManager.prototype.__init.call(this);
    this.usedNames = new Set(_getIdentifierNames2.default.call(void 0, code, tokens));
  }
  claimFreeName(name) {
    const newName = this.findFreeName(name);
    this.usedNames.add(newName);
    return newName;
  }
  findFreeName(name) {
    if (!this.usedNames.has(name)) {
      return name;
    }
    let suffixNum = 2;
    while (this.usedNames.has(name + String(suffixNum))) {
      suffixNum++;
    }
    return name + String(suffixNum);
  }
}
exports.default = NameManager;
}),
/* --- node_modules/sucrase/dist/Options.js --- */
"node_modules/sucrase/dist/Options.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _tsinterfacechecker = _kame_require_("src/kame-ts-interface-checker-stub.js");
var _Optionsgentypes = _kame_require_("node_modules/sucrase/dist/Options-gen-types.js");
var _Optionsgentypes2 = _interopRequireDefault(_Optionsgentypes);
const {
  Options: OptionsChecker
} = _tsinterfacechecker.createCheckers.call(void 0, _Optionsgentypes2.default);
function validateOptions(options) {
  OptionsChecker.strictCheck(options);
}
exports.validateOptions = validateOptions;
}),
/* --- node_modules/sucrase/dist/parser/index.js --- */
"node_modules/sucrase/dist/parser/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _index = _kame_require_("node_modules/sucrase/dist/parser/traverser/index.js");
class File {
  constructor(tokens, scopes) {
    this.tokens = tokens;
    this.scopes = scopes;
  }
}
exports.File = File;
function parse(input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled) {
  if (isFlowEnabled && isTypeScriptEnabled) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }
  _base.initParser.call(void 0, input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);
  const result = _index.parseFile.call(void 0);
  if (_base.state.error) {
    throw _base.augmentError.call(void 0, _base.state.error);
  }
  return result;
}
exports.parse = parse;
}),
/* --- node_modules/sucrase/dist/TokenProcessor.js --- */
"node_modules/sucrase/dist/TokenProcessor.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _isAsyncOperation = _kame_require_("node_modules/sucrase/dist/util/isAsyncOperation.js");
var _isAsyncOperation2 = _interopRequireDefault(_isAsyncOperation);
class TokenProcessor {
  __init() {
    this.resultCode = "";
  }
  __init2() {
    this.tokenIndex = 0;
  }
  constructor(code, tokens, isFlowEnabled, disableESTransforms, helperManager) {
    ;
    this.code = code;
    this.tokens = tokens;
    this.isFlowEnabled = isFlowEnabled;
    this.disableESTransforms = disableESTransforms;
    this.helperManager = helperManager;
    TokenProcessor.prototype.__init.call(this);
    TokenProcessor.prototype.__init2.call(this);
  }

  /**
   * Make a new TokenProcessor for things like lookahead.
   */
  snapshot() {
    return {
      resultCode: this.resultCode,
      tokenIndex: this.tokenIndex
    };
  }
  restoreToSnapshot(snapshot) {
    this.resultCode = snapshot.resultCode;
    this.tokenIndex = snapshot.tokenIndex;
  }

  /**
   * Remove and return the code generated since the snapshot, leaving the
   * current token position in-place. Unlike most TokenProcessor operations,
   * this operation can result in input/output line number mismatches because
   * the removed code may contain newlines, so this operation should be used
   * sparingly.
   */
  dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {
    const result = this.resultCode.slice(snapshot.resultCode.length);
    this.resultCode = snapshot.resultCode;
    return result;
  }
  reset() {
    this.resultCode = "";
    this.tokenIndex = 0;
  }
  matchesContextualAtIndex(index, contextualKeyword) {
    return this.matches1AtIndex(index, _types.TokenType.name) && this.tokens[index].contextualKeyword === contextualKeyword;
  }
  identifierNameAtIndex(index) {
    // TODO: We need to process escapes since technically you can have unicode escapes in variable
    // names.
    return this.identifierNameForToken(this.tokens[index]);
  }
  identifierNameAtRelativeIndex(relativeIndex) {
    return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));
  }
  identifierName() {
    return this.identifierNameForToken(this.currentToken());
  }
  identifierNameForToken(token) {
    return this.code.slice(token.start, token.end);
  }
  rawCodeForToken(token) {
    return this.code.slice(token.start, token.end);
  }
  stringValueAtIndex(index) {
    return this.stringValueForToken(this.tokens[index]);
  }
  stringValue() {
    return this.stringValueForToken(this.currentToken());
  }
  stringValueForToken(token) {
    // This is used to identify when two imports are the same and to resolve TypeScript enum keys.
    // Ideally we'd process escapes within the strings, but for now we pretty much take the raw
    // code.
    return this.code.slice(token.start + 1, token.end - 1);
  }
  matches1AtIndex(index, t1) {
    return this.tokens[index].type === t1;
  }
  matches2AtIndex(index, t1, t2) {
    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;
  }
  matches3AtIndex(index, t1, t2, t3) {
    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2 && this.tokens[index + 2].type === t3;
  }
  matches1(t1) {
    return this.tokens[this.tokenIndex].type === t1;
  }
  matches2(t1, t2) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;
  }
  matches3(t1, t2, t3) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3;
  }
  matches4(t1, t2, t3, t4) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4;
  }
  matches5(t1, t2, t3, t4, t5) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4 && this.tokens[this.tokenIndex + 4].type === t5;
  }
  matchesContextual(contextualKeyword) {
    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);
  }
  matchesContextIdAndLabel(type, contextId) {
    return this.matches1(type) && this.currentToken().contextId === contextId;
  }
  previousWhitespaceAndComments() {
    let whitespaceAndComments = this.code.slice(this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0, this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length);
    if (this.isFlowEnabled) {
      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, "");
    }
    return whitespaceAndComments;
  }
  replaceToken(newCode) {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultCode += newCode;
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  replaceTokenTrimmingLeftWhitespace(newCode) {
    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, "");
    this.appendTokenPrefix();
    this.resultCode += newCode;
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  removeInitialToken() {
    this.replaceToken("");
  }
  removeToken() {
    this.replaceTokenTrimmingLeftWhitespace("");
  }

  /**
   * Remove all code until the next }, accounting for balanced braces.
   */
  removeBalancedCode() {
    let braceDepth = 0;
    while (!this.isAtEnd()) {
      if (this.matches1(_types.TokenType.braceL)) {
        braceDepth++;
      } else if (this.matches1(_types.TokenType.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      this.removeToken();
    }
  }
  copyExpectedToken(tokenType) {
    if (this.tokens[this.tokenIndex].type !== tokenType) {
      throw new Error(`Expected token ${tokenType}`);
    }
    this.copyToken();
  }
  copyToken() {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  copyTokenWithPrefix(prefix) {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultCode += prefix;
    this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  appendTokenPrefix() {
    const token = this.currentToken();
    if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {
      token.isAsyncOperation = _isAsyncOperation2.default.call(void 0, this);
    }
    if (this.disableESTransforms) {
      return;
    }
    if (token.numNullishCoalesceStarts) {
      for (let i = 0; i < token.numNullishCoalesceStarts; i++) {
        if (token.isAsyncOperation) {
          this.resultCode += "await ";
          this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce");
        } else {
          this.resultCode += this.helperManager.getHelperName("nullishCoalesce");
        }
        this.resultCode += "(";
      }
    }
    if (token.isOptionalChainStart) {
      if (token.isAsyncOperation) {
        this.resultCode += "await ";
      }
      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === _types.TokenType._delete) {
        if (token.isAsyncOperation) {
          this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete");
        } else {
          this.resultCode += this.helperManager.getHelperName("optionalChainDelete");
        }
      } else if (token.isAsyncOperation) {
        this.resultCode += this.helperManager.getHelperName("asyncOptionalChain");
      } else {
        this.resultCode += this.helperManager.getHelperName("optionalChain");
      }
      this.resultCode += "([";
    }
  }
  appendTokenSuffix() {
    const token = this.currentToken();
    if (token.isOptionalChainEnd && !this.disableESTransforms) {
      this.resultCode += "])";
    }
    if (token.numNullishCoalesceEnds && !this.disableESTransforms) {
      for (let i = 0; i < token.numNullishCoalesceEnds; i++) {
        this.resultCode += "))";
      }
    }
  }
  appendCode(code) {
    this.resultCode += code;
  }
  currentToken() {
    return this.tokens[this.tokenIndex];
  }
  currentTokenCode() {
    const token = this.currentToken();
    return this.code.slice(token.start, token.end);
  }
  tokenAtRelativeIndex(relativeIndex) {
    return this.tokens[this.tokenIndex + relativeIndex];
  }
  currentIndex() {
    return this.tokenIndex;
  }

  /**
   * Move to the next token. Only suitable in preprocessing steps. When
   * generating new code, you should use copyToken or removeToken.
   */
  nextToken() {
    if (this.tokenIndex === this.tokens.length) {
      throw new Error("Unexpectedly reached end of input.");
    }
    this.tokenIndex++;
  }
  previousToken() {
    this.tokenIndex--;
  }
  finish() {
    if (this.tokenIndex !== this.tokens.length) {
      throw new Error("Tried to finish processing tokens before reaching the end.");
    }
    this.resultCode += this.previousWhitespaceAndComments();
    return this.resultCode;
  }
  isAtEnd() {
    return this.tokenIndex === this.tokens.length;
  }
}
exports.default = TokenProcessor;
}),
/* --- node_modules/sucrase/dist/transformers/RootTransformer.js --- */
"node_modules/sucrase/dist/transformers/RootTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _getClassInfo = _kame_require_("node_modules/sucrase/dist/util/getClassInfo.js");
var _getClassInfo2 = _interopRequireDefault(_getClassInfo);
var _CJSImportTransformer = _kame_require_("node_modules/sucrase/dist/transformers/CJSImportTransformer.js");
var _CJSImportTransformer2 = _interopRequireDefault(_CJSImportTransformer);
var _ESMImportTransformer = _kame_require_("node_modules/sucrase/dist/transformers/ESMImportTransformer.js");
var _ESMImportTransformer2 = _interopRequireDefault(_ESMImportTransformer);
var _FlowTransformer = _kame_require_("node_modules/sucrase/dist/transformers/FlowTransformer.js");
var _FlowTransformer2 = _interopRequireDefault(_FlowTransformer);
var _JestHoistTransformer = _kame_require_("node_modules/sucrase/dist/transformers/JestHoistTransformer.js");
var _JestHoistTransformer2 = _interopRequireDefault(_JestHoistTransformer);
var _JSXTransformer = _kame_require_("node_modules/sucrase/dist/transformers/JSXTransformer.js");
var _JSXTransformer2 = _interopRequireDefault(_JSXTransformer);
var _NumericSeparatorTransformer = _kame_require_("node_modules/sucrase/dist/transformers/NumericSeparatorTransformer.js");
var _NumericSeparatorTransformer2 = _interopRequireDefault(_NumericSeparatorTransformer);
var _OptionalCatchBindingTransformer = _kame_require_("node_modules/sucrase/dist/transformers/OptionalCatchBindingTransformer.js");
var _OptionalCatchBindingTransformer2 = _interopRequireDefault(_OptionalCatchBindingTransformer);
var _OptionalChainingNullishTransformer = _kame_require_("node_modules/sucrase/dist/transformers/OptionalChainingNullishTransformer.js");
var _OptionalChainingNullishTransformer2 = _interopRequireDefault(_OptionalChainingNullishTransformer);
var _ReactDisplayNameTransformer = _kame_require_("node_modules/sucrase/dist/transformers/ReactDisplayNameTransformer.js");
var _ReactDisplayNameTransformer2 = _interopRequireDefault(_ReactDisplayNameTransformer);
var _ReactHotLoaderTransformer = _kame_require_("node_modules/sucrase/dist/transformers/ReactHotLoaderTransformer.js");
var _ReactHotLoaderTransformer2 = _interopRequireDefault(_ReactHotLoaderTransformer);
var _TypeScriptTransformer = _kame_require_("node_modules/sucrase/dist/transformers/TypeScriptTransformer.js");
var _TypeScriptTransformer2 = _interopRequireDefault(_TypeScriptTransformer);
class RootTransformer {
  __init() {
    this.transformers = [];
  }
  __init2() {
    this.generatedVariables = [];
  }
  constructor(sucraseContext, transforms, enableLegacyBabel5ModuleInterop, options) {
    ;
    RootTransformer.prototype.__init.call(this);
    RootTransformer.prototype.__init2.call(this);
    this.nameManager = sucraseContext.nameManager;
    this.helperManager = sucraseContext.helperManager;
    const {
      tokenProcessor,
      importProcessor
    } = sucraseContext;
    this.tokens = tokenProcessor;
    this.isImportsTransformEnabled = transforms.includes("imports");
    this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
    this.disableESTransforms = Boolean(options.disableESTransforms);
    if (!options.disableESTransforms) {
      this.transformers.push(new (0, _OptionalChainingNullishTransformer2.default)(tokenProcessor, this.nameManager));
      this.transformers.push(new (0, _NumericSeparatorTransformer2.default)(tokenProcessor));
      this.transformers.push(new (0, _OptionalCatchBindingTransformer2.default)(tokenProcessor, this.nameManager));
    }
    if (transforms.includes("jsx")) {
      this.transformers.push(new (0, _JSXTransformer2.default)(this, tokenProcessor, importProcessor, this.nameManager, options));
      this.transformers.push(new (0, _ReactDisplayNameTransformer2.default)(this, tokenProcessor, importProcessor, options));
    }
    let reactHotLoaderTransformer = null;
    if (transforms.includes("react-hot-loader")) {
      if (!options.filePath) {
        throw new Error("filePath is required when using the react-hot-loader transform.");
      }
      reactHotLoaderTransformer = new (0, _ReactHotLoaderTransformer2.default)(tokenProcessor, options.filePath);
      this.transformers.push(reactHotLoaderTransformer);
    }

    // Note that we always want to enable the imports transformer, even when the import transform
    // itself isn't enabled, since we need to do type-only import pruning for both Flow and
    // TypeScript.
    if (transforms.includes("imports")) {
      if (importProcessor === null) {
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      }
      this.transformers.push(new (0, _CJSImportTransformer2.default)(this, tokenProcessor, importProcessor, this.nameManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, transforms.includes("typescript"), Boolean(options.preserveDynamicImport)));
    } else {
      this.transformers.push(new (0, _ESMImportTransformer2.default)(tokenProcessor, this.nameManager, this.helperManager, reactHotLoaderTransformer, transforms.includes("typescript"), options));
    }
    if (transforms.includes("flow")) {
      this.transformers.push(new (0, _FlowTransformer2.default)(this, tokenProcessor, transforms.includes("imports")));
    }
    if (transforms.includes("typescript")) {
      this.transformers.push(new (0, _TypeScriptTransformer2.default)(this, tokenProcessor, transforms.includes("imports")));
    }
    if (transforms.includes("jest")) {
      this.transformers.push(new (0, _JestHoistTransformer2.default)(this, tokenProcessor, this.nameManager, importProcessor));
    }
  }
  transform() {
    this.tokens.reset();
    this.processBalancedCode();
    const shouldAddUseStrict = this.isImportsTransformEnabled;
    // "use strict" always needs to be first, so override the normal transformer order.
    let prefix = shouldAddUseStrict ? '"use strict";' : "";
    for (const transformer of this.transformers) {
      prefix += transformer.getPrefixCode();
    }
    prefix += this.helperManager.emitHelpers();
    prefix += this.generatedVariables.map(v => ` var ${v};`).join("");
    for (const transformer of this.transformers) {
      prefix += transformer.getHoistedCode();
    }
    let suffix = "";
    for (const transformer of this.transformers) {
      suffix += transformer.getSuffixCode();
    }
    let code = this.tokens.finish();
    if (code.startsWith("#!")) {
      let newlineIndex = code.indexOf("\n");
      if (newlineIndex === -1) {
        newlineIndex = code.length;
        code += "\n";
      }
      return code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix;
    } else {
      return prefix + this.tokens.finish() + suffix;
    }
  }
  processBalancedCode() {
    let braceDepth = 0;
    let parenDepth = 0;
    while (!this.tokens.isAtEnd()) {
      if (this.tokens.matches1(_types.TokenType.braceL) || this.tokens.matches1(_types.TokenType.dollarBraceL)) {
        braceDepth++;
      } else if (this.tokens.matches1(_types.TokenType.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      if (this.tokens.matches1(_types.TokenType.parenL)) {
        parenDepth++;
      } else if (this.tokens.matches1(_types.TokenType.parenR)) {
        if (parenDepth === 0) {
          return;
        }
        parenDepth--;
      }
      this.processToken();
    }
  }
  processToken() {
    if (this.tokens.matches1(_types.TokenType._class)) {
      this.processClass();
      return;
    }
    for (const transformer of this.transformers) {
      const wasProcessed = transformer.process();
      if (wasProcessed) {
        return;
      }
    }
    this.tokens.copyToken();
  }

  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(_types.TokenType._class, _types.TokenType.name)) {
      throw new Error("Expected identifier for exported class name.");
    }
    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    this.processClass();
    return name;
  }
  processClass() {
    const classInfo = _getClassInfo2.default.call(void 0, this, this.tokens, this.nameManager, this.disableESTransforms);

    // Both static and instance initializers need a class name to use to invoke the initializer, so
    // assign to one if necessary.
    const needsCommaExpression = (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) && classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;
    let className = classInfo.headerInfo.className;
    if (needsCommaExpression) {
      className = this.nameManager.claimFreeName("_class");
      this.generatedVariables.push(className);
      this.tokens.appendCode(` (${className} =`);
    }
    const classToken = this.tokens.currentToken();
    const contextId = classToken.contextId;
    if (contextId == null) {
      throw new Error("Expected class to have a context ID.");
    }
    this.tokens.copyExpectedToken(_types.TokenType._class);
    while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)) {
      this.processToken();
    }
    this.processClassBody(classInfo, className);
    const staticInitializerStatements = classInfo.staticInitializerNames.map(name => `${className}.${name}()`);
    if (needsCommaExpression) {
      this.tokens.appendCode(`, ${staticInitializerStatements.map(s => `${s}, `).join("")}${className})`);
    } else if (classInfo.staticInitializerNames.length > 0) {
      this.tokens.appendCode(` ${staticInitializerStatements.map(s => `${s};`).join(" ")}`);
    }
  }

  /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */
  processClassBody(classInfo, className) {
    const {
      headerInfo,
      constructorInsertPos,
      constructorInitializerStatements,
      fields,
      instanceInitializerNames,
      rangesToRemove
    } = classInfo;
    let fieldIndex = 0;
    let rangeToRemoveIndex = 0;
    const classContextId = this.tokens.currentToken().contextId;
    if (classContextId == null) {
      throw new Error("Expected non-null context ID on class.");
    }
    this.tokens.copyExpectedToken(_types.TokenType.braceL);
    if (this.isReactHotLoaderTransformEnabled) {
      this.tokens.appendCode("__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}");
    }
    const needsConstructorInit = constructorInitializerStatements.length + instanceInitializerNames.length > 0;
    if (constructorInsertPos === null && needsConstructorInit) {
      const constructorInitializersCode = this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className);
      if (headerInfo.hasSuperclass) {
        const argsName = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(`constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`);
      } else {
        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);
      }
    }
    while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)) {
      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
        let needsCloseBrace = false;
        if (this.tokens.matches1(_types.TokenType.bracketL)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);
        } else if (this.tokens.matches1(_types.TokenType.string) || this.tokens.matches1(_types.TokenType.num)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);
          needsCloseBrace = true;
        } else {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);
        }
        while (this.tokens.currentIndex() < fields[fieldIndex].end) {
          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {
            this.tokens.appendCode("]");
          }
          this.processToken();
        }
        this.tokens.appendCode("}");
        fieldIndex++;
      } else if (rangeToRemoveIndex < rangesToRemove.length && this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start) {
        if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeInitialToken();
        }
        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeToken();
        }
        rangeToRemoveIndex++;
      } else if (this.tokens.currentIndex() === constructorInsertPos) {
        this.tokens.copyToken();
        if (needsConstructorInit) {
          this.tokens.appendCode(`;${this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className)};`);
        }
        this.processToken();
      } else {
        this.processToken();
      }
    }
    this.tokens.copyExpectedToken(_types.TokenType.braceR);
  }
  makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className) {
    return [...constructorInitializerStatements, ...instanceInitializerNames.map(name => `${className}.prototype.${name}.call(this)`)].join(";");
  }

  /**
   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
   * arrow function return types since they can confuse the parser. In that case, we want to move
   * the close-paren to the same line as the arrow.
   *
   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
   */
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(_types.TokenType.parenR, _types.TokenType.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let nextNonTypeIndex = this.tokens.currentIndex() + 1;
      // Look ahead to see if this is an arrow function or something else.
      while (this.tokens.tokens[nextNonTypeIndex].isType) {
        nextNonTypeIndex++;
      }
      if (this.tokens.matches1AtIndex(nextNonTypeIndex, _types.TokenType.arrow)) {
        this.tokens.removeInitialToken();
        while (this.tokens.currentIndex() < nextNonTypeIndex) {
          this.tokens.removeToken();
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(") =>");
        return true;
      }
    }
    return false;
  }

  /**
   * An async arrow function might be of the form:
   *
   * async <
   *   T
   * >() => {}
   *
   * in which case, removing the type parameters will cause a syntax error. Detect this case and
   * move the open-paren earlier.
   */
  processPossibleAsyncArrowWithTypeParams() {
    if (!this.tokens.matchesContextual(_keywords.ContextualKeyword._async) && !this.tokens.matches1(_types.TokenType._async)) {
      return false;
    }
    const nextToken = this.tokens.tokenAtRelativeIndex(1);
    if (nextToken.type !== _types.TokenType.lessThan || !nextToken.isType) {
      return false;
    }
    let nextNonTypeIndex = this.tokens.currentIndex() + 1;
    // Look ahead to see if this is an arrow function or something else.
    while (this.tokens.tokens[nextNonTypeIndex].isType) {
      nextNonTypeIndex++;
    }
    if (this.tokens.matches1AtIndex(nextNonTypeIndex, _types.TokenType.parenL)) {
      this.tokens.replaceToken("async (");
      this.tokens.removeInitialToken();
      while (this.tokens.currentIndex() < nextNonTypeIndex) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      // We ate a ( token, so we need to process the tokens in between and then the ) token so that
      // we remain balanced.
      this.processBalancedCode();
      this.processToken();
      return true;
    }
    return false;
  }
  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
      return true;
    }
    return false;
  }
}
exports.default = RootTransformer;
}),
/* --- node_modules/sucrase/dist/util/formatTokens.js --- */
"node_modules/sucrase/dist/util/formatTokens.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _linesandcolumns = _kame_require_("node_modules/lines-and-columns/build/index.js");
var _linesandcolumns2 = _interopRequireDefault(_linesandcolumns);
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
function formatTokens(code, tokens) {
  if (tokens.length === 0) {
    return "";
  }
  const tokenKeys = Object.keys(tokens[0]).filter(k => k !== "type" && k !== "value" && k !== "start" && k !== "end" && k !== "loc");
  const typeKeys = Object.keys(tokens[0].type).filter(k => k !== "label" && k !== "keyword");
  const headings = ["Location", "Label", "Raw", ...tokenKeys, ...typeKeys];
  const lines = new (0, _linesandcolumns2.default)(code);
  const rows = [headings, ...tokens.map(getTokenComponents)];
  const padding = headings.map(() => 0);
  for (const components of rows) {
    for (let i = 0; i < components.length; i++) {
      padding[i] = Math.max(padding[i], components[i].length);
    }
  }
  return rows.map(components => components.map((component, i) => component.padEnd(padding[i])).join(" ")).join("\n");
  function getTokenComponents(token) {
    const raw = code.slice(token.start, token.end);
    return [formatRange(token.start, token.end), _types.formatTokenType.call(void 0, token.type), truncate(String(raw), 14),
    // @ts-ignore: Intentional dynamic access by key.
    ...tokenKeys.map(key => formatValue(token[key], key)),
    // @ts-ignore: Intentional dynamic access by key.
    ...typeKeys.map(key => formatValue(token.type[key], key))];
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function formatValue(value, key) {
    if (value === true) {
      return key;
    } else if (value === false || value === null) {
      return "";
    } else {
      return String(value);
    }
  }
  function formatRange(start, end) {
    return `${formatPos(start)}-${formatPos(end)}`;
  }
  function formatPos(pos) {
    const location = lines.locationForIndex(pos);
    if (!location) {
      return "Unknown";
    } else {
      return `${location.line + 1}:${location.column + 1}`;
    }
  }
}
exports.default = formatTokens;
function truncate(s, length) {
  if (s.length > length) {
    return `${s.slice(0, length - 3)}...`;
  } else {
    return s;
  }
}
}),
/* --- node_modules/sucrase/dist/util/getTSImportedNames.js --- */
"node_modules/sucrase/dist/util/getTSImportedNames.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _getImportExportSpecifierInfo = _kame_require_("node_modules/sucrase/dist/util/getImportExportSpecifierInfo.js");
var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);

/**
 * Special case code to scan for imported names in ESM TypeScript. We need to do this so we can
 * properly get globals so we can compute shadowed globals.
 *
 * This is similar to logic in CJSImportProcessor, but trimmed down to avoid logic with CJS
 * replacement and flow type imports.
 */
function getTSImportedNames(tokens) {
  const importedNames = new Set();
  for (let i = 0; i < tokens.tokens.length; i++) {
    if (tokens.matches1AtIndex(i, _types.TokenType._import) && !tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {
      collectNamesForImport(tokens, i, importedNames);
    }
  }
  return importedNames;
}
exports.default = getTSImportedNames;
function collectNamesForImport(tokens, index, importedNames) {
  index++;
  if (tokens.matches1AtIndex(index, _types.TokenType.parenL)) {
    // Dynamic import, so nothing to do
    return;
  }
  if (tokens.matches1AtIndex(index, _types.TokenType.name)) {
    importedNames.add(tokens.identifierNameAtIndex(index));
    index++;
    if (tokens.matches1AtIndex(index, _types.TokenType.comma)) {
      index++;
    }
  }
  if (tokens.matches1AtIndex(index, _types.TokenType.star)) {
    // * as
    index += 2;
    importedNames.add(tokens.identifierNameAtIndex(index));
    index++;
  }
  if (tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
    index++;
    collectNamesForNamedImport(tokens, index, importedNames);
  }
}
function collectNamesForNamedImport(tokens, index, importedNames) {
  while (true) {
    if (tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
      return;
    }
    const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, tokens, index);
    index = specifierInfo.endIndex;
    if (!specifierInfo.isType) {
      importedNames.add(specifierInfo.rightName);
    }
    if (tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {
      return;
    } else if (tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
      return;
    } else if (tokens.matches1AtIndex(index, _types.TokenType.comma)) {
      index++;
    } else {
      throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`);
    }
  }
}
}),
/* --- node_modules/coffeescript/lib/coffeescript/coffeescript.js --- */
"node_modules/coffeescript/lib/coffeescript/coffeescript.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  // CoffeeScript can be used both on the server, as a command-line compiler based
  // on Node.js/V8, or to run CoffeeScript directly in the browser. This module
  // contains the main entry functions for tokenizing, parsing, and compiling
  // source CoffeeScript into JavaScript.
  var FILE_EXTENSIONS, Lexer, SourceMap, base64encode, checkShebangLine, compile, getSourceMap, helpers, lexer, packageJson, parser, registerCompiled, withPrettyErrors;
  ({
    Lexer
  } = _kame_require_("node_modules/coffeescript/lib/coffeescript/lexer.js"));
  ({
    parser
  } = _kame_require_("node_modules/coffeescript/lib/coffeescript/parser.js"));
  helpers = _kame_require_("node_modules/coffeescript/lib/coffeescript/helpers.js");
  SourceMap = _kame_require_("node_modules/coffeescript/lib/coffeescript/sourcemap.js");

  // Require `package.json`, which is two levels above this file, as this file is
  // evaluated from `lib/coffeescript`.
  packageJson = _kame_require_("node_modules/coffeescript/package.json");

  // The current CoffeeScript version number.
  exports.VERSION = packageJson.version;
  exports.FILE_EXTENSIONS = FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md'];

  // Expose helpers for testing.
  exports.helpers = helpers;
  ({
    getSourceMap,
    registerCompiled
  } = SourceMap);

  // This is exported to enable an external module to implement caching of
  // sourcemaps. This is used only when `patchStackTrace` has been called to adjust
  // stack traces for files with cached source maps.
  exports.registerCompiled = registerCompiled;

  // Function that allows for btoa in both nodejs and the browser.
  base64encode = function (src) {
    switch (false) {
      case typeof Buffer !== 'function':
        return Buffer.from(src).toString('base64');
      case typeof btoa !== 'function':
        // The contents of a `<script>` block are encoded via UTF-16, so if any extended
        // characters are used in the block, btoa will fail as it maxes out at UTF-8.
        // See https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem
        // for the gory details, and for the solution implemented here.
        return btoa(encodeURIComponent(src).replace(/%([0-9A-F]{2})/g, function (match, p1) {
          return String.fromCharCode('0x' + p1);
        }));
      default:
        throw new Error('Unable to base64 encode inline sourcemap.');
    }
  };

  // Function wrapper to add source file information to SyntaxErrors thrown by the
  // lexer/parser/compiler.
  withPrettyErrors = function (fn) {
    return function (code, options = {}) {
      var err;
      try {
        return fn.call(this, code, options);
      } catch (error) {
        err = error;
        if (typeof code !== 'string') {
          // Support `CoffeeScript.nodes(tokens)`.
          throw err;
        }
        throw helpers.updateSyntaxError(err, code, options.filename);
      }
    };
  };

  // Compile CoffeeScript code to JavaScript, using the Coffee/Jison compiler.

  // If `options.sourceMap` is specified, then `options.filename` must also be
  // specified. All options that can be passed to `SourceMap#generate` may also
  // be passed here.

  // This returns a javascript string, unless `options.sourceMap` is passed,
  // in which case this returns a `{js, v3SourceMap, sourceMap}`
  // object, where sourceMap is a sourcemap.coffee#SourceMap object, handy for
  // doing programmatic lookups.
  exports.compile = compile = withPrettyErrors(function (code, options = {}) {
    var ast, currentColumn, currentLine, encoded, filename, fragment, fragments, generateSourceMap, header, i, j, js, len, len1, map, newLines, nodes, range, ref, sourceCodeLastLine, sourceCodeNumberOfLines, sourceMapDataURI, sourceURL, token, tokens, transpiler, transpilerOptions, transpilerOutput, v3SourceMap;
    // Clone `options`, to avoid mutating the `options` object passed in.
    options = Object.assign({}, options);
    generateSourceMap = options.sourceMap || options.inlineMap || options.filename == null;
    filename = options.filename || helpers.anonymousFileName();
    checkShebangLine(filename, code);
    if (generateSourceMap) {
      map = new SourceMap();
    }
    tokens = lexer.tokenize(code, options);
    // Pass a list of referenced variables, so that generated variables wont get
    // the same name.
    options.referencedVars = function () {
      var i, len, results;
      results = [];
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        if (token[0] === 'IDENTIFIER') {
          results.push(token[1]);
        }
      }
      return results;
    }();
    // Check for import or export; if found, force bare mode.
    if (!(options.bare != null && options.bare === true)) {
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        if ((ref = token[0]) === 'IMPORT' || ref === 'EXPORT') {
          options.bare = true;
          break;
        }
      }
    }
    nodes = parser.parse(tokens);
    // If all that was requested was a POJO representation of the nodes, e.g.
    // the abstract syntax tree (AST), we can stop now and just return that
    // (after fixing the location data for the root/`File``Program` node,
    // which mightve gotten misaligned from the original source due to the
    // `clean` function in the lexer).
    if (options.ast) {
      nodes.allCommentTokens = helpers.extractAllCommentTokens(tokens);
      sourceCodeNumberOfLines = (code.match(/\r?\n/g) || '').length + 1;
      sourceCodeLastLine = /.*$/.exec(code)[0];
      ast = nodes.ast(options);
      range = [0, code.length];
      ast.start = ast.program.start = range[0];
      ast.end = ast.program.end = range[1];
      ast.range = ast.program.range = range;
      ast.loc.start = ast.program.loc.start = {
        line: 1,
        column: 0
      };
      ast.loc.end.line = ast.program.loc.end.line = sourceCodeNumberOfLines;
      ast.loc.end.column = ast.program.loc.end.column = sourceCodeLastLine.length;
      ast.tokens = tokens;
      return ast;
    }
    fragments = nodes.compileToFragments(options);
    currentLine = 0;
    if (options.header) {
      currentLine += 1;
    }
    if (options.shiftLine) {
      currentLine += 1;
    }
    currentColumn = 0;
    js = "";
    for (j = 0, len1 = fragments.length; j < len1; j++) {
      fragment = fragments[j];
      // Update the sourcemap with data from each fragment.
      if (generateSourceMap) {
        // Do not include empty, whitespace, or semicolon-only fragments.
        if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
            noReplace: true
          });
        }
        newLines = helpers.count(fragment.code, "\n");
        currentLine += newLines;
        if (newLines) {
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
        } else {
          currentColumn += fragment.code.length;
        }
      }
      // Copy the code from each fragment into the final JavaScript.
      js += fragment.code;
    }
    if (options.header) {
      header = `Generated by CoffeeScript ${this.VERSION}`;
      js = `// ${header}\n${js}`;
    }
    if (generateSourceMap) {
      v3SourceMap = map.generate(options, code);
    }
    if (options.transpile) {
      if (typeof options.transpile !== 'object') {
        // This only happens if run via the Node API and `transpile` is set to
        // something other than an object.
        throw new Error('The transpile option must be given an object with options to pass to Babel');
      }
      // Get the reference to Babel that we have been passed if this compiler
      // is run via the CLI or Node API.
      transpiler = options.transpile.transpile;
      delete options.transpile.transpile;
      transpilerOptions = Object.assign({}, options.transpile);
      // See https://github.com/babel/babel/issues/827#issuecomment-77573107:
      // Babel can take a v3 source map object as input in `inputSourceMap`
      // and it will return an *updated* v3 source map object in its output.
      if (v3SourceMap && transpilerOptions.inputSourceMap == null) {
        transpilerOptions.inputSourceMap = v3SourceMap;
      }
      transpilerOutput = transpiler(js, transpilerOptions);
      js = transpilerOutput.code;
      if (v3SourceMap && transpilerOutput.map) {
        v3SourceMap = transpilerOutput.map;
      }
    }
    if (options.inlineMap) {
      encoded = base64encode(JSON.stringify(v3SourceMap));
      sourceMapDataURI = `//# sourceMappingURL=data:application/json;base64,${encoded}`;
      sourceURL = `//# sourceURL=${filename}`;
      js = `${js}\n${sourceMapDataURI}\n${sourceURL}`;
    }
    registerCompiled(filename, code, map);
    if (options.sourceMap) {
      return {
        js,
        sourceMap: map,
        v3SourceMap: JSON.stringify(v3SourceMap, null, 2)
      };
    } else {
      return js;
    }
  });

  // Tokenize a string of CoffeeScript code, and return the array of tokens.
  exports.tokens = withPrettyErrors(function (code, options) {
    return lexer.tokenize(code, options);
  });

  // Parse a string of CoffeeScript code or an array of lexed tokens, and
  // return the AST. You can then compile it by calling `.compile()` on the root,
  // or traverse it by using `.traverseChildren()` with a callback.
  exports.nodes = withPrettyErrors(function (source, options) {
    if (typeof source === 'string') {
      source = lexer.tokenize(source, options);
    }
    return parser.parse(source);
  });

  // This file used to export these methods; leave stubs that throw warnings
  // instead. These methods have been moved into `index.coffee` to provide
  // separate entrypoints for Node and non-Node environments, so that static
  // analysis tools dont choke on Node packages when compiling for a non-Node
  // environment.
  exports.run = exports.eval = exports.register = function () {
    throw new Error('require index.coffee, not this file');
  };

  // Instantiate a Lexer for our use here.
  lexer = new Lexer();

  // The real Lexer produces a generic stream of tokens. This object provides a
  // thin wrapper around it, compatible with the Jison API. We can then pass it
  // directly as a Jison lexer.
  parser.lexer = {
    yylloc: {
      range: []
    },
    options: {
      ranges: true
    },
    lex: function () {
      var tag, token;
      token = parser.tokens[this.pos++];
      if (token) {
        [tag, this.yytext, this.yylloc] = token;
        parser.errorToken = token.origin || token;
        this.yylineno = this.yylloc.first_line;
      } else {
        tag = '';
      }
      return tag;
    },
    setInput: function (tokens) {
      parser.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function () {
      return '';
    }
  };

  // Make all the AST nodes visible to the parser.
  parser.yy = _kame_require_("node_modules/coffeescript/lib/coffeescript/nodes.js");

  // Override Jison's default error handling function.
  parser.yy.parseError = function (message, {
    token
  }) {
    var errorLoc, errorTag, errorText, errorToken, tokens;
    // Disregard Jison's message, it contains redundant line number information.
    // Disregard the token, we take its value directly from the lexer in case
    // the error is caused by a generated token which might refer to its origin.
    ({
      errorToken,
      tokens
    } = parser);
    [errorTag, errorText, errorLoc] = errorToken;
    errorText = function () {
      switch (false) {
        case errorToken !== tokens[tokens.length - 1]:
          return 'end of input';
        case errorTag !== 'INDENT' && errorTag !== 'OUTDENT':
          return 'indentation';
        case errorTag !== 'IDENTIFIER' && errorTag !== 'NUMBER' && errorTag !== 'INFINITY' && errorTag !== 'STRING' && errorTag !== 'STRING_START' && errorTag !== 'REGEX' && errorTag !== 'REGEX_START':
          return errorTag.replace(/_START$/, '').toLowerCase();
        default:
          return helpers.nameWhitespaceCharacter(errorText);
      }
    }();
    // The second argument has a `loc` property, which should have the location
    // data for this token. Unfortunately, Jison seems to send an outdated `loc`
    // (from the previous token), so we take the location information directly
    // from the lexer.
    return helpers.throwSyntaxError(`unexpected ${errorText}`, errorLoc);
  };
  exports.patchStackTrace = function () {
    var formatSourcePosition, getSourceMapping;
    // Based on http://v8.googlecode.com/svn/branches/bleeding_edge/src/messages.js
    // Modified to handle sourceMap
    formatSourcePosition = function (frame, getSourceMapping) {
      var as, column, fileLocation, filename, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
      filename = void 0;
      fileLocation = '';
      if (frame.isNative()) {
        fileLocation = "native";
      } else {
        if (frame.isEval()) {
          filename = frame.getScriptNameOrSourceURL();
          if (!filename) {
            fileLocation = `${frame.getEvalOrigin()}, `;
          }
        } else {
          filename = frame.getFileName();
        }
        filename || (filename = "<anonymous>");
        line = frame.getLineNumber();
        column = frame.getColumnNumber();
        // Check for a sourceMap position
        source = getSourceMapping(filename, line, column);
        fileLocation = source ? `${filename}:${source[0]}:${source[1]}` : `${filename}:${line}:${column}`;
      }
      functionName = frame.getFunctionName();
      isConstructor = frame.isConstructor();
      isMethodCall = !(frame.isToplevel() || isConstructor);
      if (isMethodCall) {
        methodName = frame.getMethodName();
        typeName = frame.getTypeName();
        if (functionName) {
          tp = as = '';
          if (typeName && functionName.indexOf(typeName)) {
            tp = `${typeName}.`;
          }
          if (methodName && functionName.indexOf(`.${methodName}`) !== functionName.length - methodName.length - 1) {
            as = ` [as ${methodName}]`;
          }
          return `${tp}${functionName}${as} (${fileLocation})`;
        } else {
          return `${typeName}.${methodName || '<anonymous>'} (${fileLocation})`;
        }
      } else if (isConstructor) {
        return `new ${functionName || '<anonymous>'} (${fileLocation})`;
      } else if (functionName) {
        return `${functionName} (${fileLocation})`;
      } else {
        return fileLocation;
      }
    };
    getSourceMapping = function (filename, line, column) {
      var answer, sourceMap;
      sourceMap = getSourceMap(filename, line, column);
      if (sourceMap != null) {
        answer = sourceMap.sourceLocation([line - 1, column - 1]);
      }
      if (answer != null) {
        return [answer[0] + 1, answer[1] + 1];
      } else {
        return null;
      }
    };
    // Based on [michaelficarra/CoffeeScriptRedux](http://goo.gl/ZTx1p)
    // NodeJS / V8 have no support for transforming positions in stack traces using
    // sourceMap, so we must monkey-patch Error to display CoffeeScript source
    // positions.
    return Error.prepareStackTrace = function (err, stack) {
      var frame, frames;
      frames = function () {
        var i, len, results;
        results = [];
        for (i = 0, len = stack.length; i < len; i++) {
          frame = stack[i];
          if (frame.getFunction() === exports.run) {
            // Dont display stack frames deeper than `CoffeeScript.run`.
            break;
          }
          results.push(`    at ${formatSourcePosition(frame, getSourceMapping)}`);
        }
        return results;
      }();
      return `${err.toString()}\n${frames.join('\n')}\n`;
    };
  };
  checkShebangLine = function (file, input) {
    var args, firstLine, ref, rest;
    firstLine = input.split(/$/m)[0];
    rest = firstLine != null ? firstLine.match(/^#!\s*([^\s]+\s*)(.*)/) : void 0;
    args = rest != null ? (ref = rest[2]) != null ? ref.split(/\s/).filter(function (s) {
      return s !== '';
    }) : void 0 : void 0;
    if ((args != null ? args.length : void 0) > 1) {
      console.error(`The script to be run begins with a shebang line with more than one
argument. This script will fail on platforms such as Linux which only
allow a single argument.`);
      console.error(`The shebang line was: '${firstLine}' in file '${file}'`);
      return console.error(`The arguments were: ${JSON.stringify(args)}`);
    }
  };
}).call(void 0);
}),
/* --- external:@babel/core --- */
"external:@babel/core": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
if (typeof require === "function") {
	module.exports = require("@babel/core");
} else if (typeof babelCore !== "undefined") {
	module.exports = babelCore;
} else if (typeof BabelCore !== "undefined") {
	module.exports = BabelCore;
} else {
	if ("production" !== "production") {
		console.warn("Failed to load external " + "@babel/core" + ". An empty module will be used instead, but this might cause problems in your code. Consider using a custom resolver to shim this external.");
	}
	module.exports = {};
}
}),
/* --- external:babel-core --- */
"external:babel-core": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
if (typeof require === "function") {
	module.exports = require("babel-core");
} else if (typeof babelCore !== "undefined") {
	module.exports = babelCore;
} else if (typeof BabelCore !== "undefined") {
	module.exports = BabelCore;
} else {
	if ("production" !== "production") {
		console.warn("Failed to load external " + "babel-core" + ". An empty module will be used instead, but this might cause problems in your code. Consider using a custom resolver to shim this external.");
	}
	module.exports = {};
}
}),
/* --- external:module --- */
"external:module": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
if (typeof require === "function") {
	module.exports = require("module");
} else if (typeof module !== "undefined") {
	module.exports = module;
} else if (typeof Module !== "undefined") {
	module.exports = Module;
} else {
	if ("production" !== "production") {
		console.warn("Failed to load external " + "module" + ". An empty module will be used instead, but this might cause problems in your code. Consider using a custom resolver to shim this external.");
	}
	module.exports = {};
}
}),
/* --- node_modules/coffeescript/lib/coffeescript/register.js --- */
"node_modules/coffeescript/lib/coffeescript/register.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  var CoffeeScript, Module, binary, cacheSourceMaps, child_process, ext, findExtension, fork, getRootModule, helpers, i, len, loadFile, nodeSourceMapsSupportEnabled, patchStackTrace, path, ref, ref1;
  CoffeeScript = _kame_require_("node_modules/coffeescript/lib/coffeescript/index.js");
  child_process = _kame_require_("external:child_process");
  helpers = _kame_require_("node_modules/coffeescript/lib/coffeescript/helpers.js");
  path = _kame_require_("src/kame-module-stub.js");
  ({
    patchStackTrace
  } = CoffeeScript);

  // Check if Node's built-in source map stack trace transformations are enabled.
  nodeSourceMapsSupportEnabled = typeof process !== "undefined" && process !== null && (process.execArgv.includes('--enable-source-maps') || ((ref = process.env.NODE_OPTIONS) != null ? ref.includes('--enable-source-maps') : void 0));
  if (!(Error.prepareStackTrace || nodeSourceMapsSupportEnabled)) {
    cacheSourceMaps = true;
    patchStackTrace();
  }

  // Load and run a CoffeeScript file for Node, stripping any `BOM`s.
  loadFile = function (module, filename) {
    var js, options;
    options = module.options || getRootModule(module).options || {};
    // Currently `CoffeeScript.compile` caches all source maps if present. They
    // are available in `getSourceMap` retrieved by `filename`.
    if (cacheSourceMaps || nodeSourceMapsSupportEnabled) {
      options.inlineMap = true;
    }
    js = CoffeeScript._compileFile(filename, options);
    return module._compile(js, filename);
  };

  // If the installed version of Node supports `require.extensions`, register
  // CoffeeScript as an extension.
  if (require.extensions) {
    ref1 = CoffeeScript.FILE_EXTENSIONS;
    for (i = 0, len = ref1.length; i < len; i++) {
      ext = ref1[i];
      require.extensions[ext] = loadFile;
    }
    // Patch Node's module loader to be able to handle multi-dot extensions.
    // This is a horrible thing that should not be required.
    Module = _kame_require_("external:module");
    findExtension = function (filename) {
      var curExtension, extensions;
      extensions = path.basename(filename).split('.');
      if (extensions[0] === '') {
        // Remove the initial dot from dotfiles.
        extensions.shift();
      }
      // Start with the longest possible extension and work our way shortwards.
      while (extensions.shift()) {
        curExtension = '.' + extensions.join('.');
        if (Module._extensions[curExtension]) {
          return curExtension;
        }
      }
      return '.js';
    };
    Module.prototype.load = function (filename) {
      var extension;
      this.filename = filename;
      this.paths = Module._nodeModulePaths(path.dirname(filename));
      extension = findExtension(filename);
      Module._extensions[extension](this, filename);
      return this.loaded = true;
    };
  }

  // If we're on Node, patch `child_process.fork` so that Coffee scripts are able
  // to fork both CoffeeScript files, and JavaScript files, directly.
  if (child_process) {
    ({
      fork
    } = child_process);
    binary = require.resolve('../../bin/coffee');
    child_process.fork = function (path, args, options) {
      if (helpers.isCoffee(path)) {
        if (!Array.isArray(args)) {
          options = args || {};
          args = [];
        }
        args = [path].concat(args);
        path = binary;
      }
      return fork(path, args, options);
    };
  }

  // Utility function to find the `options` object attached to the topmost module.
  getRootModule = function (module) {
    if (module.parent) {
      return getRootModule(module.parent);
    } else {
      return module;
    }
  };
}).call(void 0);
}),
/* --- node_modules/balanced-match/index.js --- */
"node_modules/balanced-match/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);
  var r = range(a, b, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}
function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}
balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}
}),
/* --- node_modules/yaml/dist/doc/directives.js --- */
"node_modules/yaml/dist/doc/directives.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var visit = _kame_require_("node_modules/yaml/dist/visit.js");
const escapeChars = {
  '!': '%21',
  ',': '%2C',
  '[': '%5B',
  ']': '%5D',
  '{': '%7B',
  '}': '%7D'
};
const escapeTagName = tn => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
  constructor(yaml, tags) {
    /**
     * The directives-end/doc-start marker `---`. If `null`, a marker may still be
     * included in the document's stringified representation.
     */
    this.docStart = null;
    /** The doc-end marker `...`.  */
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case '1.1':
        this.atNextDocument = true;
        break;
      case '1.2':
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: '1.2'
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = {
        explicit: Directives.defaultYaml.explicit,
        version: '1.1'
      };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case '%TAG':
        {
          if (parts.length !== 2) {
            onError(0, '%TAG directive should contain exactly two parts');
            if (parts.length < 2) return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
      case '%YAML':
        {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, '%YAML directive should contain exactly one part');
            return false;
          }
          const [version] = parts;
          if (version === '1.1' || version === '1.2') {
            this.yaml.version = version;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid);
            return false;
          }
        }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === '!') return '!'; // non-specific tag
    if (source[0] !== '!') {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === '<') {
      const verbatim = source.slice(2, -1);
      if (verbatim === '!' || verbatim === '!!') {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== '>') onError('Verbatim tags must end with a >');
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix) onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) return prefix + decodeURIComponent(suffix);
    if (handle === '!') return source; // local tag
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix)) return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === '!' ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || '1.2'}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {
      const tags = {};
      visit.visit(doc.contents, (_key, node) => {
        if (Node.isNode(node) && node.tag) tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === '!!' && prefix === 'tag:yaml.org,2002:') continue;
      if (!doc || tagNames.some(tn => tn.startsWith(prefix))) lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join('\n');
  }
}
Directives.defaultYaml = {
  explicit: false,
  version: '1.2'
};
Directives.defaultTags = {
  '!!': 'tag:yaml.org,2002:'
};
exports.Directives = Directives;
}),
/* --- node_modules/yaml/dist/compose/compose-doc.js --- */
"node_modules/yaml/dist/compose/compose-doc.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Document = _kame_require_("node_modules/yaml/dist/doc/Document.js");
var composeNode = _kame_require_("node_modules/yaml/dist/compose/compose-node.js");
var resolveEnd = _kame_require_("node_modules/yaml/dist/compose/resolve-end.js");
var resolveProps = _kame_require_("node_modules/yaml/dist/compose/resolve-props.js");
function composeDoc(options, directives, {
  offset,
  start,
  value,
  end
}, onError) {
  const opts = Object.assign({
    _directives: directives
  }, options);
  const doc = new Document.Document(undefined, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps.resolveProps(start, {
    indicator: 'doc-start',
    next: value ?? (end === null || end === void 0 ? void 0 : end[0]),
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === 'block-map' || value.type === 'block-seq') && !props.hasNewline) onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
  }
  doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
  if (re.comment) doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}
exports.composeDoc = composeDoc;
}),
/* --- node_modules/yaml/dist/compose/resolve-end.js --- */
"node_modules/yaml/dist/compose/resolve-end.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

function resolveEnd(end, offset, reqSpace, onError) {
  let comment = '';
  if (end) {
    let hasSpace = false;
    let sep = '';
    for (const token of end) {
      const {
        source,
        type
      } = token;
      switch (type) {
        case 'space':
          hasSpace = true;
          break;
        case 'comment':
          {
            if (reqSpace && !hasSpace) onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
            const cb = source.substring(1) || ' ';
            if (!comment) comment = cb;else comment += sep + cb;
            sep = '';
            break;
          }
        case 'newline':
          if (comment) sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return {
    comment,
    offset
  };
}
exports.resolveEnd = resolveEnd;
}),
/* --- node_modules/yaml/dist/nodes/Collection.js --- */
"node_modules/yaml/dist/nodes/Collection.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var createNode = _kame_require_("node_modules/yaml/dist/doc/createNode.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
function collectionFromPath(schema, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = new Map([[k, v]]);
    }
  }
  return createNode.createNode(v, undefined, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error('This should not happen, please report a bug.');
    },
    schema,
    sourceObjects: new Map()
  });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = path => path == null || typeof path === 'object' && !!path[Symbol.iterator]().next().done;
class Collection extends Node.NodeBase {
  constructor(type, schema) {
    super(type);
    Object.defineProperty(this, 'schema', {
      value: schema,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema) copy.schema = schema;
    copy.items = copy.items.map(it => Node.isNode(it) || Node.isPair(it) ? it.clone(schema) : it);
    if (this.range) copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path)) this.add(value);else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (Node.isCollection(node)) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0) return this.delete(key);
    const node = this.get(key, true);
    if (Node.isCollection(node)) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0) return !keepScalar && Node.isScalar(node) ? node.value : node;else return Node.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every(node => {
      if (!Node.isPair(node)) return false;
      const n = node.value;
      return n == null || allowScalar && Node.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0) return this.has(key);
    const node = this.get(key, true);
    return Node.isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (Node.isCollection(node)) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
}
Collection.maxFlowStringSingleLineLength = 60;
exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;
}),
/* --- node_modules/yaml/dist/nodes/toJS.js --- */
"node_modules/yaml/dist/nodes/toJS.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  if (Array.isArray(value)) return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === 'function') {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    if (!ctx || !Node.hasAnchor(value)) return value.toJSON(arg, ctx);
    const data = {
      aliasCount: 0,
      count: 1,
      res: undefined
    };
    ctx.anchors.set(value, data);
    ctx.onCreate = res => {
      data.res = res;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate) ctx.onCreate(res);
    return res;
  }
  if (typeof value === 'bigint' && !(ctx !== null && ctx !== void 0 && ctx.keep)) return Number(value);
  return value;
}
exports.toJS = toJS;
}),
/* --- node_modules/yaml/dist/stringify/stringify.js --- */
"node_modules/yaml/dist/stringify/stringify.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var anchors = _kame_require_("node_modules/yaml/dist/doc/anchors.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var stringifyComment = _kame_require_("node_modules/yaml/dist/stringify/stringifyComment.js");
var stringifyString = _kame_require_("node_modules/yaml/dist/stringify/stringifyString.js");
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment.stringifyComment,
    defaultKeyType: null,
    defaultStringType: 'PLAIN',
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: 'false',
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: 'null',
    simpleKeys: false,
    singleQuote: null,
    trueStr: 'true',
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case 'block':
      inFlow = false;
      break;
    case 'flow':
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: new Set(),
    doc,
    indent: '',
    indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter(t => t.tag === item.tag);
    if (match.length > 0) return match.find(t => t.format === item.format) ?? match[0];
  }
  let tagObj = undefined;
  let obj;
  if (Node.isScalar(item)) {
    obj = item.value;
    const match = tags.filter(t => {
      var _t$identify;
      return (_t$identify = t.identify) === null || _t$identify === void 0 ? void 0 : _t$identify.call(t, obj);
    });
    tagObj = match.find(t => t.format === item.format) ?? match.find(t => !t.format);
  } else {
    obj = item;
    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    var _obj, _obj$constructor;
    const name = ((_obj = obj) === null || _obj === void 0 ? void 0 : (_obj$constructor = _obj.constructor) === null || _obj$constructor === void 0 ? void 0 : _obj$constructor.name) ?? typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, {
  anchors: anchors$1,
  doc
}) {
  if (!doc.directives) return '';
  const props = [];
  const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;
  if (anchor && anchors.anchorIsValid(anchor)) {
    anchors$1.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag) props.push(doc.directives.tagString(tag));
  return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
  if (Node.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
  if (Node.isAlias(item)) {
    var _ctx$resolvedAliases;
    if (ctx.doc.directives) return item.toString(ctx);
    if ((_ctx$resolvedAliases = ctx.resolvedAliases) !== null && _ctx$resolvedAliases !== void 0 && _ctx$resolvedAliases.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);else ctx.resolvedAliases = new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = undefined;
  const node = Node.isNode(item) ? item : ctx.doc.createNode(item, {
    onTagObj: o => tagObj = o
  });
  if (!tagObj) tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(node, ctx, onComment, onChompKeep) : Node.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props) return str;
  return Node.isScalar(node) || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
}
exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;
}),
/* --- node_modules/yaml/dist/stringify/stringifyDocument.js --- */
"node_modules/yaml/dist/stringify/stringifyDocument.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var stringify = _kame_require_("node_modules/yaml/dist/stringify/stringify.js");
var stringifyComment = _kame_require_("node_modules/yaml/dist/stringify/stringifyComment.js");
function stringifyDocument(doc, options) {
  var _doc$directives;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart) hasDirectives = true;
  }
  if (hasDirectives) lines.push('---');
  const ctx = stringify.createStringifyContext(doc, options);
  const {
    commentString
  } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1) lines.unshift('');
    const cs = commentString(doc.commentBefore);
    lines.unshift(stringifyComment.indentComment(cs, ''));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (Node.isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives) lines.push('');
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(stringifyComment.indentComment(cs, ''));
      }
      // top-level block scalars need to be indented if followed by a comment
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? undefined : () => chompKeep = true;
    let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment) body += stringifyComment.lineComment(body, '', commentString(contentComment));
    if ((body[0] === '|' || body[0] === '>') && lines[lines.length - 1] === '---') {
      // Top-level block scalars with a preceding doc marker ought to use the
      // same line for their header.
      lines[lines.length - 1] = `--- ${body}`;
    } else lines.push(body);
  } else {
    lines.push(stringify.stringify(doc.contents, ctx));
  }
  if ((_doc$directives = doc.directives) !== null && _doc$directives !== void 0 && _doc$directives.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes('\n')) {
        lines.push('...');
        lines.push(stringifyComment.indentComment(cs, ''));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push('...');
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep) dc = dc.replace(/^\n+/, '');
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
      lines.push(stringifyComment.indentComment(commentString(dc), ''));
    }
  }
  return lines.join('\n') + '\n';
}
exports.stringifyDocument = stringifyDocument;
}),
/* --- node_modules/yaml/dist/doc/anchors.js --- */
"node_modules/yaml/dist/doc/anchors.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var visit = _kame_require_("node_modules/yaml/dist/visit.js");

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = new Set();
  visit.visit(root, {
    Value(_key, node) {
      if (node.anchor) anchors.add(node.anchor);
    }
  });
  return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name)) return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = new Map();
  let prevAnchors = null;
  return {
    onAnchor: source => {
      aliasObjects.push(source);
      if (!prevAnchors) prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === 'object' && ref.anchor && (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error('Failed to resolve repeated object (this should not happen)');
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}
exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;
}),
/* --- node_modules/yaml/dist/doc/applyReviver.js --- */
"node_modules/yaml/dist/doc/applyReviver.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === 'object') {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === undefined) delete val[i];else if (v1 !== v0) val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === undefined) val.delete(k);else if (v1 !== v0) val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === undefined) val.delete(v0);else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === undefined) delete val[k];else if (v1 !== v0) val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
exports.applyReviver = applyReviver;
}),
/* --- node_modules/yaml/dist/doc/createNode.js --- */
"node_modules/yaml/dist/doc/createNode.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Alias = _kame_require_("node_modules/yaml/dist/nodes/Alias.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter(t => t.tag === tagName);
    const tagObj = match.find(t => !t.format) ?? match[0];
    if (!tagObj) throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find(t => {
    var _t$identify;
    return ((_t$identify = t.identify) === null || _t$identify === void 0 ? void 0 : _t$identify.call(t, value)) && !t.format;
  });
}
function createNode(value, tagName, ctx) {
  var _tagName, _tagObj;
  if (Node.isDocument(value)) value = value.contents;
  if (Node.isNode(value)) return value;
  if (Node.isPair(value)) {
    var _ctx$schema$Node$MAP$, _ctx$schema$Node$MAP;
    const map = (_ctx$schema$Node$MAP$ = (_ctx$schema$Node$MAP = ctx.schema[Node.MAP]).createNode) === null || _ctx$schema$Node$MAP$ === void 0 ? void 0 : _ctx$schema$Node$MAP$.call(_ctx$schema$Node$MAP, ctx.schema, null, ctx);
    map.items.push(value);
    return map;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== 'undefined' && value instanceof BigInt // not supported everywhere
  ) {
    // https://tc39.es/ecma262/#sec-serializejsonproperty
    value = value.valueOf();
  }
  const {
    aliasDuplicateObjects,
    onAnchor,
    onTagObj,
    schema,
    sourceObjects
  } = ctx;
  // Detect duplicate references to the same object & use Alias nodes for all
  // after first. The `ref` wrapper allows for circular references to resolve.
  let ref = undefined;
  if (aliasDuplicateObjects && value && typeof value === 'object') {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor) ref.anchor = onAnchor(value);
      return new Alias.Alias(ref.anchor);
    } else {
      ref = {
        anchor: null,
        node: null
      };
      sourceObjects.set(value, ref);
    }
  }
  if ((_tagName = tagName) !== null && _tagName !== void 0 && _tagName.startsWith('!!')) tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === 'function') {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      value = value.toJSON();
    }
    if (!value || typeof value !== 'object') {
      const node = new Scalar.Scalar(value);
      if (ref) ref.node = node;
      return node;
    }
    tagObj = value instanceof Map ? schema[Node.MAP] : Symbol.iterator in Object(value) ? schema[Node.SEQ] : schema[Node.MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (_tagObj = tagObj) !== null && _tagObj !== void 0 && _tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar.Scalar(value);
  if (tagName) node.tag = tagName;
  if (ref) ref.node = node;
  return node;
}
exports.createNode = createNode;
}),
/* --- node_modules/yaml/dist/schema/common/map.js --- */
"node_modules/yaml/dist/schema/common/map.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Pair = _kame_require_("node_modules/yaml/dist/nodes/Pair.js");
var YAMLMap = _kame_require_("node_modules/yaml/dist/nodes/YAMLMap.js");
function createMap(schema, obj, ctx) {
  const {
    keepUndefined,
    replacer
  } = ctx;
  const map = new YAMLMap.YAMLMap(schema);
  const add = (key, value) => {
    if (typeof replacer === 'function') value = replacer.call(obj, key, value);else if (Array.isArray(replacer) && !replacer.includes(key)) return;
    if (value !== undefined || keepUndefined) map.items.push(Pair.createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj) add(key, value);
  } else if (obj && typeof obj === 'object') {
    for (const key of Object.keys(obj)) add(key, obj[key]);
  }
  if (typeof schema.sortMapEntries === 'function') {
    map.items.sort(schema.sortMapEntries);
  }
  return map;
}
const map = {
  collection: 'map',
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap.YAMLMap,
  tag: 'tag:yaml.org,2002:map',
  resolve(map, onError) {
    if (!Node.isMap(map)) onError('Expected a mapping for this tag');
    return map;
  }
};
exports.map = map;
}),
/* --- node_modules/yaml/dist/schema/common/seq.js --- */
"node_modules/yaml/dist/schema/common/seq.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var createNode = _kame_require_("node_modules/yaml/dist/doc/createNode.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var YAMLSeq = _kame_require_("node_modules/yaml/dist/nodes/YAMLSeq.js");
function createSeq(schema, obj, ctx) {
  const {
    replacer
  } = ctx;
  const seq = new YAMLSeq.YAMLSeq(schema);
  if (obj && Symbol.iterator in Object(obj)) {
    let i = 0;
    for (let it of obj) {
      if (typeof replacer === 'function') {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key, it);
      }
      seq.items.push(createNode.createNode(it, undefined, ctx));
    }
  }
  return seq;
}
const seq = {
  collection: 'seq',
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq.YAMLSeq,
  tag: 'tag:yaml.org,2002:seq',
  resolve(seq, onError) {
    if (!Node.isSeq(seq)) onError('Expected a sequence for this tag');
    return seq;
  }
};
exports.seq = seq;
}),
/* --- node_modules/yaml/dist/schema/common/string.js --- */
"node_modules/yaml/dist/schema/common/string.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var stringifyString = _kame_require_("node_modules/yaml/dist/stringify/stringifyString.js");
const string = {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: str => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({
      actualString: true
    }, ctx);
    return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
  }
};
exports.string = string;
}),
/* --- node_modules/yaml/dist/schema/tags.js --- */
"node_modules/yaml/dist/schema/tags.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var map = _kame_require_("node_modules/yaml/dist/schema/common/map.js");
var _null = _kame_require_("node_modules/yaml/dist/schema/common/null.js");
var seq = _kame_require_("node_modules/yaml/dist/schema/common/seq.js");
var string = _kame_require_("node_modules/yaml/dist/schema/common/string.js");
var bool = _kame_require_("node_modules/yaml/dist/schema/core/bool.js");
var float = _kame_require_("node_modules/yaml/dist/schema/core/float.js");
var int = _kame_require_("node_modules/yaml/dist/schema/core/int.js");
var schema = _kame_require_("node_modules/yaml/dist/schema/core/schema.js");
var schema$1 = _kame_require_("node_modules/yaml/dist/schema/json/schema.js");
var binary = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/binary.js");
var omap = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/omap.js");
var pairs = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/pairs.js");
var schema$2 = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/schema.js");
var set = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/set.js");
var timestamp = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/timestamp.js");
const schemas = new Map([['core', schema.schema], ['failsafe', [map.map, seq.seq, string.string]], ['json', schema$1.schema], ['yaml11', schema$2.schema], ['yaml-1.1', schema$2.schema]]);
const tagsByName = {
  binary: binary.binary,
  bool: bool.boolTag,
  float: float.float,
  floatExp: float.floatExp,
  floatNaN: float.floatNaN,
  floatTime: timestamp.floatTime,
  int: int.int,
  intHex: int.intHex,
  intOct: int.intOct,
  intTime: timestamp.intTime,
  map: map.map,
  null: _null.nullTag,
  omap: omap.omap,
  pairs: pairs.pairs,
  seq: seq.seq,
  set: set.set,
  timestamp: timestamp.timestamp
};
const coreKnownTags = {
  'tag:yaml.org,2002:binary': binary.binary,
  'tag:yaml.org,2002:omap': omap.omap,
  'tag:yaml.org,2002:pairs': pairs.pairs,
  'tag:yaml.org,2002:set': set.set,
  'tag:yaml.org,2002:timestamp': timestamp.timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags)) tags = [];else {
      const keys = Array.from(schemas.keys()).filter(key => key !== 'yaml11').map(key => JSON.stringify(key)).join(', ');
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags) tags = tags.concat(tag);
  } else if (typeof customTags === 'function') {
    tags = customTags(tags.slice());
  }
  return tags.map(tag => {
    if (typeof tag !== 'string') return tag;
    const tagObj = tagsByName[tag];
    if (tagObj) return tagObj;
    const keys = Object.keys(tagsByName).map(key => JSON.stringify(key)).join(', ');
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}
exports.coreKnownTags = coreKnownTags;
exports.getTags = getTags;
}),
/* --- node_modules/yaml/dist/stringify/stringifyPair.js --- */
"node_modules/yaml/dist/stringify/stringifyPair.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var stringify = _kame_require_("node_modules/yaml/dist/stringify/stringify.js");
var stringifyComment = _kame_require_("node_modules/yaml/dist/stringify/stringifyComment.js");
function stringifyPair({
  key,
  value
}, ctx, onComment, onChompKeep) {
  const {
    allNullValues,
    doc,
    indent,
    indentStep,
    options: {
      commentString,
      indentSeq,
      simpleKeys
    }
  } = ctx;
  let keyComment = Node.isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error('With simple keys, key nodes cannot have comments');
    }
    if (Node.isCollection(key)) {
      const msg = 'With simple keys, collection cannot be used as a key value';
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || Node.isCollection(key) || (Node.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === 'object'));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment) onComment();
      return str === '' ? '?' : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep) onChompKeep();
    return str;
  }
  if (keyCommentDone) keyComment = null;
  if (explicitKey) {
    if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}\n${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = '';
  let valueComment = null;
  if (Node.isNode(value)) {
    if (value.spaceBefore) vcb = '\n';
    if (value.commentBefore) {
      const cs = commentString(value.commentBefore);
      vcb += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
    }
    valueComment = value.comment;
  } else if (value && typeof value === 'object') {
    value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && Node.isScalar(value)) ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && Node.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    // If indentSeq === false, consider '- ' as part of indentation where possible
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = ' ';
  if (vcb || keyComment) {
    if (valueStr === '' && !ctx.inFlow) ws = vcb === '\n' ? '\n\n' : vcb;else ws = `${vcb}\n${ctx.indent}`;
  } else if (!explicitKey && Node.isCollection(value)) {
    const flow = valueStr[0] === '[' || valueStr[0] === '{';
    if (!flow || valueStr.includes('\n')) ws = `\n${ctx.indent}`;
  } else if (valueStr === '' || valueStr[0] === '\n') ws = '';
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment) onComment();
  } else if (valueComment && !valueCommentDone) {
    str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
exports.stringifyPair = stringifyPair;
}),
/* --- node_modules/yaml/dist/nodes/addPairToJSMap.js --- */
"node_modules/yaml/dist/nodes/addPairToJSMap.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var log = _kame_require_("node_modules/yaml/dist/log.js");
var stringify = _kame_require_("node_modules/yaml/dist/stringify/stringify.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var toJS = _kame_require_("node_modules/yaml/dist/nodes/toJS.js");
const MERGE_KEY = '<<';
function addPairToJSMap(ctx, map, {
  key,
  value
}) {
  if (ctx !== null && ctx !== void 0 && ctx.doc.schema.merge && isMergeKey(key)) {
    value = Node.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (Node.isSeq(value)) for (const it of value.items) mergeToJSMap(ctx, map, it);else if (Array.isArray(value)) for (const it of value) mergeToJSMap(ctx, map, it);else mergeToJSMap(ctx, map, value);
  } else {
    const jsKey = toJS.toJS(key, '', ctx);
    if (map instanceof Map) {
      map.set(jsKey, toJS.toJS(value, jsKey, ctx));
    } else if (map instanceof Set) {
      map.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS.toJS(value, stringKey, ctx);
      if (stringKey in map) Object.defineProperty(map, stringKey, {
        value: jsValue,
        writable: true,
        enumerable: true,
        configurable: true
      });else map[stringKey] = jsValue;
    }
  }
  return map;
}
const isMergeKey = key => key === MERGE_KEY || Node.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function mergeToJSMap(ctx, map, value) {
  const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!Node.isMap(source)) throw new Error('Merge sources must be maps or map aliases');
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value] of srcMap) {
    if (map instanceof Map) {
      if (!map.has(key)) map.set(key, value);
    } else if (map instanceof Set) {
      map.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
      Object.defineProperty(map, key, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null) return '';
  if (typeof jsKey !== 'object') return String(jsKey);
  if (Node.isNode(key) && ctx && ctx.doc) {
    const strCtx = stringify.createStringifyContext(ctx.doc, {});
    strCtx.anchors = new Set();
    for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '..."';
      log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
exports.addPairToJSMap = addPairToJSMap;
}),
/* --- node_modules/yaml/dist/stringify/stringifyCollection.js --- */
"node_modules/yaml/dist/stringify/stringifyCollection.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Collection = _kame_require_("node_modules/yaml/dist/nodes/Collection.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var stringify = _kame_require_("node_modules/yaml/dist/stringify/stringify.js");
var stringifyComment = _kame_require_("node_modules/yaml/dist/stringify/stringifyComment.js");
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify(collection, ctx, options);
}
function stringifyBlockCollection({
  comment,
  items
}, ctx, {
  blockItemPrefix,
  flowChars,
  itemIndent,
  onChompKeep,
  onComment
}) {
  const {
    indent,
    options: {
      commentString
    }
  } = ctx;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    type: null
  });
  let chompKeep = false; // flag for the preceding node's status
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (Node.isNode(item)) {
      if (!chompKeep && item.spaceBefore) lines.push('');
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment) comment = item.comment;
    } else if (Node.isPair(item)) {
      const ik = Node.isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore) lines.push('');
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str = stringify.stringify(item, itemCtx, () => comment = null, () => chompKeep = true);
    if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
    if (chompKeep && comment) chompKeep = false;
    lines.push(blockItemPrefix + str);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `\n${indent}${line}` : '\n';
    }
  }
  if (comment) {
    str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
    if (onComment) onComment();
  } else if (chompKeep && onChompKeep) onChompKeep();
  return str;
}
function stringifyFlowCollection({
  comment,
  items
}, ctx, {
  flowChars,
  itemIndent,
  onComment
}) {
  const {
    indent,
    indentStep,
    options: {
      commentString
    }
  } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (Node.isNode(item)) {
      if (item.spaceBefore) lines.push('');
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment) comment = item.comment;
    } else if (Node.isPair(item)) {
      const ik = Node.isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore) lines.push('');
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment) reqNewline = true;
      }
      const iv = Node.isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment) comment = iv.comment;
        if (iv.commentBefore) reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment = ik.comment;
      }
    }
    if (comment) reqNewline = true;
    let str = stringify.stringify(item, itemCtx, () => comment = null);
    if (i < items.length - 1) str += ',';
    if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes('\n'))) reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  let str;
  const {
    start,
    end
  } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines) str += line ? `\n${indentStep}${indent}${line}` : '\n';
      str += `\n${indent}${end}`;
    } else {
      str = `${start} ${lines.join(' ')} ${end}`;
    }
  }
  if (comment) {
    str += stringifyComment.lineComment(str, commentString(comment), indent);
    if (onComment) onComment();
  }
  return str;
}
function addCommentBefore({
  indent,
  options: {
    commentString
  }
}, lines, comment, chompKeep) {
  if (comment && chompKeep) comment = comment.replace(/^\n+/, '');
  if (comment) {
    const ic = stringifyComment.indentComment(commentString(comment), indent);
    lines.push(ic.trimStart()); // Avoid double indent on first line
  }
}

exports.stringifyCollection = stringifyCollection;
}),
/* --- node_modules/yaml/dist/parse/cst-scalar.js --- */
"node_modules/yaml/dist/parse/cst-scalar.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var resolveBlockScalar = _kame_require_("node_modules/yaml/dist/compose/resolve-block-scalar.js");
var resolveFlowScalar = _kame_require_("node_modules/yaml/dist/compose/resolve-flow-scalar.js");
var errors = _kame_require_("node_modules/yaml/dist/errors.js");
var stringifyString = _kame_require_("node_modules/yaml/dist/stringify/stringifyString.js");
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError) onError(offset, code, message);else throw new errors.YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case 'scalar':
      case 'single-quoted-scalar':
      case 'double-quoted-scalar':
        return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
      case 'block-scalar':
        return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
  const {
    implicitKey = false,
    indent,
    inFlow = false,
    offset = -1,
    type = 'PLAIN'
  } = context;
  const source = stringifyString.stringifyString({
    type,
    value
  }, {
    implicitKey,
    indent: indent > 0 ? ' '.repeat(indent) : '',
    inFlow,
    options: {
      blockQuote: true,
      lineWidth: -1
    }
  });
  const end = context.end ?? [{
    type: 'newline',
    offset: -1,
    indent,
    source: '\n'
  }];
  switch (source[0]) {
    case '|':
    case '>':
      {
        const he = source.indexOf('\n');
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + '\n';
        const props = [{
          type: 'block-scalar-header',
          offset,
          indent,
          source: head
        }];
        if (!addEndtoBlockProps(props, end)) props.push({
          type: 'newline',
          offset: -1,
          indent,
          source: '\n'
        });
        return {
          type: 'block-scalar',
          offset,
          indent,
          props,
          source: body
        };
      }
    case '"':
      return {
        type: 'double-quoted-scalar',
        offset,
        indent,
        source,
        end
      };
    case "'":
      return {
        type: 'single-quoted-scalar',
        offset,
        indent,
        source,
        end
      };
    default:
      return {
        type: 'scalar',
        offset,
        indent,
        source,
        end
      };
  }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
  let {
    afterKey = false,
    implicitKey = false,
    inFlow = false,
    type
  } = context;
  let indent = 'indent' in token ? token.indent : null;
  if (afterKey && typeof indent === 'number') indent += 2;
  if (!type) switch (token.type) {
    case 'single-quoted-scalar':
      type = 'QUOTE_SINGLE';
      break;
    case 'double-quoted-scalar':
      type = 'QUOTE_DOUBLE';
      break;
    case 'block-scalar':
      {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');
        type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
        break;
      }
    default:
      type = 'PLAIN';
  }
  const source = stringifyString.stringifyString({
    type,
    value
  }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
    inFlow,
    options: {
      blockQuote: true,
      lineWidth: -1
    }
  });
  switch (source[0]) {
    case '|':
    case '>':
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, 'double-quoted-scalar');
      break;
    case "'":
      setFlowScalarValue(token, source, 'single-quoted-scalar');
      break;
    default:
      setFlowScalarValue(token, source, 'scalar');
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf('\n');
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + '\n';
  if (token.type === 'block-scalar') {
    const header = token.props[0];
    if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');
    header.source = head;
    token.source = body;
  } else {
    const {
      offset
    } = token;
    const indent = 'indent' in token ? token.indent : -1;
    const props = [{
      type: 'block-scalar-header',
      offset,
      indent,
      source: head
    }];
    if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined)) props.push({
      type: 'newline',
      offset: -1,
      indent,
      source: '\n'
    });
    for (const key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];
    Object.assign(token, {
      type: 'block-scalar',
      indent,
      props,
      source: body
    });
  }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
  if (end) for (const st of end) switch (st.type) {
    case 'space':
    case 'comment':
      props.push(st);
      break;
    case 'newline':
      props.push(st);
      return true;
  }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case 'scalar':
    case 'double-quoted-scalar':
    case 'single-quoted-scalar':
      token.type = type;
      token.source = source;
      break;
    case 'block-scalar':
      {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === 'block-scalar-header') oa -= token.props[0].source.length;
        for (const tok of end) tok.offset += oa;
        delete token.props;
        Object.assign(token, {
          type,
          source,
          end
        });
        break;
      }
    case 'block-map':
    case 'block-seq':
      {
        const offset = token.offset + source.length;
        const nl = {
          type: 'newline',
          offset,
          indent: token.indent,
          source: '\n'
        };
        delete token.items;
        Object.assign(token, {
          type,
          source,
          end: [nl]
        });
        break;
      }
    default:
      {
        const indent = 'indent' in token ? token.indent : -1;
        const end = 'end' in token && Array.isArray(token.end) ? token.end.filter(st => st.type === 'space' || st.type === 'comment' || st.type === 'newline') : [];
        for (const key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];
        Object.assign(token, {
          type,
          indent,
          source,
          end
        });
      }
  }
}
exports.createScalarToken = createScalarToken;
exports.resolveAsScalar = resolveAsScalar;
exports.setScalarValue = setScalarValue;
}),
/* --- node_modules/yaml/dist/parse/cst-stringify.js --- */
"node_modules/yaml/dist/parse/cst-stringify.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify = cst => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
  switch (token.type) {
    case 'block-scalar':
      {
        let res = '';
        for (const tok of token.props) res += stringifyToken(tok);
        return res + token.source;
      }
    case 'block-map':
    case 'block-seq':
      {
        let res = '';
        for (const item of token.items) res += stringifyItem(item);
        return res;
      }
    case 'flow-collection':
      {
        let res = token.start.source;
        for (const item of token.items) res += stringifyItem(item);
        for (const st of token.end) res += st.source;
        return res;
      }
    case 'document':
      {
        let res = stringifyItem(token);
        if (token.end) for (const st of token.end) res += st.source;
        return res;
      }
    default:
      {
        let res = token.source;
        if ('end' in token && token.end) for (const st of token.end) res += st.source;
        return res;
      }
  }
}
function stringifyItem({
  start,
  key,
  sep,
  value
}) {
  let res = '';
  for (const st of start) res += st.source;
  if (key) res += stringifyToken(key);
  if (sep) for (const st of sep) res += st.source;
  if (value) res += stringifyToken(value);
  return res;
}
exports.stringify = stringify;
}),
/* --- node_modules/yaml/dist/parse/cst-visit.js --- */
"node_modules/yaml/dist/parse/cst-visit.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]`  Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null`  Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]`  Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token`  The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
  if ('type' in cst && cst.type === 'document') cst = {
    start: cst.start,
    value: cst.value
  };
  _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    var _item;
    const tok = (_item = item) === null || _item === void 0 ? void 0 : _item[field];
    if (tok && 'items' in tok) {
      item = tok.items[index];
    } else return undefined;
  }
  return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
  const parent = visit.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent === null || parent === void 0 ? void 0 : parent[field];
  if (coll && 'items' in coll) return coll;
  throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === 'symbol') return ctrl;
  for (const field of ['key', 'value']) {
    const token = item[field];
    if (token && 'items' in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === 'number') i = ci - 1;else if (ci === BREAK) return BREAK;else if (ci === REMOVE) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === 'function' && field === 'key') ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}
exports.visit = visit;
}),
/* --- node_modules/yaml/dist/log.js --- */
"node_modules/yaml/dist/log.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

function debug(logLevel, ...messages) {
  if (logLevel === 'debug') console.log(...messages);
}
function warn(logLevel, warning) {
  if (logLevel === 'debug' || logLevel === 'warn') {
    if (typeof process !== 'undefined' && process.emitWarning) process.emitWarning(warning);else console.warn(warning);
  }
}
exports.debug = debug;
exports.warn = warn;
}),
/* --- node_modules/sucrase/dist/parser/tokenizer/index.js --- */
"node_modules/sucrase/dist/parser/tokenizer/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} /* eslint max-len: 0 */

var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _util = _kame_require_("node_modules/sucrase/dist/parser/traverser/util.js");
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _identifier = _kame_require_("node_modules/sucrase/dist/parser/util/identifier.js");
var _whitespace = _kame_require_("node_modules/sucrase/dist/parser/util/whitespace.js");
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _readWord = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/readWord.js");
var _readWord2 = _interopRequireDefault(_readWord);
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var IdentifierRole;
(function (IdentifierRole) {
  const Access = 0;
  IdentifierRole[IdentifierRole["Access"] = Access] = "Access";
  const ExportAccess = Access + 1;
  IdentifierRole[IdentifierRole["ExportAccess"] = ExportAccess] = "ExportAccess";
  const TopLevelDeclaration = ExportAccess + 1;
  IdentifierRole[IdentifierRole["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
  const FunctionScopedDeclaration = TopLevelDeclaration + 1;
  IdentifierRole[IdentifierRole["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
  const BlockScopedDeclaration = FunctionScopedDeclaration + 1;
  IdentifierRole[IdentifierRole["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1;
  IdentifierRole[IdentifierRole["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1;
  IdentifierRole[IdentifierRole["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1;
  IdentifierRole[IdentifierRole["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1;
  IdentifierRole[IdentifierRole["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
  // Any identifier bound in an import statement, e.g. both A and b from
  // `import A, * as b from 'A';`
  const ImportDeclaration = ObjectShorthand + 1;
  IdentifierRole[IdentifierRole["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
  const ObjectKey = ImportDeclaration + 1;
  IdentifierRole[IdentifierRole["ObjectKey"] = ObjectKey] = "ObjectKey";
  // The `foo` in `import {foo as bar} from "./abc";`.
  const ImportAccess = ObjectKey + 1;
  IdentifierRole[IdentifierRole["ImportAccess"] = ImportAccess] = "ImportAccess";
})(IdentifierRole || (exports.IdentifierRole = IdentifierRole = {}));

/**
 * Extra information on jsxTagStart tokens, used to determine which of the three
 * jsx functions are called in the automatic transform.
 */
var JSXRole;
(function (JSXRole) {
  // The element is self-closing or has a body that resolves to empty. We
  // shouldn't emit children at all in this case.
  const NoChildren = 0;
  JSXRole[JSXRole["NoChildren"] = NoChildren] = "NoChildren";
  // The element has a single explicit child, which might still be an arbitrary
  // expression like an array. We should emit that expression as the children.
  const OneChild = NoChildren + 1;
  JSXRole[JSXRole["OneChild"] = OneChild] = "OneChild";
  // The element has at least two explicitly-specified children or has spread
  // children, so child positions are assumed to be "static". We should wrap
  // these children in an array.
  const StaticChildren = OneChild + 1;
  JSXRole[JSXRole["StaticChildren"] = StaticChildren] = "StaticChildren";
  // The element has a prop named "key" after a prop spread, so we should fall
  // back to the createElement function.
  const KeyAfterPropSpread = StaticChildren + 1;
  JSXRole[JSXRole["KeyAfterPropSpread"] = KeyAfterPropSpread] = "KeyAfterPropSpread";
})(JSXRole || (exports.JSXRole = JSXRole = {}));
function isDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
exports.isDeclaration = isDeclaration;
function isNonTopLevelDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
exports.isNonTopLevelDeclaration = isNonTopLevelDeclaration;
function isTopLevelDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ImportDeclaration;
}
exports.isTopLevelDeclaration = isTopLevelDeclaration;
function isBlockScopedDeclaration(token) {
  const role = token.identifierRole;
  // Treat top-level declarations as block scope since the distinction doesn't matter here.
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
exports.isBlockScopedDeclaration = isBlockScopedDeclaration;
function isFunctionScopedDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
}
exports.isFunctionScopedDeclaration = isFunctionScopedDeclaration;
function isObjectShorthandDeclaration(token) {
  return token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
}
exports.isObjectShorthandDeclaration = isObjectShorthandDeclaration;

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.
class Token {
  constructor() {
    this.type = _base.state.type;
    this.contextualKeyword = _base.state.contextualKeyword;
    this.start = _base.state.start;
    this.end = _base.state.end;
    this.scopeDepth = _base.state.scopeDepth;
    this.isType = _base.state.isType;
    this.identifierRole = null;
    this.jsxRole = null;
    this.shadowsGlobal = false;
    this.isAsyncOperation = false;
    this.contextId = null;
    this.rhsEndIndex = null;
    this.isExpression = false;
    this.numNullishCoalesceStarts = 0;
    this.numNullishCoalesceEnds = 0;
    this.isOptionalChainStart = false;
    this.isOptionalChainEnd = false;
    this.subscriptStartIndex = null;
    this.nullishStartIndex = null;
  }

  // Initially false for all tokens, then may be computed in a follow-up step that does scope
  // analysis.

  // Initially false for all tokens, but may be set during transform to mark it as containing an
  // await operation.

  // For assignments, the index of the RHS. For export tokens, the end of the export.

  // For class tokens, records if the class is a class expression or a class statement.

  // Number of times to insert a `nullishCoalesce(` snippet before this token.

  // Number of times to insert a `)` snippet after this token.

  // If true, insert an `optionalChain([` snippet before this token.

  // If true, insert a `])` snippet after this token.

  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
  // subscript chain. This can be used to determine if this chain is an optional chain.

  // Tag for `??` operators to denote the root token for this nullish coalescing call.
}

exports.Token = Token;

// ## Tokenizer

// Move to the next token
function next() {
  _base.state.tokens.push(new Token());
  nextToken();
}
exports.next = next;

// Call instead of next when inside a template, since that needs to be handled differently.
function nextTemplateToken() {
  _base.state.tokens.push(new Token());
  _base.state.start = _base.state.pos;
  readTmplToken();
}
exports.nextTemplateToken = nextTemplateToken;

// The tokenizer never parses regexes by default. Instead, the parser is responsible for
// instructing it to parse a regex when we see a slash at the start of an expression.
function retokenizeSlashAsRegex() {
  if (_base.state.type === _types.TokenType.assign) {
    --_base.state.pos;
  }
  readRegexp();
}
exports.retokenizeSlashAsRegex = retokenizeSlashAsRegex;
function pushTypeContext(existingTokensInType) {
  for (let i = _base.state.tokens.length - existingTokensInType; i < _base.state.tokens.length; i++) {
    _base.state.tokens[i].isType = true;
  }
  const oldIsType = _base.state.isType;
  _base.state.isType = true;
  return oldIsType;
}
exports.pushTypeContext = pushTypeContext;
function popTypeContext(oldIsType) {
  _base.state.isType = oldIsType;
}
exports.popTypeContext = popTypeContext;
function eat(type) {
  if (match(type)) {
    next();
    return true;
  } else {
    return false;
  }
}
exports.eat = eat;
function eatTypeToken(tokenType) {
  const oldIsType = _base.state.isType;
  _base.state.isType = true;
  eat(tokenType);
  _base.state.isType = oldIsType;
}
exports.eatTypeToken = eatTypeToken;
function match(type) {
  return _base.state.type === type;
}
exports.match = match;
function lookaheadType() {
  const snapshot = _base.state.snapshot();
  next();
  const type = _base.state.type;
  _base.state.restoreFromSnapshot(snapshot);
  return type;
}
exports.lookaheadType = lookaheadType;
class TypeAndKeyword {
  constructor(type, contextualKeyword) {
    this.type = type;
    this.contextualKeyword = contextualKeyword;
  }
}
exports.TypeAndKeyword = TypeAndKeyword;
function lookaheadTypeAndKeyword() {
  const snapshot = _base.state.snapshot();
  next();
  const type = _base.state.type;
  const contextualKeyword = _base.state.contextualKeyword;
  _base.state.restoreFromSnapshot(snapshot);
  return new TypeAndKeyword(type, contextualKeyword);
}
exports.lookaheadTypeAndKeyword = lookaheadTypeAndKeyword;
function nextTokenStart() {
  return nextTokenStartSince(_base.state.pos);
}
exports.nextTokenStart = nextTokenStart;
function nextTokenStartSince(pos) {
  _whitespace.skipWhiteSpace.lastIndex = pos;
  const skip = _whitespace.skipWhiteSpace.exec(_base.input);
  return pos + skip[0].length;
}
exports.nextTokenStartSince = nextTokenStartSince;
function lookaheadCharCode() {
  return _base.input.charCodeAt(nextTokenStart());
}
exports.lookaheadCharCode = lookaheadCharCode;

// Read a single token, updating the parser object's token-related
// properties.
function nextToken() {
  skipSpace();
  _base.state.start = _base.state.pos;
  if (_base.state.pos >= _base.input.length) {
    const tokens = _base.state.tokens;
    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.
    // Also check the token positions rather than the types since sometimes we rewrite the token
    // type to something else.
    if (tokens.length >= 2 && tokens[tokens.length - 1].start >= _base.input.length && tokens[tokens.length - 2].start >= _base.input.length) {
      _util.unexpected.call(void 0, "Unexpectedly reached the end of input.");
    }
    finishToken(_types.TokenType.eof);
    return;
  }
  readToken(_base.input.charCodeAt(_base.state.pos));
}
exports.nextToken = nextToken;
function readToken(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash || code === _charcodes.charCodes.atSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.atSign) {
    _readWord2.default.call(void 0);
  } else {
    getTokenFromCode(code);
  }
}
function skipBlockComment() {
  while (_base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.asterisk || _base.input.charCodeAt(_base.state.pos + 1) !== _charcodes.charCodes.slash) {
    _base.state.pos++;
    if (_base.state.pos > _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated comment", _base.state.pos - 2);
      return;
    }
  }
  _base.state.pos += 2;
}
function skipLineComment(startSkip) {
  let ch = _base.input.charCodeAt(_base.state.pos += startSkip);
  if (_base.state.pos < _base.input.length) {
    while (ch !== _charcodes.charCodes.lineFeed && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.lineSeparator && ch !== _charcodes.charCodes.paragraphSeparator && ++_base.state.pos < _base.input.length) {
      ch = _base.input.charCodeAt(_base.state.pos);
    }
  }
}
exports.skipLineComment = skipLineComment;

// Called at the start of the parse and after every token. Skips
// whitespace and comments.
function skipSpace() {
  while (_base.state.pos < _base.input.length) {
    const ch = _base.input.charCodeAt(_base.state.pos);
    switch (ch) {
      case _charcodes.charCodes.carriageReturn:
        if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.lineFeed) {
          ++_base.state.pos;
        }
      case _charcodes.charCodes.lineFeed:
      case _charcodes.charCodes.lineSeparator:
      case _charcodes.charCodes.paragraphSeparator:
        ++_base.state.pos;
        break;
      case _charcodes.charCodes.slash:
        switch (_base.input.charCodeAt(_base.state.pos + 1)) {
          case _charcodes.charCodes.asterisk:
            _base.state.pos += 2;
            skipBlockComment();
            break;
          case _charcodes.charCodes.slash:
            skipLineComment(2);
            break;
          default:
            return;
        }
        break;
      default:
        if (_whitespace.IS_WHITESPACE[ch]) {
          ++_base.state.pos;
        } else {
          return;
        }
    }
  }
}
exports.skipSpace = skipSpace;

// Called at the end of every token. Sets various fields, and skips the space after the token, so
// that the next one's `start` will point at the right position.
function finishToken(type, contextualKeyword = _keywords.ContextualKeyword.NONE) {
  _base.state.end = _base.state.pos;
  _base.state.type = type;
  _base.state.contextualKeyword = contextualKeyword;
}
exports.finishToken = finishToken;

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
function readToken_dot() {
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar >= _charcodes.charCodes.digit0 && nextChar <= _charcodes.charCodes.digit9) {
    readNumber(true);
    return;
  }
  if (nextChar === _charcodes.charCodes.dot && _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.dot) {
    _base.state.pos += 3;
    finishToken(_types.TokenType.ellipsis);
  } else {
    ++_base.state.pos;
    finishToken(_types.TokenType.dot);
  }
}
function readToken_slash() {
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
  } else {
    finishOp(_types.TokenType.slash, 1);
  }
}
function readToken_mult_modulo(code) {
  // '%*'
  let tokenType = code === _charcodes.charCodes.asterisk ? _types.TokenType.star : _types.TokenType.modulo;
  let width = 1;
  let nextChar = _base.input.charCodeAt(_base.state.pos + 1);

  // Exponentiation operator **
  if (code === _charcodes.charCodes.asterisk && nextChar === _charcodes.charCodes.asterisk) {
    width++;
    nextChar = _base.input.charCodeAt(_base.state.pos + 2);
    tokenType = _types.TokenType.exponent;
  }

  // Match *= or %=, disallowing *=> which can be valid in flow.
  if (nextChar === _charcodes.charCodes.equalsTo && _base.input.charCodeAt(_base.state.pos + 2) !== _charcodes.charCodes.greaterThan) {
    width++;
    tokenType = _types.TokenType.assign;
  }
  finishOp(tokenType, width);
}
function readToken_pipe_amp(code) {
  // '|&'
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === code) {
    if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {
      // ||= or &&=
      finishOp(_types.TokenType.assign, 3);
    } else {
      // || or &&
      finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.logicalOR : _types.TokenType.logicalAND, 2);
    }
    return;
  }
  if (code === _charcodes.charCodes.verticalBar) {
    // '|>'
    if (nextChar === _charcodes.charCodes.greaterThan) {
      finishOp(_types.TokenType.pipeline, 2);
      return;
    } else if (nextChar === _charcodes.charCodes.rightCurlyBrace && _base.isFlowEnabled) {
      // '|}'
      finishOp(_types.TokenType.braceBarR, 2);
      return;
    }
  }
  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
    return;
  }
  finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.bitwiseOR : _types.TokenType.bitwiseAND, 1);
}
function readToken_caret() {
  // '^'
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
  } else {
    finishOp(_types.TokenType.bitwiseXOR, 1);
  }
}
function readToken_plus_min(code) {
  // '+-'
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === code) {
    // Tentatively call this a prefix operator, but it might be changed to postfix later.
    finishOp(_types.TokenType.preIncDec, 2);
    return;
  }
  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
  } else if (code === _charcodes.charCodes.plusSign) {
    finishOp(_types.TokenType.plus, 1);
  } else {
    finishOp(_types.TokenType.minus, 1);
  }
}
function readToken_lt() {
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === _charcodes.charCodes.lessThan) {
    if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {
      finishOp(_types.TokenType.assign, 3);
      return;
    }
    // This still might be two instances of <, e.g. the TS type argument
    // expression f<<T>() => void>() , but parse as left shift for now and we'll
    // retokenize if necessary. We can't use isType for this case because we
    // don't know yet if we're in a type.
    finishOp(_types.TokenType.bitShiftL, 2);
    return;
  }
  if (nextChar === _charcodes.charCodes.equalsTo) {
    // <=
    finishOp(_types.TokenType.relationalOrEqual, 2);
  } else {
    finishOp(_types.TokenType.lessThan, 1);
  }
}
function readToken_gt() {
  if (_base.state.isType) {
    // Avoid right-shift for things like `Array<Array<string>>` and
    // greater-than-or-equal for things like `const a: Array<number>=[];`.
    finishOp(_types.TokenType.greaterThan, 1);
    return;
  }
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === _charcodes.charCodes.greaterThan) {
    const size = _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.greaterThan ? 3 : 2;
    if (_base.input.charCodeAt(_base.state.pos + size) === _charcodes.charCodes.equalsTo) {
      finishOp(_types.TokenType.assign, size + 1);
      return;
    }
    finishOp(_types.TokenType.bitShiftR, size);
    return;
  }
  if (nextChar === _charcodes.charCodes.equalsTo) {
    // >=
    finishOp(_types.TokenType.relationalOrEqual, 2);
  } else {
    finishOp(_types.TokenType.greaterThan, 1);
  }
}

/**
 * Called after `as` expressions in TS; we're switching from a type to a
 * non-type context, so a > token may actually be >= .
 */
function rescan_gt() {
  if (_base.state.type === _types.TokenType.greaterThan) {
    _base.state.pos -= 1;
    readToken_gt();
  }
}
exports.rescan_gt = rescan_gt;
function readToken_eq_excl(code) {
  // '=!'
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.equality, _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo ? 3 : 2);
    return;
  }
  if (code === _charcodes.charCodes.equalsTo && nextChar === _charcodes.charCodes.greaterThan) {
    // '=>'
    _base.state.pos += 2;
    finishToken(_types.TokenType.arrow);
    return;
  }
  finishOp(code === _charcodes.charCodes.equalsTo ? _types.TokenType.eq : _types.TokenType.bang, 1);
}
function readToken_question() {
  // '?'
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  const nextChar2 = _base.input.charCodeAt(_base.state.pos + 2);
  if (nextChar === _charcodes.charCodes.questionMark &&
  // In Flow (but not TypeScript), ??string is a valid type that should be
  // tokenized as two individual ? tokens.
  !(_base.isFlowEnabled && _base.state.isType)) {
    if (nextChar2 === _charcodes.charCodes.equalsTo) {
      // '??='
      finishOp(_types.TokenType.assign, 3);
    } else {
      // '??'
      finishOp(_types.TokenType.nullishCoalescing, 2);
    }
  } else if (nextChar === _charcodes.charCodes.dot && !(nextChar2 >= _charcodes.charCodes.digit0 && nextChar2 <= _charcodes.charCodes.digit9)) {
    // '.' not followed by a number
    _base.state.pos += 2;
    finishToken(_types.TokenType.questionDot);
  } else {
    ++_base.state.pos;
    finishToken(_types.TokenType.question);
  }
}
function getTokenFromCode(code) {
  switch (code) {
    case _charcodes.charCodes.numberSign:
      ++_base.state.pos;
      finishToken(_types.TokenType.hash);
      return;

    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.

    case _charcodes.charCodes.dot:
      readToken_dot();
      return;

    // Punctuation tokens.
    case _charcodes.charCodes.leftParenthesis:
      ++_base.state.pos;
      finishToken(_types.TokenType.parenL);
      return;
    case _charcodes.charCodes.rightParenthesis:
      ++_base.state.pos;
      finishToken(_types.TokenType.parenR);
      return;
    case _charcodes.charCodes.semicolon:
      ++_base.state.pos;
      finishToken(_types.TokenType.semi);
      return;
    case _charcodes.charCodes.comma:
      ++_base.state.pos;
      finishToken(_types.TokenType.comma);
      return;
    case _charcodes.charCodes.leftSquareBracket:
      ++_base.state.pos;
      finishToken(_types.TokenType.bracketL);
      return;
    case _charcodes.charCodes.rightSquareBracket:
      ++_base.state.pos;
      finishToken(_types.TokenType.bracketR);
      return;
    case _charcodes.charCodes.leftCurlyBrace:
      if (_base.isFlowEnabled && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.verticalBar) {
        finishOp(_types.TokenType.braceBarL, 2);
      } else {
        ++_base.state.pos;
        finishToken(_types.TokenType.braceL);
      }
      return;
    case _charcodes.charCodes.rightCurlyBrace:
      ++_base.state.pos;
      finishToken(_types.TokenType.braceR);
      return;
    case _charcodes.charCodes.colon:
      if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.colon) {
        finishOp(_types.TokenType.doubleColon, 2);
      } else {
        ++_base.state.pos;
        finishToken(_types.TokenType.colon);
      }
      return;
    case _charcodes.charCodes.questionMark:
      readToken_question();
      return;
    case _charcodes.charCodes.atSign:
      ++_base.state.pos;
      finishToken(_types.TokenType.at);
      return;
    case _charcodes.charCodes.graveAccent:
      ++_base.state.pos;
      finishToken(_types.TokenType.backQuote);
      return;
    case _charcodes.charCodes.digit0:
      {
        const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
        // '0x', '0X', '0o', '0O', '0b', '0B'
        if (nextChar === _charcodes.charCodes.lowercaseX || nextChar === _charcodes.charCodes.uppercaseX || nextChar === _charcodes.charCodes.lowercaseO || nextChar === _charcodes.charCodes.uppercaseO || nextChar === _charcodes.charCodes.lowercaseB || nextChar === _charcodes.charCodes.uppercaseB) {
          readRadixNumber();
          return;
        }
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case _charcodes.charCodes.digit1:
    case _charcodes.charCodes.digit2:
    case _charcodes.charCodes.digit3:
    case _charcodes.charCodes.digit4:
    case _charcodes.charCodes.digit5:
    case _charcodes.charCodes.digit6:
    case _charcodes.charCodes.digit7:
    case _charcodes.charCodes.digit8:
    case _charcodes.charCodes.digit9:
      readNumber(false);
      return;

    // Quotes produce strings.
    case _charcodes.charCodes.quotationMark:
    case _charcodes.charCodes.apostrophe:
      readString(code);
      return;

    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case _charcodes.charCodes.slash:
      readToken_slash();
      return;
    case _charcodes.charCodes.percentSign:
    case _charcodes.charCodes.asterisk:
      readToken_mult_modulo(code);
      return;
    case _charcodes.charCodes.verticalBar:
    case _charcodes.charCodes.ampersand:
      readToken_pipe_amp(code);
      return;
    case _charcodes.charCodes.caret:
      readToken_caret();
      return;
    case _charcodes.charCodes.plusSign:
    case _charcodes.charCodes.dash:
      readToken_plus_min(code);
      return;
    case _charcodes.charCodes.lessThan:
      readToken_lt();
      return;
    case _charcodes.charCodes.greaterThan:
      readToken_gt();
      return;
    case _charcodes.charCodes.equalsTo:
    case _charcodes.charCodes.exclamationMark:
      readToken_eq_excl(code);
      return;
    case _charcodes.charCodes.tilde:
      finishOp(_types.TokenType.tilde, 1);
      return;
    default:
      break;
  }
  _util.unexpected.call(void 0, `Unexpected character '${String.fromCharCode(code)}'`, _base.state.pos);
}
exports.getTokenFromCode = getTokenFromCode;
function finishOp(type, size) {
  _base.state.pos += size;
  finishToken(type);
}
function readRegexp() {
  const start = _base.state.pos;
  let escaped = false;
  let inClass = false;
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated regular expression", start);
      return;
    }
    const code = _base.input.charCodeAt(_base.state.pos);
    if (escaped) {
      escaped = false;
    } else {
      if (code === _charcodes.charCodes.leftSquareBracket) {
        inClass = true;
      } else if (code === _charcodes.charCodes.rightSquareBracket && inClass) {
        inClass = false;
      } else if (code === _charcodes.charCodes.slash && !inClass) {
        break;
      }
      escaped = code === _charcodes.charCodes.backslash;
    }
    ++_base.state.pos;
  }
  ++_base.state.pos;
  // Need to use `skipWord` because '\uXXXX' sequences are allowed here (don't ask).
  skipWord();
  finishToken(_types.TokenType.regexp);
}

/**
 * Read a decimal integer. Note that this can't be unified with the similar code
 * in readRadixNumber (which also handles hex digits) because "e" needs to be
 * the end of the integer so that we can properly handle scientific notation.
 */
function readInt() {
  while (true) {
    const code = _base.input.charCodeAt(_base.state.pos);
    if (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9 || code === _charcodes.charCodes.underscore) {
      _base.state.pos++;
    } else {
      break;
    }
  }
}
function readRadixNumber() {
  _base.state.pos += 2; // 0x

  // Walk to the end of the number, allowing hex digits.
  while (true) {
    const code = _base.input.charCodeAt(_base.state.pos);
    if (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9 || code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF || code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF || code === _charcodes.charCodes.underscore) {
      _base.state.pos++;
    } else {
      break;
    }
  }
  const nextChar = _base.input.charCodeAt(_base.state.pos);
  if (nextChar === _charcodes.charCodes.lowercaseN) {
    ++_base.state.pos;
    finishToken(_types.TokenType.bigint);
  } else {
    finishToken(_types.TokenType.num);
  }
}

// Read an integer, octal integer, or floating-point number.
function readNumber(startsWithDot) {
  let isBigInt = false;
  let isDecimal = false;
  if (!startsWithDot) {
    readInt();
  }
  let nextChar = _base.input.charCodeAt(_base.state.pos);
  if (nextChar === _charcodes.charCodes.dot) {
    ++_base.state.pos;
    readInt();
    nextChar = _base.input.charCodeAt(_base.state.pos);
  }
  if (nextChar === _charcodes.charCodes.uppercaseE || nextChar === _charcodes.charCodes.lowercaseE) {
    nextChar = _base.input.charCodeAt(++_base.state.pos);
    if (nextChar === _charcodes.charCodes.plusSign || nextChar === _charcodes.charCodes.dash) {
      ++_base.state.pos;
    }
    readInt();
    nextChar = _base.input.charCodeAt(_base.state.pos);
  }
  if (nextChar === _charcodes.charCodes.lowercaseN) {
    ++_base.state.pos;
    isBigInt = true;
  } else if (nextChar === _charcodes.charCodes.lowercaseM) {
    ++_base.state.pos;
    isDecimal = true;
  }
  if (isBigInt) {
    finishToken(_types.TokenType.bigint);
    return;
  }
  if (isDecimal) {
    finishToken(_types.TokenType.decimal);
    return;
  }
  finishToken(_types.TokenType.num);
}
function readString(quote) {
  _base.state.pos++;
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated string constant");
      return;
    }
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (ch === _charcodes.charCodes.backslash) {
      _base.state.pos++;
    } else if (ch === quote) {
      break;
    }
    _base.state.pos++;
  }
  _base.state.pos++;
  finishToken(_types.TokenType.string);
}

// Reads template string tokens.
function readTmplToken() {
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated template");
      return;
    }
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (ch === _charcodes.charCodes.graveAccent || ch === _charcodes.charCodes.dollarSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.leftCurlyBrace) {
      if (_base.state.pos === _base.state.start && match(_types.TokenType.template)) {
        if (ch === _charcodes.charCodes.dollarSign) {
          _base.state.pos += 2;
          finishToken(_types.TokenType.dollarBraceL);
          return;
        } else {
          ++_base.state.pos;
          finishToken(_types.TokenType.backQuote);
          return;
        }
      }
      finishToken(_types.TokenType.template);
      return;
    }
    if (ch === _charcodes.charCodes.backslash) {
      _base.state.pos++;
    }
    _base.state.pos++;
  }
}

// Skip to the end of the current word. Note that this is the same as the snippet at the end of
// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough
// measurements.
function skipWord() {
  while (_base.state.pos < _base.input.length) {
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (_identifier.IS_IDENTIFIER_CHAR[ch]) {
      _base.state.pos++;
    } else if (ch === _charcodes.charCodes.backslash) {
      // \u
      _base.state.pos += 2;
      if (_base.input.charCodeAt(_base.state.pos) === _charcodes.charCodes.leftCurlyBrace) {
        while (_base.state.pos < _base.input.length && _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.rightCurlyBrace) {
          _base.state.pos++;
        }
        _base.state.pos++;
      }
    } else {
      break;
    }
  }
}
exports.skipWord = skipWord;
}),
/* --- node_modules/sucrase/dist/parser/tokenizer/keywords.js --- */
"node_modules/sucrase/dist/parser/tokenizer/keywords.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ContextualKeyword;
(function (ContextualKeyword) {
  const NONE = 0;
  ContextualKeyword[ContextualKeyword["NONE"] = NONE] = "NONE";
  const _abstract = NONE + 1;
  ContextualKeyword[ContextualKeyword["_abstract"] = _abstract] = "_abstract";
  const _accessor = _abstract + 1;
  ContextualKeyword[ContextualKeyword["_accessor"] = _accessor] = "_accessor";
  const _as = _accessor + 1;
  ContextualKeyword[ContextualKeyword["_as"] = _as] = "_as";
  const _assert = _as + 1;
  ContextualKeyword[ContextualKeyword["_assert"] = _assert] = "_assert";
  const _asserts = _assert + 1;
  ContextualKeyword[ContextualKeyword["_asserts"] = _asserts] = "_asserts";
  const _async = _asserts + 1;
  ContextualKeyword[ContextualKeyword["_async"] = _async] = "_async";
  const _await = _async + 1;
  ContextualKeyword[ContextualKeyword["_await"] = _await] = "_await";
  const _checks = _await + 1;
  ContextualKeyword[ContextualKeyword["_checks"] = _checks] = "_checks";
  const _constructor = _checks + 1;
  ContextualKeyword[ContextualKeyword["_constructor"] = _constructor] = "_constructor";
  const _declare = _constructor + 1;
  ContextualKeyword[ContextualKeyword["_declare"] = _declare] = "_declare";
  const _enum = _declare + 1;
  ContextualKeyword[ContextualKeyword["_enum"] = _enum] = "_enum";
  const _exports = _enum + 1;
  ContextualKeyword[ContextualKeyword["_exports"] = _exports] = "_exports";
  const _from = _exports + 1;
  ContextualKeyword[ContextualKeyword["_from"] = _from] = "_from";
  const _get = _from + 1;
  ContextualKeyword[ContextualKeyword["_get"] = _get] = "_get";
  const _global = _get + 1;
  ContextualKeyword[ContextualKeyword["_global"] = _global] = "_global";
  const _implements = _global + 1;
  ContextualKeyword[ContextualKeyword["_implements"] = _implements] = "_implements";
  const _infer = _implements + 1;
  ContextualKeyword[ContextualKeyword["_infer"] = _infer] = "_infer";
  const _interface = _infer + 1;
  ContextualKeyword[ContextualKeyword["_interface"] = _interface] = "_interface";
  const _is = _interface + 1;
  ContextualKeyword[ContextualKeyword["_is"] = _is] = "_is";
  const _keyof = _is + 1;
  ContextualKeyword[ContextualKeyword["_keyof"] = _keyof] = "_keyof";
  const _mixins = _keyof + 1;
  ContextualKeyword[ContextualKeyword["_mixins"] = _mixins] = "_mixins";
  const _module = _mixins + 1;
  ContextualKeyword[ContextualKeyword["_module"] = _module] = "_module";
  const _namespace = _module + 1;
  ContextualKeyword[ContextualKeyword["_namespace"] = _namespace] = "_namespace";
  const _of = _namespace + 1;
  ContextualKeyword[ContextualKeyword["_of"] = _of] = "_of";
  const _opaque = _of + 1;
  ContextualKeyword[ContextualKeyword["_opaque"] = _opaque] = "_opaque";
  const _out = _opaque + 1;
  ContextualKeyword[ContextualKeyword["_out"] = _out] = "_out";
  const _override = _out + 1;
  ContextualKeyword[ContextualKeyword["_override"] = _override] = "_override";
  const _private = _override + 1;
  ContextualKeyword[ContextualKeyword["_private"] = _private] = "_private";
  const _protected = _private + 1;
  ContextualKeyword[ContextualKeyword["_protected"] = _protected] = "_protected";
  const _proto = _protected + 1;
  ContextualKeyword[ContextualKeyword["_proto"] = _proto] = "_proto";
  const _public = _proto + 1;
  ContextualKeyword[ContextualKeyword["_public"] = _public] = "_public";
  const _readonly = _public + 1;
  ContextualKeyword[ContextualKeyword["_readonly"] = _readonly] = "_readonly";
  const _require = _readonly + 1;
  ContextualKeyword[ContextualKeyword["_require"] = _require] = "_require";
  const _satisfies = _require + 1;
  ContextualKeyword[ContextualKeyword["_satisfies"] = _satisfies] = "_satisfies";
  const _set = _satisfies + 1;
  ContextualKeyword[ContextualKeyword["_set"] = _set] = "_set";
  const _static = _set + 1;
  ContextualKeyword[ContextualKeyword["_static"] = _static] = "_static";
  const _symbol = _static + 1;
  ContextualKeyword[ContextualKeyword["_symbol"] = _symbol] = "_symbol";
  const _type = _symbol + 1;
  ContextualKeyword[ContextualKeyword["_type"] = _type] = "_type";
  const _unique = _type + 1;
  ContextualKeyword[ContextualKeyword["_unique"] = _unique] = "_unique";
})(ContextualKeyword || (exports.ContextualKeyword = ContextualKeyword = {}));
}),
/* --- node_modules/sucrase/dist/parser/tokenizer/types.js --- */
"node_modules/sucrase/dist/parser/tokenizer/types.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Generated file, do not edit! Run "yarn generate" to re-generate this file.
/* istanbul ignore file */
/**
 * Enum of all token types, with bit fields to signify meaningful properties.
 */
var TokenType;
(function (TokenType) {
  // Precedence 0 means not an operator; otherwise it is a positive number up to 12.
  const PRECEDENCE_MASK = 0xf;
  TokenType[TokenType["PRECEDENCE_MASK"] = PRECEDENCE_MASK] = "PRECEDENCE_MASK";
  const IS_KEYWORD = 1 << 4;
  TokenType[TokenType["IS_KEYWORD"] = IS_KEYWORD] = "IS_KEYWORD";
  const IS_ASSIGN = 1 << 5;
  TokenType[TokenType["IS_ASSIGN"] = IS_ASSIGN] = "IS_ASSIGN";
  const IS_RIGHT_ASSOCIATIVE = 1 << 6;
  TokenType[TokenType["IS_RIGHT_ASSOCIATIVE"] = IS_RIGHT_ASSOCIATIVE] = "IS_RIGHT_ASSOCIATIVE";
  const IS_PREFIX = 1 << 7;
  TokenType[TokenType["IS_PREFIX"] = IS_PREFIX] = "IS_PREFIX";
  const IS_POSTFIX = 1 << 8;
  TokenType[TokenType["IS_POSTFIX"] = IS_POSTFIX] = "IS_POSTFIX";
  const IS_EXPRESSION_START = 1 << 9;
  TokenType[TokenType["IS_EXPRESSION_START"] = IS_EXPRESSION_START] = "IS_EXPRESSION_START";
  const num = 512;
  TokenType[TokenType["num"] = num] = "num"; // num startsExpr
  const bigint = 1536;
  TokenType[TokenType["bigint"] = bigint] = "bigint"; // bigint startsExpr
  const decimal = 2560;
  TokenType[TokenType["decimal"] = decimal] = "decimal"; // decimal startsExpr
  const regexp = 3584;
  TokenType[TokenType["regexp"] = regexp] = "regexp"; // regexp startsExpr
  const string = 4608;
  TokenType[TokenType["string"] = string] = "string"; // string startsExpr
  const name = 5632;
  TokenType[TokenType["name"] = name] = "name"; // name startsExpr
  const eof = 6144;
  TokenType[TokenType["eof"] = eof] = "eof"; // eof
  const bracketL = 7680;
  TokenType[TokenType["bracketL"] = bracketL] = "bracketL"; // [ startsExpr
  const bracketR = 8192;
  TokenType[TokenType["bracketR"] = bracketR] = "bracketR"; // ]
  const braceL = 9728;
  TokenType[TokenType["braceL"] = braceL] = "braceL"; // { startsExpr
  const braceBarL = 10752;
  TokenType[TokenType["braceBarL"] = braceBarL] = "braceBarL"; // {| startsExpr
  const braceR = 11264;
  TokenType[TokenType["braceR"] = braceR] = "braceR"; // }
  const braceBarR = 12288;
  TokenType[TokenType["braceBarR"] = braceBarR] = "braceBarR"; // |}
  const parenL = 13824;
  TokenType[TokenType["parenL"] = parenL] = "parenL"; // ( startsExpr
  const parenR = 14336;
  TokenType[TokenType["parenR"] = parenR] = "parenR"; // )
  const comma = 15360;
  TokenType[TokenType["comma"] = comma] = "comma"; // ,
  const semi = 16384;
  TokenType[TokenType["semi"] = semi] = "semi"; // ;
  const colon = 17408;
  TokenType[TokenType["colon"] = colon] = "colon"; // :
  const doubleColon = 18432;
  TokenType[TokenType["doubleColon"] = doubleColon] = "doubleColon"; // ::
  const dot = 19456;
  TokenType[TokenType["dot"] = dot] = "dot"; // .
  const question = 20480;
  TokenType[TokenType["question"] = question] = "question"; // ?
  const questionDot = 21504;
  TokenType[TokenType["questionDot"] = questionDot] = "questionDot"; // ?.
  const arrow = 22528;
  TokenType[TokenType["arrow"] = arrow] = "arrow"; // =>
  const template = 23552;
  TokenType[TokenType["template"] = template] = "template"; // template
  const ellipsis = 24576;
  TokenType[TokenType["ellipsis"] = ellipsis] = "ellipsis"; // ...
  const backQuote = 25600;
  TokenType[TokenType["backQuote"] = backQuote] = "backQuote"; // `
  const dollarBraceL = 27136;
  TokenType[TokenType["dollarBraceL"] = dollarBraceL] = "dollarBraceL"; // ${ startsExpr
  const at = 27648;
  TokenType[TokenType["at"] = at] = "at"; // @
  const hash = 29184;
  TokenType[TokenType["hash"] = hash] = "hash"; // # startsExpr
  const eq = 29728;
  TokenType[TokenType["eq"] = eq] = "eq"; // = isAssign
  const assign = 30752;
  TokenType[TokenType["assign"] = assign] = "assign"; // _= isAssign
  const preIncDec = 32640;
  TokenType[TokenType["preIncDec"] = preIncDec] = "preIncDec"; // ++/-- prefix postfix startsExpr
  const postIncDec = 33664;
  TokenType[TokenType["postIncDec"] = postIncDec] = "postIncDec"; // ++/-- prefix postfix startsExpr
  const bang = 34432;
  TokenType[TokenType["bang"] = bang] = "bang"; // ! prefix startsExpr
  const tilde = 35456;
  TokenType[TokenType["tilde"] = tilde] = "tilde"; // ~ prefix startsExpr
  const pipeline = 35841;
  TokenType[TokenType["pipeline"] = pipeline] = "pipeline"; // |> prec:1
  const nullishCoalescing = 36866;
  TokenType[TokenType["nullishCoalescing"] = nullishCoalescing] = "nullishCoalescing"; // ?? prec:2
  const logicalOR = 37890;
  TokenType[TokenType["logicalOR"] = logicalOR] = "logicalOR"; // || prec:2
  const logicalAND = 38915;
  TokenType[TokenType["logicalAND"] = logicalAND] = "logicalAND"; // && prec:3
  const bitwiseOR = 39940;
  TokenType[TokenType["bitwiseOR"] = bitwiseOR] = "bitwiseOR"; // | prec:4
  const bitwiseXOR = 40965;
  TokenType[TokenType["bitwiseXOR"] = bitwiseXOR] = "bitwiseXOR"; // ^ prec:5
  const bitwiseAND = 41990;
  TokenType[TokenType["bitwiseAND"] = bitwiseAND] = "bitwiseAND"; // & prec:6
  const equality = 43015;
  TokenType[TokenType["equality"] = equality] = "equality"; // ==/!= prec:7
  const lessThan = 44040;
  TokenType[TokenType["lessThan"] = lessThan] = "lessThan"; // < prec:8
  const greaterThan = 45064;
  TokenType[TokenType["greaterThan"] = greaterThan] = "greaterThan"; // > prec:8
  const relationalOrEqual = 46088;
  TokenType[TokenType["relationalOrEqual"] = relationalOrEqual] = "relationalOrEqual"; // <=/>= prec:8
  const bitShiftL = 47113;
  TokenType[TokenType["bitShiftL"] = bitShiftL] = "bitShiftL"; // << prec:9
  const bitShiftR = 48137;
  TokenType[TokenType["bitShiftR"] = bitShiftR] = "bitShiftR"; // >>/>>> prec:9
  const plus = 49802;
  TokenType[TokenType["plus"] = plus] = "plus"; // + prec:10 prefix startsExpr
  const minus = 50826;
  TokenType[TokenType["minus"] = minus] = "minus"; // - prec:10 prefix startsExpr
  const modulo = 51723;
  TokenType[TokenType["modulo"] = modulo] = "modulo"; // % prec:11 startsExpr
  const star = 52235;
  TokenType[TokenType["star"] = star] = "star"; // * prec:11
  const slash = 53259;
  TokenType[TokenType["slash"] = slash] = "slash"; // / prec:11
  const exponent = 54348;
  TokenType[TokenType["exponent"] = exponent] = "exponent"; // ** prec:12 rightAssociative
  const jsxName = 55296;
  TokenType[TokenType["jsxName"] = jsxName] = "jsxName"; // jsxName
  const jsxText = 56320;
  TokenType[TokenType["jsxText"] = jsxText] = "jsxText"; // jsxText
  const jsxEmptyText = 57344;
  TokenType[TokenType["jsxEmptyText"] = jsxEmptyText] = "jsxEmptyText"; // jsxEmptyText
  const jsxTagStart = 58880;
  TokenType[TokenType["jsxTagStart"] = jsxTagStart] = "jsxTagStart"; // jsxTagStart startsExpr
  const jsxTagEnd = 59392;
  TokenType[TokenType["jsxTagEnd"] = jsxTagEnd] = "jsxTagEnd"; // jsxTagEnd
  const typeParameterStart = 60928;
  TokenType[TokenType["typeParameterStart"] = typeParameterStart] = "typeParameterStart"; // typeParameterStart startsExpr
  const nonNullAssertion = 61440;
  TokenType[TokenType["nonNullAssertion"] = nonNullAssertion] = "nonNullAssertion"; // nonNullAssertion
  const _break = 62480;
  TokenType[TokenType["_break"] = _break] = "_break"; // break keyword
  const _case = 63504;
  TokenType[TokenType["_case"] = _case] = "_case"; // case keyword
  const _catch = 64528;
  TokenType[TokenType["_catch"] = _catch] = "_catch"; // catch keyword
  const _continue = 65552;
  TokenType[TokenType["_continue"] = _continue] = "_continue"; // continue keyword
  const _debugger = 66576;
  TokenType[TokenType["_debugger"] = _debugger] = "_debugger"; // debugger keyword
  const _default = 67600;
  TokenType[TokenType["_default"] = _default] = "_default"; // default keyword
  const _do = 68624;
  TokenType[TokenType["_do"] = _do] = "_do"; // do keyword
  const _else = 69648;
  TokenType[TokenType["_else"] = _else] = "_else"; // else keyword
  const _finally = 70672;
  TokenType[TokenType["_finally"] = _finally] = "_finally"; // finally keyword
  const _for = 71696;
  TokenType[TokenType["_for"] = _for] = "_for"; // for keyword
  const _function = 73232;
  TokenType[TokenType["_function"] = _function] = "_function"; // function keyword startsExpr
  const _if = 73744;
  TokenType[TokenType["_if"] = _if] = "_if"; // if keyword
  const _return = 74768;
  TokenType[TokenType["_return"] = _return] = "_return"; // return keyword
  const _switch = 75792;
  TokenType[TokenType["_switch"] = _switch] = "_switch"; // switch keyword
  const _throw = 77456;
  TokenType[TokenType["_throw"] = _throw] = "_throw"; // throw keyword prefix startsExpr
  const _try = 77840;
  TokenType[TokenType["_try"] = _try] = "_try"; // try keyword
  const _var = 78864;
  TokenType[TokenType["_var"] = _var] = "_var"; // var keyword
  const _let = 79888;
  TokenType[TokenType["_let"] = _let] = "_let"; // let keyword
  const _const = 80912;
  TokenType[TokenType["_const"] = _const] = "_const"; // const keyword
  const _while = 81936;
  TokenType[TokenType["_while"] = _while] = "_while"; // while keyword
  const _with = 82960;
  TokenType[TokenType["_with"] = _with] = "_with"; // with keyword
  const _new = 84496;
  TokenType[TokenType["_new"] = _new] = "_new"; // new keyword startsExpr
  const _this = 85520;
  TokenType[TokenType["_this"] = _this] = "_this"; // this keyword startsExpr
  const _super = 86544;
  TokenType[TokenType["_super"] = _super] = "_super"; // super keyword startsExpr
  const _class = 87568;
  TokenType[TokenType["_class"] = _class] = "_class"; // class keyword startsExpr
  const _extends = 88080;
  TokenType[TokenType["_extends"] = _extends] = "_extends"; // extends keyword
  const _export = 89104;
  TokenType[TokenType["_export"] = _export] = "_export"; // export keyword
  const _import = 90640;
  TokenType[TokenType["_import"] = _import] = "_import"; // import keyword startsExpr
  const _yield = 91664;
  TokenType[TokenType["_yield"] = _yield] = "_yield"; // yield keyword startsExpr
  const _null = 92688;
  TokenType[TokenType["_null"] = _null] = "_null"; // null keyword startsExpr
  const _true = 93712;
  TokenType[TokenType["_true"] = _true] = "_true"; // true keyword startsExpr
  const _false = 94736;
  TokenType[TokenType["_false"] = _false] = "_false"; // false keyword startsExpr
  const _in = 95256;
  TokenType[TokenType["_in"] = _in] = "_in"; // in prec:8 keyword
  const _instanceof = 96280;
  TokenType[TokenType["_instanceof"] = _instanceof] = "_instanceof"; // instanceof prec:8 keyword
  const _typeof = 97936;
  TokenType[TokenType["_typeof"] = _typeof] = "_typeof"; // typeof keyword prefix startsExpr
  const _void = 98960;
  TokenType[TokenType["_void"] = _void] = "_void"; // void keyword prefix startsExpr
  const _delete = 99984;
  TokenType[TokenType["_delete"] = _delete] = "_delete"; // delete keyword prefix startsExpr
  const _async = 100880;
  TokenType[TokenType["_async"] = _async] = "_async"; // async keyword startsExpr
  const _get = 101904;
  TokenType[TokenType["_get"] = _get] = "_get"; // get keyword startsExpr
  const _set = 102928;
  TokenType[TokenType["_set"] = _set] = "_set"; // set keyword startsExpr
  const _declare = 103952;
  TokenType[TokenType["_declare"] = _declare] = "_declare"; // declare keyword startsExpr
  const _readonly = 104976;
  TokenType[TokenType["_readonly"] = _readonly] = "_readonly"; // readonly keyword startsExpr
  const _abstract = 106000;
  TokenType[TokenType["_abstract"] = _abstract] = "_abstract"; // abstract keyword startsExpr
  const _static = 107024;
  TokenType[TokenType["_static"] = _static] = "_static"; // static keyword startsExpr
  const _public = 107536;
  TokenType[TokenType["_public"] = _public] = "_public"; // public keyword
  const _private = 108560;
  TokenType[TokenType["_private"] = _private] = "_private"; // private keyword
  const _protected = 109584;
  TokenType[TokenType["_protected"] = _protected] = "_protected"; // protected keyword
  const _override = 110608;
  TokenType[TokenType["_override"] = _override] = "_override"; // override keyword
  const _as = 112144;
  TokenType[TokenType["_as"] = _as] = "_as"; // as keyword startsExpr
  const _enum = 113168;
  TokenType[TokenType["_enum"] = _enum] = "_enum"; // enum keyword startsExpr
  const _type = 114192;
  TokenType[TokenType["_type"] = _type] = "_type"; // type keyword startsExpr
  const _implements = 115216;
  TokenType[TokenType["_implements"] = _implements] = "_implements"; // implements keyword startsExpr
})(TokenType || (exports.TokenType = TokenType = {}));
function formatTokenType(tokenType) {
  switch (tokenType) {
    case TokenType.num:
      return "num";
    case TokenType.bigint:
      return "bigint";
    case TokenType.decimal:
      return "decimal";
    case TokenType.regexp:
      return "regexp";
    case TokenType.string:
      return "string";
    case TokenType.name:
      return "name";
    case TokenType.eof:
      return "eof";
    case TokenType.bracketL:
      return "[";
    case TokenType.bracketR:
      return "]";
    case TokenType.braceL:
      return "{";
    case TokenType.braceBarL:
      return "{|";
    case TokenType.braceR:
      return "}";
    case TokenType.braceBarR:
      return "|}";
    case TokenType.parenL:
      return "(";
    case TokenType.parenR:
      return ")";
    case TokenType.comma:
      return ",";
    case TokenType.semi:
      return ";";
    case TokenType.colon:
      return ":";
    case TokenType.doubleColon:
      return "::";
    case TokenType.dot:
      return ".";
    case TokenType.question:
      return "?";
    case TokenType.questionDot:
      return "?.";
    case TokenType.arrow:
      return "=>";
    case TokenType.template:
      return "template";
    case TokenType.ellipsis:
      return "...";
    case TokenType.backQuote:
      return "`";
    case TokenType.dollarBraceL:
      return "${";
    case TokenType.at:
      return "@";
    case TokenType.hash:
      return "#";
    case TokenType.eq:
      return "=";
    case TokenType.assign:
      return "_=";
    case TokenType.preIncDec:
      return "++/--";
    case TokenType.postIncDec:
      return "++/--";
    case TokenType.bang:
      return "!";
    case TokenType.tilde:
      return "~";
    case TokenType.pipeline:
      return "|>";
    case TokenType.nullishCoalescing:
      return "??";
    case TokenType.logicalOR:
      return "||";
    case TokenType.logicalAND:
      return "&&";
    case TokenType.bitwiseOR:
      return "|";
    case TokenType.bitwiseXOR:
      return "^";
    case TokenType.bitwiseAND:
      return "&";
    case TokenType.equality:
      return "==/!=";
    case TokenType.lessThan:
      return "<";
    case TokenType.greaterThan:
      return ">";
    case TokenType.relationalOrEqual:
      return "<=/>=";
    case TokenType.bitShiftL:
      return "<<";
    case TokenType.bitShiftR:
      return ">>/>>>";
    case TokenType.plus:
      return "+";
    case TokenType.minus:
      return "-";
    case TokenType.modulo:
      return "%";
    case TokenType.star:
      return "*";
    case TokenType.slash:
      return "/";
    case TokenType.exponent:
      return "**";
    case TokenType.jsxName:
      return "jsxName";
    case TokenType.jsxText:
      return "jsxText";
    case TokenType.jsxEmptyText:
      return "jsxEmptyText";
    case TokenType.jsxTagStart:
      return "jsxTagStart";
    case TokenType.jsxTagEnd:
      return "jsxTagEnd";
    case TokenType.typeParameterStart:
      return "typeParameterStart";
    case TokenType.nonNullAssertion:
      return "nonNullAssertion";
    case TokenType._break:
      return "break";
    case TokenType._case:
      return "case";
    case TokenType._catch:
      return "catch";
    case TokenType._continue:
      return "continue";
    case TokenType._debugger:
      return "debugger";
    case TokenType._default:
      return "default";
    case TokenType._do:
      return "do";
    case TokenType._else:
      return "else";
    case TokenType._finally:
      return "finally";
    case TokenType._for:
      return "for";
    case TokenType._function:
      return "function";
    case TokenType._if:
      return "if";
    case TokenType._return:
      return "return";
    case TokenType._switch:
      return "switch";
    case TokenType._throw:
      return "throw";
    case TokenType._try:
      return "try";
    case TokenType._var:
      return "var";
    case TokenType._let:
      return "let";
    case TokenType._const:
      return "const";
    case TokenType._while:
      return "while";
    case TokenType._with:
      return "with";
    case TokenType._new:
      return "new";
    case TokenType._this:
      return "this";
    case TokenType._super:
      return "super";
    case TokenType._class:
      return "class";
    case TokenType._extends:
      return "extends";
    case TokenType._export:
      return "export";
    case TokenType._import:
      return "import";
    case TokenType._yield:
      return "yield";
    case TokenType._null:
      return "null";
    case TokenType._true:
      return "true";
    case TokenType._false:
      return "false";
    case TokenType._in:
      return "in";
    case TokenType._instanceof:
      return "instanceof";
    case TokenType._typeof:
      return "typeof";
    case TokenType._void:
      return "void";
    case TokenType._delete:
      return "delete";
    case TokenType._async:
      return "async";
    case TokenType._get:
      return "get";
    case TokenType._set:
      return "set";
    case TokenType._declare:
      return "declare";
    case TokenType._readonly:
      return "readonly";
    case TokenType._abstract:
      return "abstract";
    case TokenType._static:
      return "static";
    case TokenType._public:
      return "public";
    case TokenType._private:
      return "private";
    case TokenType._protected:
      return "protected";
    case TokenType._override:
      return "override";
    case TokenType._as:
      return "as";
    case TokenType._enum:
      return "enum";
    case TokenType._type:
      return "type";
    case TokenType._implements:
      return "implements";
    default:
      return "";
  }
}
exports.formatTokenType = formatTokenType;
}),
/* --- node_modules/sucrase/dist/util/getImportExportSpecifierInfo.js --- */
"node_modules/sucrase/dist/util/getImportExportSpecifierInfo.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");

/**
 * Determine information about this named import or named export specifier.
 *
 * This syntax is the `a` from statements like these:
 * import {A} from "./foo";
 * export {A};
 * export {A} from "./foo";
 *
 * As it turns out, we can exactly characterize the syntax meaning by simply
 * counting the number of tokens, which can be from 1 to 4:
 * {A}
 * {type A}
 * {A as B}
 * {type A as B}
 *
 * In the type case, we never actually need the names in practice, so don't get
 * them.
 *
 * TODO: There's some redundancy with the type detection here and the isType
 * flag that's already present on tokens in TS mode. This function could
 * potentially be simplified and/or pushed to the call sites to avoid the object
 * allocation.
 */
function getImportExportSpecifierInfo(tokens, index = tokens.currentIndex()) {
  let endIndex = index + 1;
  if (isSpecifierEnd(tokens, endIndex)) {
    // import {A}
    const name = tokens.identifierNameAtIndex(index);
    return {
      isType: false,
      leftName: name,
      rightName: name,
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    // import {type A}
    return {
      isType: true,
      leftName: null,
      rightName: null,
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    // import {A as B}
    return {
      isType: false,
      leftName: tokens.identifierNameAtIndex(index),
      rightName: tokens.identifierNameAtIndex(index + 2),
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    // import {type A as B}
    return {
      isType: true,
      leftName: null,
      rightName: null,
      endIndex
    };
  }
  throw new Error(`Unexpected import/export specifier at ${index}`);
}
exports.default = getImportExportSpecifierInfo;
function isSpecifierEnd(tokens, index) {
  const token = tokens.tokens[index];
  return token.type === _types.TokenType.braceR || token.type === _types.TokenType.comma;
}
}),
/* --- node_modules/sucrase/dist/util/getNonTypeIdentifiers.js --- */
"node_modules/sucrase/dist/util/getNonTypeIdentifiers.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _JSXTransformer = _kame_require_("node_modules/sucrase/dist/transformers/JSXTransformer.js");
var _getJSXPragmaInfo = _kame_require_("node_modules/sucrase/dist/util/getJSXPragmaInfo.js");
var _getJSXPragmaInfo2 = _interopRequireDefault(_getJSXPragmaInfo);
function getNonTypeIdentifiers(tokens, options) {
  const jsxPragmaInfo = _getJSXPragmaInfo2.default.call(void 0, options);
  const nonTypeIdentifiers = new Set();
  for (let i = 0; i < tokens.tokens.length; i++) {
    const token = tokens.tokens[i];
    if (token.type === _types.TokenType.name && !token.isType && (token.identifierRole === _tokenizer.IdentifierRole.Access || token.identifierRole === _tokenizer.IdentifierRole.ObjectShorthand || token.identifierRole === _tokenizer.IdentifierRole.ExportAccess) && !token.shadowsGlobal) {
      nonTypeIdentifiers.add(tokens.identifierNameForToken(token));
    }
    if (token.type === _types.TokenType.jsxTagStart) {
      nonTypeIdentifiers.add(jsxPragmaInfo.base);
    }
    if (token.type === _types.TokenType.jsxTagStart && i + 1 < tokens.tokens.length && tokens.tokens[i + 1].type === _types.TokenType.jsxTagEnd) {
      nonTypeIdentifiers.add(jsxPragmaInfo.base);
      nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);
    }
    if (token.type === _types.TokenType.jsxName && token.identifierRole === _tokenizer.IdentifierRole.Access) {
      const identifierName = tokens.identifierNameForToken(token);
      // Lower-case single-component tag names like "div" don't count.
      if (!_JSXTransformer.startsWithLowerCase.call(void 0, identifierName) || tokens.tokens[i + 1].type === _types.TokenType.dot) {
        nonTypeIdentifiers.add(tokens.identifierNameForToken(token));
      }
    }
  }
  return nonTypeIdentifiers;
}
exports.getNonTypeIdentifiers = getNonTypeIdentifiers;
}),
/* --- node_modules/sucrase/dist/parser/util/charcodes.js --- */
"node_modules/sucrase/dist/parser/util/charcodes.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var charCodes;
(function (charCodes) {
  const backSpace = 8;
  charCodes[charCodes["backSpace"] = backSpace] = "backSpace";
  const lineFeed = 10;
  charCodes[charCodes["lineFeed"] = lineFeed] = "lineFeed"; //  '\n'
  const tab = 9;
  charCodes[charCodes["tab"] = tab] = "tab"; //  '\t'
  const carriageReturn = 13;
  charCodes[charCodes["carriageReturn"] = carriageReturn] = "carriageReturn"; //  '\r'
  const shiftOut = 14;
  charCodes[charCodes["shiftOut"] = shiftOut] = "shiftOut";
  const space = 32;
  charCodes[charCodes["space"] = space] = "space";
  const exclamationMark = 33;
  charCodes[charCodes["exclamationMark"] = exclamationMark] = "exclamationMark"; //  '!'
  const quotationMark = 34;
  charCodes[charCodes["quotationMark"] = quotationMark] = "quotationMark"; //  '"'
  const numberSign = 35;
  charCodes[charCodes["numberSign"] = numberSign] = "numberSign"; //  '#'
  const dollarSign = 36;
  charCodes[charCodes["dollarSign"] = dollarSign] = "dollarSign"; //  '$'
  const percentSign = 37;
  charCodes[charCodes["percentSign"] = percentSign] = "percentSign"; //  '%'
  const ampersand = 38;
  charCodes[charCodes["ampersand"] = ampersand] = "ampersand"; //  '&'
  const apostrophe = 39;
  charCodes[charCodes["apostrophe"] = apostrophe] = "apostrophe"; //  '''
  const leftParenthesis = 40;
  charCodes[charCodes["leftParenthesis"] = leftParenthesis] = "leftParenthesis"; //  '('
  const rightParenthesis = 41;
  charCodes[charCodes["rightParenthesis"] = rightParenthesis] = "rightParenthesis"; //  ')'
  const asterisk = 42;
  charCodes[charCodes["asterisk"] = asterisk] = "asterisk"; //  '*'
  const plusSign = 43;
  charCodes[charCodes["plusSign"] = plusSign] = "plusSign"; //  '+'
  const comma = 44;
  charCodes[charCodes["comma"] = comma] = "comma"; //  ','
  const dash = 45;
  charCodes[charCodes["dash"] = dash] = "dash"; //  '-'
  const dot = 46;
  charCodes[charCodes["dot"] = dot] = "dot"; //  '.'
  const slash = 47;
  charCodes[charCodes["slash"] = slash] = "slash"; //  '/'
  const digit0 = 48;
  charCodes[charCodes["digit0"] = digit0] = "digit0"; //  '0'
  const digit1 = 49;
  charCodes[charCodes["digit1"] = digit1] = "digit1"; //  '1'
  const digit2 = 50;
  charCodes[charCodes["digit2"] = digit2] = "digit2"; //  '2'
  const digit3 = 51;
  charCodes[charCodes["digit3"] = digit3] = "digit3"; //  '3'
  const digit4 = 52;
  charCodes[charCodes["digit4"] = digit4] = "digit4"; //  '4'
  const digit5 = 53;
  charCodes[charCodes["digit5"] = digit5] = "digit5"; //  '5'
  const digit6 = 54;
  charCodes[charCodes["digit6"] = digit6] = "digit6"; //  '6'
  const digit7 = 55;
  charCodes[charCodes["digit7"] = digit7] = "digit7"; //  '7'
  const digit8 = 56;
  charCodes[charCodes["digit8"] = digit8] = "digit8"; //  '8'
  const digit9 = 57;
  charCodes[charCodes["digit9"] = digit9] = "digit9"; //  '9'
  const colon = 58;
  charCodes[charCodes["colon"] = colon] = "colon"; //  ':'
  const semicolon = 59;
  charCodes[charCodes["semicolon"] = semicolon] = "semicolon"; //  ';'
  const lessThan = 60;
  charCodes[charCodes["lessThan"] = lessThan] = "lessThan"; //  '<'
  const equalsTo = 61;
  charCodes[charCodes["equalsTo"] = equalsTo] = "equalsTo"; //  '='
  const greaterThan = 62;
  charCodes[charCodes["greaterThan"] = greaterThan] = "greaterThan"; //  '>'
  const questionMark = 63;
  charCodes[charCodes["questionMark"] = questionMark] = "questionMark"; //  '?'
  const atSign = 64;
  charCodes[charCodes["atSign"] = atSign] = "atSign"; //  '@'
  const uppercaseA = 65;
  charCodes[charCodes["uppercaseA"] = uppercaseA] = "uppercaseA"; //  'A'
  const uppercaseB = 66;
  charCodes[charCodes["uppercaseB"] = uppercaseB] = "uppercaseB"; //  'B'
  const uppercaseC = 67;
  charCodes[charCodes["uppercaseC"] = uppercaseC] = "uppercaseC"; //  'C'
  const uppercaseD = 68;
  charCodes[charCodes["uppercaseD"] = uppercaseD] = "uppercaseD"; //  'D'
  const uppercaseE = 69;
  charCodes[charCodes["uppercaseE"] = uppercaseE] = "uppercaseE"; //  'E'
  const uppercaseF = 70;
  charCodes[charCodes["uppercaseF"] = uppercaseF] = "uppercaseF"; //  'F'
  const uppercaseG = 71;
  charCodes[charCodes["uppercaseG"] = uppercaseG] = "uppercaseG"; //  'G'
  const uppercaseH = 72;
  charCodes[charCodes["uppercaseH"] = uppercaseH] = "uppercaseH"; //  'H'
  const uppercaseI = 73;
  charCodes[charCodes["uppercaseI"] = uppercaseI] = "uppercaseI"; //  'I'
  const uppercaseJ = 74;
  charCodes[charCodes["uppercaseJ"] = uppercaseJ] = "uppercaseJ"; //  'J'
  const uppercaseK = 75;
  charCodes[charCodes["uppercaseK"] = uppercaseK] = "uppercaseK"; //  'K'
  const uppercaseL = 76;
  charCodes[charCodes["uppercaseL"] = uppercaseL] = "uppercaseL"; //  'L'
  const uppercaseM = 77;
  charCodes[charCodes["uppercaseM"] = uppercaseM] = "uppercaseM"; //  'M'
  const uppercaseN = 78;
  charCodes[charCodes["uppercaseN"] = uppercaseN] = "uppercaseN"; //  'N'
  const uppercaseO = 79;
  charCodes[charCodes["uppercaseO"] = uppercaseO] = "uppercaseO"; //  'O'
  const uppercaseP = 80;
  charCodes[charCodes["uppercaseP"] = uppercaseP] = "uppercaseP"; //  'P'
  const uppercaseQ = 81;
  charCodes[charCodes["uppercaseQ"] = uppercaseQ] = "uppercaseQ"; //  'Q'
  const uppercaseR = 82;
  charCodes[charCodes["uppercaseR"] = uppercaseR] = "uppercaseR"; //  'R'
  const uppercaseS = 83;
  charCodes[charCodes["uppercaseS"] = uppercaseS] = "uppercaseS"; //  'S'
  const uppercaseT = 84;
  charCodes[charCodes["uppercaseT"] = uppercaseT] = "uppercaseT"; //  'T'
  const uppercaseU = 85;
  charCodes[charCodes["uppercaseU"] = uppercaseU] = "uppercaseU"; //  'U'
  const uppercaseV = 86;
  charCodes[charCodes["uppercaseV"] = uppercaseV] = "uppercaseV"; //  'V'
  const uppercaseW = 87;
  charCodes[charCodes["uppercaseW"] = uppercaseW] = "uppercaseW"; //  'W'
  const uppercaseX = 88;
  charCodes[charCodes["uppercaseX"] = uppercaseX] = "uppercaseX"; //  'X'
  const uppercaseY = 89;
  charCodes[charCodes["uppercaseY"] = uppercaseY] = "uppercaseY"; //  'Y'
  const uppercaseZ = 90;
  charCodes[charCodes["uppercaseZ"] = uppercaseZ] = "uppercaseZ"; //  'Z'
  const leftSquareBracket = 91;
  charCodes[charCodes["leftSquareBracket"] = leftSquareBracket] = "leftSquareBracket"; //  '['
  const backslash = 92;
  charCodes[charCodes["backslash"] = backslash] = "backslash"; //  '\    '
  const rightSquareBracket = 93;
  charCodes[charCodes["rightSquareBracket"] = rightSquareBracket] = "rightSquareBracket"; //  ']'
  const caret = 94;
  charCodes[charCodes["caret"] = caret] = "caret"; //  '^'
  const underscore = 95;
  charCodes[charCodes["underscore"] = underscore] = "underscore"; //  '_'
  const graveAccent = 96;
  charCodes[charCodes["graveAccent"] = graveAccent] = "graveAccent"; //  '`'
  const lowercaseA = 97;
  charCodes[charCodes["lowercaseA"] = lowercaseA] = "lowercaseA"; //  'a'
  const lowercaseB = 98;
  charCodes[charCodes["lowercaseB"] = lowercaseB] = "lowercaseB"; //  'b'
  const lowercaseC = 99;
  charCodes[charCodes["lowercaseC"] = lowercaseC] = "lowercaseC"; //  'c'
  const lowercaseD = 100;
  charCodes[charCodes["lowercaseD"] = lowercaseD] = "lowercaseD"; //  'd'
  const lowercaseE = 101;
  charCodes[charCodes["lowercaseE"] = lowercaseE] = "lowercaseE"; //  'e'
  const lowercaseF = 102;
  charCodes[charCodes["lowercaseF"] = lowercaseF] = "lowercaseF"; //  'f'
  const lowercaseG = 103;
  charCodes[charCodes["lowercaseG"] = lowercaseG] = "lowercaseG"; //  'g'
  const lowercaseH = 104;
  charCodes[charCodes["lowercaseH"] = lowercaseH] = "lowercaseH"; //  'h'
  const lowercaseI = 105;
  charCodes[charCodes["lowercaseI"] = lowercaseI] = "lowercaseI"; //  'i'
  const lowercaseJ = 106;
  charCodes[charCodes["lowercaseJ"] = lowercaseJ] = "lowercaseJ"; //  'j'
  const lowercaseK = 107;
  charCodes[charCodes["lowercaseK"] = lowercaseK] = "lowercaseK"; //  'k'
  const lowercaseL = 108;
  charCodes[charCodes["lowercaseL"] = lowercaseL] = "lowercaseL"; //  'l'
  const lowercaseM = 109;
  charCodes[charCodes["lowercaseM"] = lowercaseM] = "lowercaseM"; //  'm'
  const lowercaseN = 110;
  charCodes[charCodes["lowercaseN"] = lowercaseN] = "lowercaseN"; //  'n'
  const lowercaseO = 111;
  charCodes[charCodes["lowercaseO"] = lowercaseO] = "lowercaseO"; //  'o'
  const lowercaseP = 112;
  charCodes[charCodes["lowercaseP"] = lowercaseP] = "lowercaseP"; //  'p'
  const lowercaseQ = 113;
  charCodes[charCodes["lowercaseQ"] = lowercaseQ] = "lowercaseQ"; //  'q'
  const lowercaseR = 114;
  charCodes[charCodes["lowercaseR"] = lowercaseR] = "lowercaseR"; //  'r'
  const lowercaseS = 115;
  charCodes[charCodes["lowercaseS"] = lowercaseS] = "lowercaseS"; //  's'
  const lowercaseT = 116;
  charCodes[charCodes["lowercaseT"] = lowercaseT] = "lowercaseT"; //  't'
  const lowercaseU = 117;
  charCodes[charCodes["lowercaseU"] = lowercaseU] = "lowercaseU"; //  'u'
  const lowercaseV = 118;
  charCodes[charCodes["lowercaseV"] = lowercaseV] = "lowercaseV"; //  'v'
  const lowercaseW = 119;
  charCodes[charCodes["lowercaseW"] = lowercaseW] = "lowercaseW"; //  'w'
  const lowercaseX = 120;
  charCodes[charCodes["lowercaseX"] = lowercaseX] = "lowercaseX"; //  'x'
  const lowercaseY = 121;
  charCodes[charCodes["lowercaseY"] = lowercaseY] = "lowercaseY"; //  'y'
  const lowercaseZ = 122;
  charCodes[charCodes["lowercaseZ"] = lowercaseZ] = "lowercaseZ"; //  'z'
  const leftCurlyBrace = 123;
  charCodes[charCodes["leftCurlyBrace"] = leftCurlyBrace] = "leftCurlyBrace"; //  '{'
  const verticalBar = 124;
  charCodes[charCodes["verticalBar"] = verticalBar] = "verticalBar"; //  '|'
  const rightCurlyBrace = 125;
  charCodes[charCodes["rightCurlyBrace"] = rightCurlyBrace] = "rightCurlyBrace"; //  '}'
  const tilde = 126;
  charCodes[charCodes["tilde"] = tilde] = "tilde"; //  '~'
  const nonBreakingSpace = 160;
  charCodes[charCodes["nonBreakingSpace"] = nonBreakingSpace] = "nonBreakingSpace";
  // eslint-disable-next-line no-irregular-whitespace
  const oghamSpaceMark = 5760;
  charCodes[charCodes["oghamSpaceMark"] = oghamSpaceMark] = "oghamSpaceMark"; // ''
  const lineSeparator = 8232;
  charCodes[charCodes["lineSeparator"] = lineSeparator] = "lineSeparator";
  const paragraphSeparator = 8233;
  charCodes[charCodes["paragraphSeparator"] = paragraphSeparator] = "paragraphSeparator";
})(charCodes || (exports.charCodes = charCodes = {}));
function isDigit(code) {
  return code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF;
}
exports.isDigit = isDigit;
}),
/* --- node_modules/sucrase/dist/util/getIdentifierNames.js --- */
"node_modules/sucrase/dist/util/getIdentifierNames.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");

/**
 * Get all identifier names in the code, in order, including duplicates.
 */
function getIdentifierNames(code, tokens) {
  const names = [];
  for (const token of tokens) {
    if (token.type === _types.TokenType.name) {
      names.push(code.slice(token.start, token.end));
    }
  }
  return names;
}
exports.default = getIdentifierNames;
}),
/* --- src/kame-ts-interface-checker-stub.js --- */
"src/kame-ts-interface-checker-stub.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

const hasOwnProperty = Object.prototype.hasOwnProperty;
const noop = () => {};
module.exports = {
  union: noop,
  lit: noop,
  iface: noop,
  array: noop,
  opt: noop,
  createCheckers(inputs) {
    const checkers = {};
    for (let key in inputs) {
      if (hasOwnProperty.call(inputs, key)) {
        checkers[key] = {
          check() {},
          strictCheck() {}
        };
      }
    }
    return checkers;
  }
};
}),
/* --- node_modules/sucrase/dist/Options-gen-types.js --- */
"node_modules/sucrase/dist/Options-gen-types.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
} /**
  * This module was automatically generated by `ts-interface-builder`
  */
var _tsinterfacechecker = _kame_require_("src/kame-ts-interface-checker-stub.js");
var t = _interopRequireWildcard(_tsinterfacechecker);
// tslint:disable:object-literal-key-quotes

const Transform = t.union(t.lit("jsx"), t.lit("typescript"), t.lit("flow"), t.lit("imports"), t.lit("react-hot-loader"), t.lit("jest"));
exports.Transform = Transform;
const SourceMapOptions = t.iface([], {
  compiledFilename: "string"
});
exports.SourceMapOptions = SourceMapOptions;
const Options = t.iface([], {
  transforms: t.array("Transform"),
  disableESTransforms: t.opt("boolean"),
  jsxRuntime: t.opt(t.union(t.lit("classic"), t.lit("automatic"))),
  production: t.opt("boolean"),
  jsxImportSource: t.opt("string"),
  jsxPragma: t.opt("string"),
  jsxFragmentPragma: t.opt("string"),
  preserveDynamicImport: t.opt("boolean"),
  injectCreateRequireForImportRequire: t.opt("boolean"),
  enableLegacyTypeScriptModuleInterop: t.opt("boolean"),
  enableLegacyBabel5ModuleInterop: t.opt("boolean"),
  sourceMapOptions: t.opt("SourceMapOptions"),
  filePath: t.opt("string")
});
exports.Options = Options;
const exportedTypeSuite = {
  Transform: exports.Transform,
  SourceMapOptions: exports.SourceMapOptions,
  Options: exports.Options
};
exports.default = exportedTypeSuite;
}),
/* --- node_modules/sucrase/dist/parser/traverser/base.js --- */
"node_modules/sucrase/dist/parser/traverser/base.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _state = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/state.js");
var _state2 = _interopRequireDefault(_state);
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
exports.isJSXEnabled;
exports.isTypeScriptEnabled;
exports.isFlowEnabled;
exports.state;
exports.input;
exports.nextContextId;
function getNextContextId() {
  return exports.nextContextId++;
}
exports.getNextContextId = getNextContextId;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function augmentError(error) {
  if ("pos" in error) {
    const loc = locationForIndex(error.pos);
    error.message += ` (${loc.line}:${loc.column})`;
    error.loc = loc;
  }
  return error;
}
exports.augmentError = augmentError;
class Loc {
  constructor(line, column) {
    this.line = line;
    this.column = column;
  }
}
exports.Loc = Loc;
function locationForIndex(pos) {
  let line = 1;
  let column = 1;
  for (let i = 0; i < pos; i++) {
    if (exports.input.charCodeAt(i) === _charcodes.charCodes.lineFeed) {
      line++;
      column = 1;
    } else {
      column++;
    }
  }
  return new Loc(line, column);
}
exports.locationForIndex = locationForIndex;
function initParser(inputCode, isJSXEnabledArg, isTypeScriptEnabledArg, isFlowEnabledArg) {
  exports.input = inputCode;
  exports.state = new (0, _state2.default)();
  exports.nextContextId = 1;
  exports.isJSXEnabled = isJSXEnabledArg;
  exports.isTypeScriptEnabled = isTypeScriptEnabledArg;
  exports.isFlowEnabled = isFlowEnabledArg;
}
exports.initParser = initParser;
}),
/* --- node_modules/sucrase/dist/parser/traverser/index.js --- */
"node_modules/sucrase/dist/parser/traverser/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _index = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _statement = _kame_require_("node_modules/sucrase/dist/parser/traverser/statement.js");
function parseFile() {
  // If enabled, skip leading hashbang line.
  if (_base.state.pos === 0 && _base.input.charCodeAt(0) === _charcodes.charCodes.numberSign && _base.input.charCodeAt(1) === _charcodes.charCodes.exclamationMark) {
    _index.skipLineComment.call(void 0, 2);
  }
  _index.nextToken.call(void 0);
  return _statement.parseTopLevel.call(void 0);
}
exports.parseFile = parseFile;
}),
/* --- node_modules/sucrase/dist/util/isAsyncOperation.js --- */
"node_modules/sucrase/dist/util/isAsyncOperation.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");

/**
 * Determine whether this optional chain or nullish coalescing operation has any await statements in
 * it. If so, we'll need to transpile to an async operation.
 *
 * We compute this by walking the length of the operation and returning true if we see an await
 * keyword used as a real await (rather than an object key or property access). Nested optional
 * chain/nullish operations need to be tracked but don't silence await, but a nested async function
 * (or any other nested scope) will make the await not count.
 */
function isAsyncOperation(tokens) {
  let index = tokens.currentIndex();
  let depth = 0;
  const startToken = tokens.currentToken();
  do {
    const token = tokens.tokens[index];
    if (token.isOptionalChainStart) {
      depth++;
    }
    if (token.isOptionalChainEnd) {
      depth--;
    }
    depth += token.numNullishCoalesceStarts;
    depth -= token.numNullishCoalesceEnds;
    if (token.contextualKeyword === _keywords.ContextualKeyword._await && token.identifierRole == null && token.scopeDepth === startToken.scopeDepth) {
      return true;
    }
    index += 1;
  } while (depth > 0 && index < tokens.tokens.length);
  return false;
}
exports.default = isAsyncOperation;
}),
/* --- node_modules/sucrase/dist/util/getClassInfo.js --- */
"node_modules/sucrase/dist/util/getClassInfo.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");

/**
 * Get information about the class fields for this class, given a token processor pointing to the
 * open-brace at the start of the class.
 */
function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms) {
  const snapshot = tokens.snapshot();
  const headerInfo = processClassHeader(tokens);
  let constructorInitializerStatements = [];
  const instanceInitializerNames = [];
  const staticInitializerNames = [];
  let constructorInsertPos = null;
  const fields = [];
  const rangesToRemove = [];
  const classContextId = tokens.currentToken().contextId;
  if (classContextId == null) {
    throw new Error("Expected non-null class context ID on class open-brace.");
  }
  tokens.nextToken();
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)) {
    if (tokens.matchesContextual(_keywords.ContextualKeyword._constructor) && !tokens.currentToken().isType) {
      ({
        constructorInitializerStatements,
        constructorInsertPos
      } = processConstructor(tokens));
    } else if (tokens.matches1(_types.TokenType.semi)) {
      if (!disableESTransforms) {
        rangesToRemove.push({
          start: tokens.currentIndex(),
          end: tokens.currentIndex() + 1
        });
      }
      tokens.nextToken();
    } else if (tokens.currentToken().isType) {
      tokens.nextToken();
    } else {
      // Either a method or a field. Skip to the identifier part.
      const statementStartIndex = tokens.currentIndex();
      let isStatic = false;
      let isESPrivate = false;
      let isDeclareOrAbstract = false;
      while (isAccessModifier(tokens.currentToken())) {
        if (tokens.matches1(_types.TokenType._static)) {
          isStatic = true;
        }
        if (tokens.matches1(_types.TokenType.hash)) {
          isESPrivate = true;
        }
        if (tokens.matches1(_types.TokenType._declare) || tokens.matches1(_types.TokenType._abstract)) {
          isDeclareOrAbstract = true;
        }
        tokens.nextToken();
      }
      if (isStatic && tokens.matches1(_types.TokenType.braceL)) {
        // This is a static block, so don't process it in any special way.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (isESPrivate) {
        // Sucrase doesn't attempt to transpile private fields; just leave them as-is.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (tokens.matchesContextual(_keywords.ContextualKeyword._constructor) && !tokens.currentToken().isType) {
        ({
          constructorInitializerStatements,
          constructorInsertPos
        } = processConstructor(tokens));
        continue;
      }
      const nameStartIndex = tokens.currentIndex();
      skipFieldName(tokens);
      if (tokens.matches1(_types.TokenType.lessThan) || tokens.matches1(_types.TokenType.parenL)) {
        // This is a method, so nothing to process.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      // There might be a type annotation that we need to skip.
      while (tokens.currentToken().isType) {
        tokens.nextToken();
      }
      if (tokens.matches1(_types.TokenType.eq)) {
        const equalsIndex = tokens.currentIndex();
        // This is an initializer, so we need to wrap in an initializer method.
        const valueEnd = tokens.currentToken().rhsEndIndex;
        if (valueEnd == null) {
          throw new Error("Expected rhsEndIndex on class field assignment.");
        }
        tokens.nextToken();
        while (tokens.currentIndex() < valueEnd) {
          rootTransformer.processToken();
        }
        let initializerName;
        if (isStatic) {
          initializerName = nameManager.claimFreeName("__initStatic");
          staticInitializerNames.push(initializerName);
        } else {
          initializerName = nameManager.claimFreeName("__init");
          instanceInitializerNames.push(initializerName);
        }
        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.
        fields.push({
          initializerName,
          equalsIndex,
          start: nameStartIndex,
          end: tokens.currentIndex()
        });
      } else if (!disableESTransforms || isDeclareOrAbstract) {
        // This is a regular field declaration, like `x;`. With the class transform enabled, we just
        // remove the line so that no output is produced. With the class transform disabled, we
        // usually want to preserve the declaration (but still strip types), but if the `declare`
        // or `abstract` keyword is specified, we should remove the line to avoid initializing the
        // value to undefined.
        rangesToRemove.push({
          start: statementStartIndex,
          end: tokens.currentIndex()
        });
      }
    }
  }
  tokens.restoreToSnapshot(snapshot);
  if (disableESTransforms) {
    // With ES transforms disabled, we don't want to transform regular class
    // field declarations, and we don't need to do any additional tricks to
    // reference the constructor for static init, but we still need to transform
    // TypeScript field initializers defined as constructor parameters and we
    // still need to remove `declare` fields. For now, we run the same code
    // path but omit any field information, as if the class had no field
    // declarations. In the future, when we fully drop the class fields
    // transform, we can simplify this code significantly.
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames: [],
      staticInitializerNames: [],
      constructorInsertPos,
      fields: [],
      rangesToRemove
    };
  } else {
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames,
      staticInitializerNames,
      constructorInsertPos,
      fields,
      rangesToRemove
    };
  }
}
exports.default = getClassInfo;

/**
 * Move the token processor to the next method/field in the class.
 *
 * To do that, we seek forward to the next start of a class name (either an open
 * bracket or an identifier, or the closing curly brace), then seek backward to
 * include any access modifiers.
 */
function skipToNextClassElement(tokens, classContextId) {
  tokens.nextToken();
  while (tokens.currentToken().contextId !== classContextId) {
    tokens.nextToken();
  }
  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {
    tokens.previousToken();
  }
}
function processClassHeader(tokens) {
  const classToken = tokens.currentToken();
  const contextId = classToken.contextId;
  if (contextId == null) {
    throw new Error("Expected context ID on class token.");
  }
  const isExpression = classToken.isExpression;
  if (isExpression == null) {
    throw new Error("Expected isExpression on class token.");
  }
  let className = null;
  let hasSuperclass = false;
  tokens.nextToken();
  if (tokens.matches1(_types.TokenType.name)) {
    className = tokens.identifierName();
  }
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)) {
    // If this has a superclass, there will always be an `extends` token. If it doesn't have a
    // superclass, only type parameters and `implements` clauses can show up here, all of which
    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count
    // as having a superclass.
    if (tokens.matches1(_types.TokenType._extends) && !tokens.currentToken().isType) {
      hasSuperclass = true;
    }
    tokens.nextToken();
  }
  return {
    isExpression,
    className,
    hasSuperclass
  };
}

/**
 * Extract useful information out of a constructor, starting at the "constructor" name.
 */
function processConstructor(tokens) {
  const constructorInitializerStatements = [];
  tokens.nextToken();
  const constructorContextId = tokens.currentToken().contextId;
  if (constructorContextId == null) {
    throw new Error("Expected context ID on open-paren starting constructor params.");
  }
  // Advance through parameters looking for access modifiers.
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.parenR, constructorContextId)) {
    if (tokens.currentToken().contextId === constructorContextId) {
      // Current token is an open paren or comma just before a param, so check
      // that param for access modifiers.
      tokens.nextToken();
      if (isAccessModifier(tokens.currentToken())) {
        tokens.nextToken();
        while (isAccessModifier(tokens.currentToken())) {
          tokens.nextToken();
        }
        const token = tokens.currentToken();
        if (token.type !== _types.TokenType.name) {
          throw new Error("Expected identifier after access modifiers in constructor arg.");
        }
        const name = tokens.identifierNameForToken(token);
        constructorInitializerStatements.push(`this.${name} = ${name}`);
      }
    } else {
      tokens.nextToken();
    }
  }
  // )
  tokens.nextToken();
  let constructorInsertPos = tokens.currentIndex();

  // Advance through body looking for a super call.
  let foundSuperCall = false;
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, constructorContextId)) {
    if (!foundSuperCall && tokens.matches2(_types.TokenType._super, _types.TokenType.parenL)) {
      tokens.nextToken();
      const superCallContextId = tokens.currentToken().contextId;
      if (superCallContextId == null) {
        throw new Error("Expected a context ID on the super call");
      }
      while (!tokens.matchesContextIdAndLabel(_types.TokenType.parenR, superCallContextId)) {
        tokens.nextToken();
      }
      constructorInsertPos = tokens.currentIndex();
      foundSuperCall = true;
    }
    tokens.nextToken();
  }
  // }
  tokens.nextToken();
  return {
    constructorInitializerStatements,
    constructorInsertPos
  };
}

/**
 * Determine if this is any token that can go before the name in a method/field.
 */
function isAccessModifier(token) {
  return [_types.TokenType._async, _types.TokenType._get, _types.TokenType._set, _types.TokenType.plus, _types.TokenType.minus, _types.TokenType._readonly, _types.TokenType._static, _types.TokenType._public, _types.TokenType._private, _types.TokenType._protected, _types.TokenType._override, _types.TokenType._abstract, _types.TokenType.star, _types.TokenType._declare, _types.TokenType.hash].includes(token.type);
}

/**
 * The next token or set of tokens is either an identifier or an expression in square brackets, for
 * a method or field name.
 */
function skipFieldName(tokens) {
  if (tokens.matches1(_types.TokenType.bracketL)) {
    const startToken = tokens.currentToken();
    const classContextId = startToken.contextId;
    if (classContextId == null) {
      throw new Error("Expected class context ID on computed name open bracket.");
    }
    while (!tokens.matchesContextIdAndLabel(_types.TokenType.bracketR, classContextId)) {
      tokens.nextToken();
    }
    tokens.nextToken();
  } else {
    tokens.nextToken();
  }
}
}),
/* --- node_modules/sucrase/dist/transformers/CJSImportTransformer.js --- */
"node_modules/sucrase/dist/transformers/CJSImportTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _elideImportEquals = _kame_require_("node_modules/sucrase/dist/util/elideImportEquals.js");
var _elideImportEquals2 = _interopRequireDefault(_elideImportEquals);
var _getDeclarationInfo = _kame_require_("node_modules/sucrase/dist/util/getDeclarationInfo.js");
var _getDeclarationInfo2 = _interopRequireDefault(_getDeclarationInfo);
var _getImportExportSpecifierInfo = _kame_require_("node_modules/sucrase/dist/util/getImportExportSpecifierInfo.js");
var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _removeMaybeImportAssertion = _kame_require_("node_modules/sucrase/dist/util/removeMaybeImportAssertion.js");
var _shouldElideDefaultExport = _kame_require_("node_modules/sucrase/dist/util/shouldElideDefaultExport.js");
var _shouldElideDefaultExport2 = _interopRequireDefault(_shouldElideDefaultExport);
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);

/**
 * Class for editing import statements when we are transforming to commonjs.
 */
class CJSImportTransformer extends _Transformer2.default {
  __init() {
    this.hadExport = false;
  }
  __init2() {
    this.hadNamedExport = false;
  }
  __init3() {
    this.hadDefaultExport = false;
  }
  constructor(rootTransformer, tokens, importProcessor, nameManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, isTypeScriptTransformEnabled, preserveDynamicImport) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.nameManager = nameManager;
    this.reactHotLoaderTransformer = reactHotLoaderTransformer;
    this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.preserveDynamicImport = preserveDynamicImport;
    CJSImportTransformer.prototype.__init.call(this);
    CJSImportTransformer.prototype.__init2.call(this);
    CJSImportTransformer.prototype.__init3.call(this);
    ;
    this.declarationInfo = isTypeScriptTransformEnabled ? _getDeclarationInfo2.default.call(void 0, tokens) : _getDeclarationInfo.EMPTY_DECLARATION_INFO;
  }
  getPrefixCode() {
    let prefix = "";
    if (this.hadExport) {
      prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
    }
    return prefix;
  }
  getSuffixCode() {
    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
      return "\nmodule.exports = exports.default;\n";
    }
    return "";
  }
  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches1(_types.TokenType._import)) {
      this.processImport();
      return true;
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._export) && !this.tokens.currentToken().isType) {
      this.hadExport = true;
      return this.processExport();
    }
    if (this.tokens.matches2(_types.TokenType.name, _types.TokenType.postIncDec)) {
      // Fall through to normal identifier matching if this doesn't apply.
      if (this.processPostIncDec()) {
        return true;
      }
    }
    if (this.tokens.matches1(_types.TokenType.name) || this.tokens.matches1(_types.TokenType.jsxName)) {
      return this.processIdentifier();
    }
    if (this.tokens.matches1(_types.TokenType.eq)) {
      return this.processAssignment();
    }
    if (this.tokens.matches1(_types.TokenType.assign)) {
      return this.processComplexAssignment();
    }
    if (this.tokens.matches1(_types.TokenType.preIncDec)) {
      return this.processPreIncDec();
    }
    return false;
  }
  processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.importProcessor.isTypeName(importName)) {
      // If this name is only used as a type, elide the whole import.
      _elideImportEquals2.default.call(void 0, this.tokens);
    } else {
      // Otherwise, switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
  processImport() {
    if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) {
      if (this.preserveDynamicImport) {
        // Bail out, only making progress for this one token.
        this.tokens.copyToken();
        return;
      }
      this.tokens.replaceToken("Promise.resolve().then(() => require");
      const contextId = this.tokens.currentToken().contextId;
      if (contextId == null) {
        throw new Error("Expected context ID on dynamic import invocation.");
      }
      this.tokens.copyToken();
      while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.parenR, contextId)) {
        this.rootTransformer.processToken();
      }
      this.tokens.replaceToken("))");
      return;
    }
    const wasOnlyTypes = this.removeImportAndDetectIfType();
    if (wasOnlyTypes) {
      this.tokens.removeToken();
    } else {
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      this.tokens.appendCode(this.importProcessor.claimImportCode(path));
    }
    _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);
    if (this.tokens.matches1(_types.TokenType.semi)) {
      this.tokens.removeToken();
    }
  }

  /**
   * Erase this import, and return true if it was either of the form "import type" or contained only
   * "type" named imports. Such imports should not even do a side-effect import.
   *
   * The position should end at the import string.
   */
  removeImportAndDetectIfType() {
    this.tokens.removeInitialToken();
    if (this.tokens.matchesContextual(_keywords.ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)) {
      // This is an "import type" statement, so exit early.
      this.removeRemainingImport();
      return true;
    }
    if (this.tokens.matches1(_types.TokenType.name) || this.tokens.matches1(_types.TokenType.star)) {
      // We have a default import or namespace import, so there must be some
      // non-type import.
      this.removeRemainingImport();
      return false;
    }
    if (this.tokens.matches1(_types.TokenType.string)) {
      // This is a bare import, so we should proceed with the import.
      return false;
    }
    let foundNonType = false;
    while (!this.tokens.matches1(_types.TokenType.string)) {
      // Check if any named imports are of the form "foo" or "foo as bar", with
      // no leading "type".
      if (!foundNonType && this.tokens.matches1(_types.TokenType.braceL) || this.tokens.matches1(_types.TokenType.comma)) {
        this.tokens.removeToken();
        if (this.tokens.matches2(_types.TokenType.name, _types.TokenType.comma) || this.tokens.matches2(_types.TokenType.name, _types.TokenType.braceR) || this.tokens.matches4(_types.TokenType.name, _types.TokenType.name, _types.TokenType.name, _types.TokenType.comma) || this.tokens.matches4(_types.TokenType.name, _types.TokenType.name, _types.TokenType.name, _types.TokenType.braceR)) {
          foundNonType = true;
        }
      }
      this.tokens.removeToken();
    }
    return !foundNonType;
  }
  removeRemainingImport() {
    while (!this.tokens.matches1(_types.TokenType.string)) {
      this.tokens.removeToken();
    }
  }
  processIdentifier() {
    const token = this.tokens.currentToken();
    if (token.shadowsGlobal) {
      return false;
    }
    if (token.identifierRole === _tokenizer.IdentifierRole.ObjectShorthand) {
      return this.processObjectShorthand();
    }
    if (token.identifierRole !== _tokenizer.IdentifierRole.Access) {
      return false;
    }
    const replacement = this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(token));
    if (!replacement) {
      return false;
    }
    // Tolerate any number of closing parens while looking for an opening paren
    // that indicates a function call.
    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
    while (possibleOpenParenIndex < this.tokens.tokens.length && this.tokens.tokens[possibleOpenParenIndex].type === _types.TokenType.parenR) {
      possibleOpenParenIndex++;
    }
    // Avoid treating imported functions as methods of their `exports` object
    // by using `(0, f)` when the identifier is in a paren expression. Else
    // use `Function.prototype.call` when the identifier is a guaranteed
    // function call. When using `call`, pass undefined as the context.
    if (this.tokens.tokens[possibleOpenParenIndex].type === _types.TokenType.parenL) {
      if (this.tokens.tokenAtRelativeIndex(1).type === _types.TokenType.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== _types.TokenType._new) {
        this.tokens.replaceToken(`${replacement}.call(void 0, `);
        // Remove the old paren.
        this.tokens.removeToken();
        // Balance out the new paren.
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(_types.TokenType.parenR);
      } else {
        // See here: http://2ality.com/2015/12/references.html
        this.tokens.replaceToken(`(0, ${replacement})`);
      }
    } else {
      this.tokens.replaceToken(replacement);
    }
    return true;
  }
  processObjectShorthand() {
    const identifier = this.tokens.identifierName();
    const replacement = this.importProcessor.getIdentifierReplacement(identifier);
    if (!replacement) {
      return false;
    }
    this.tokens.replaceToken(`${identifier}: ${replacement}`);
    return true;
  }
  processExport() {
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum) || this.tokens.matches3(_types.TokenType._export, _types.TokenType._const, _types.TokenType._enum)) {
      // Let the TypeScript transform handle it.
      return false;
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._default)) {
      this.hadDefaultExport = true;
      if (this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType._enum)) {
        // Flow export default enums need some special handling, so handle them
        // in that tranform rather than this one.
        return false;
      }
      this.processExportDefault();
      return true;
    }
    this.hadNamedExport = true;
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._var) || this.tokens.matches2(_types.TokenType._export, _types.TokenType._let) || this.tokens.matches2(_types.TokenType._export, _types.TokenType._const)) {
      this.processExportVar();
      return true;
    } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._function) ||
    // export async function
    this.tokens.matches3(_types.TokenType._export, _types.TokenType.name, _types.TokenType._function)) {
      this.processExportFunction();
      return true;
    } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._class) || this.tokens.matches3(_types.TokenType._export, _types.TokenType._abstract, _types.TokenType._class)) {
      this.processExportClass();
      return true;
    } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.braceL)) {
      this.processExportBindings();
      return true;
    } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.star)) {
      this.processExportStar();
      return true;
    } else if (this.tokens.matches3(_types.TokenType._export, _types.TokenType.name, _types.TokenType.braceL) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)) {
      // TS `export type {` case: just remove the export entirely.
      this.tokens.removeInitialToken();
      while (!this.tokens.matches1(_types.TokenType.braceR)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();

      // Remove type re-export `... } from './T'`
      if (this.tokens.matchesContextual(_keywords.ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.string)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);
      }
      return true;
    } else {
      throw new Error("Unrecognized export syntax.");
    }
  }
  processAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,
    // with `b` as the identifier, so nothing needs to be done in that case.
    if (identifierToken.isType || identifierToken.type !== _types.TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, _types.TokenType.dot)) {
      return false;
    }
    if (index >= 2 && [_types.TokenType._var, _types.TokenType._let, _types.TokenType._const].includes(this.tokens.tokens[index - 2].type)) {
      // Declarations don't need an extra assignment. This doesn't avoid the
      // assignment for comma-separated declarations, but it's still correct
      // since the assignment is just redundant.
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.copyToken();
    this.tokens.appendCode(` ${assignmentSnippet} =`);
    return true;
  }

  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
  processComplexAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    if (identifierToken.type !== _types.TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, _types.TokenType.dot)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(` = ${assignmentSnippet}`);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
  processPreIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== _types.TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    // Ignore things like ++a.b and ++a[b] and ++a().b.
    if (index + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(index + 2, _types.TokenType.dot) || this.tokens.matches1AtIndex(index + 2, _types.TokenType.bracketL) || this.tokens.matches1AtIndex(index + 2, _types.TokenType.parenL))) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(`${assignmentSnippet} = `);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
  processPostIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index];
    const operatorToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== _types.TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, _types.TokenType.dot)) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    const operatorCode = this.tokens.rawCodeForToken(operatorToken);
    // We might also replace the identifier with something like exports.x, so
    // do that replacement here as well.
    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
    if (operatorCode === "++") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
    } else if (operatorCode === "--") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
    } else {
      throw new Error(`Unexpected operator: ${operatorCode}`);
    }
    this.tokens.removeToken();
    return true;
  }
  processExportDefault() {
    if (this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._function, _types.TokenType.name) ||
    // export default async function
    this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType.name, _types.TokenType._function, _types.TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._async)) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      // Named function export case: change it to a top-level function
      // declaration followed by exports statement.
      const name = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._class, _types.TokenType.name) || this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType._abstract, _types.TokenType._class, _types.TokenType.name)) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(_types.TokenType._abstract)) {
        this.tokens.removeToken();
      }
      const name = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType.at)) {
      throw new Error("Export default statements with decorators are not yet supported.");
      // After this point, this is a plain "export default E" statement.
    } else if (_shouldElideDefaultExport2.default.call(void 0, this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export default e`,
      // where `e` is an identifier.
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
    } else if (this.reactHotLoaderTransformer) {
      // We need to assign E to a variable. Change "export default E" to
      // "let _default; exports.default = _default = E"
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);
      this.tokens.copyToken();
      this.tokens.appendCode(` = ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
    } else {
      // Change "export default E" to "exports.default = E"
      this.tokens.replaceToken("exports.");
      this.tokens.copyToken();
      this.tokens.appendCode(" =");
    }
  }

  /**
   * Transform a declaration like `export var`, `export let`, or `export const`.
   */
  processExportVar() {
    if (this.isSimpleExportVar()) {
      this.processSimpleExportVar();
    } else {
      this.processComplexExportVar();
    }
  }

  /**
   * Determine if the export is of the form:
   * export var/let/const [varName] = [expr];
   * In other words, determine if function name inference might apply.
   */
  isSimpleExportVar() {
    let tokenIndex = this.tokens.currentIndex();
    // export
    tokenIndex++;
    // var/let/const
    tokenIndex++;
    if (!this.tokens.matches1AtIndex(tokenIndex, _types.TokenType.name)) {
      return false;
    }
    tokenIndex++;
    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {
      tokenIndex++;
    }
    if (!this.tokens.matches1AtIndex(tokenIndex, _types.TokenType.eq)) {
      return false;
    }
    return true;
  }

  /**
   * Transform an `export var` declaration initializing a single variable.
   *
   * For example, this:
   * export const f = () => {};
   * becomes this:
   * const f = () => {}; exports.f = f;
   *
   * The variable is unused (e.g. exports.f has the true value of the export).
   * We need to produce an assignment of this form so that the function will
   * have an inferred name of "f", which wouldn't happen in the more general
   * case below.
   */
  processSimpleExportVar() {
    // export
    this.tokens.removeInitialToken();
    // var/let/const
    this.tokens.copyToken();
    const varName = this.tokens.identifierName();
    // x: number  ->  x
    while (!this.tokens.matches1(_types.TokenType.eq)) {
      this.rootTransformer.processToken();
    }
    const endIndex = this.tokens.currentToken().rhsEndIndex;
    if (endIndex == null) {
      throw new Error("Expected = token with an end index.");
    }
    while (this.tokens.currentIndex() < endIndex) {
      this.rootTransformer.processToken();
    }
    this.tokens.appendCode(`; exports.${varName} = ${varName}`);
  }

  /**
   * Transform normal declaration exports, including handling destructuring.
   * For example, this:
   * export const {x: [a = 2, b], c} = d;
   * becomes this:
   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
   */
  processComplexExportVar() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const needsParens = this.tokens.matches1(_types.TokenType.braceL);
    if (needsParens) {
      this.tokens.appendCode("(");
    }
    let depth = 0;
    while (true) {
      if (this.tokens.matches1(_types.TokenType.braceL) || this.tokens.matches1(_types.TokenType.dollarBraceL) || this.tokens.matches1(_types.TokenType.bracketL)) {
        depth++;
        this.tokens.copyToken();
      } else if (this.tokens.matches1(_types.TokenType.braceR) || this.tokens.matches1(_types.TokenType.bracketR)) {
        depth--;
        this.tokens.copyToken();
      } else if (depth === 0 && !this.tokens.matches1(_types.TokenType.name) && !this.tokens.currentToken().isType) {
        break;
      } else if (this.tokens.matches1(_types.TokenType.eq)) {
        // Default values might have assignments in the RHS that we want to ignore, so skip past
        // them.
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        while (this.tokens.currentIndex() < endIndex) {
          this.rootTransformer.processToken();
        }
      } else {
        const token = this.tokens.currentToken();
        if (_tokenizer.isDeclaration.call(void 0, token)) {
          const name = this.tokens.identifierName();
          let replacement = this.importProcessor.getIdentifierReplacement(name);
          if (replacement === null) {
            throw new Error(`Expected a replacement for ${name} in \`export var\` syntax.`);
          }
          if (_tokenizer.isObjectShorthandDeclaration.call(void 0, token)) {
            replacement = `${name}: ${replacement}`;
          }
          this.tokens.replaceToken(replacement);
        } else {
          this.rootTransformer.processToken();
        }
      }
    }
    if (needsParens) {
      // Seek to the end of the RHS.
      const endIndex = this.tokens.currentToken().rhsEndIndex;
      if (endIndex == null) {
        throw new Error("Expected = token with an end index.");
      }
      while (this.tokens.currentIndex() < endIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(")");
    }
  }

  /**
   * Transform this:
   * export function foo() {}
   * into this:
   * function foo() {} exports.foo = foo;
   */
  processExportFunction() {
    this.tokens.replaceToken("");
    const name = this.processNamedFunction();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }

  /**
   * Skip past a function with a name and return that name.
   */
  processNamedFunction() {
    if (this.tokens.matches1(_types.TokenType._function)) {
      this.tokens.copyToken();
    } else if (this.tokens.matches2(_types.TokenType.name, _types.TokenType._function)) {
      if (!this.tokens.matchesContextual(_keywords.ContextualKeyword._async)) {
        throw new Error("Expected async keyword in function export.");
      }
      this.tokens.copyToken();
      this.tokens.copyToken();
    }
    if (this.tokens.matches1(_types.TokenType.star)) {
      this.tokens.copyToken();
    }
    if (!this.tokens.matches1(_types.TokenType.name)) {
      throw new Error("Expected identifier for exported function name.");
    }
    const name = this.tokens.identifierName();
    this.tokens.copyToken();
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
    }
    this.tokens.copyExpectedToken(_types.TokenType.parenL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(_types.TokenType.parenR);
    this.rootTransformer.processPossibleTypeRange();
    this.tokens.copyExpectedToken(_types.TokenType.braceL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(_types.TokenType.braceR);
    return name;
  }

  /**
   * Transform this:
   * export class A {}
   * into this:
   * class A {} exports.A = A;
   */
  processExportClass() {
    this.tokens.removeInitialToken();
    if (this.tokens.matches1(_types.TokenType._abstract)) {
      this.tokens.removeToken();
    }
    const name = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }

  /**
   * Transform this:
   * export {a, b as c};
   * into this:
   * exports.a = a; exports.c = b;
   *
   * OR
   *
   * Transform this:
   * export {a, b as c} from './foo';
   * into the pre-generated Object.defineProperty code from the ImportProcessor.
   *
   * For the first case, if the TypeScript transform is enabled, we need to skip
   * exports that are only defined as types.
   */
  processExportBindings() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const exportStatements = [];
    while (true) {
      if (this.tokens.matches1(_types.TokenType.braceR)) {
        this.tokens.removeToken();
        break;
      }
      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);
      while (this.tokens.currentIndex() < specifierInfo.endIndex) {
        this.tokens.removeToken();
      }
      if (!specifierInfo.isType && !this.shouldElideExportedIdentifier(specifierInfo.leftName)) {
        const localName = specifierInfo.leftName;
        const exportedName = specifierInfo.rightName;
        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);
        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);
      }
      if (this.tokens.matches1(_types.TokenType.braceR)) {
        this.tokens.removeToken();
        break;
      }
      if (this.tokens.matches2(_types.TokenType.comma, _types.TokenType.braceR)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        break;
      } else if (this.tokens.matches1(_types.TokenType.comma)) {
        this.tokens.removeToken();
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
      }
    }
    if (this.tokens.matchesContextual(_keywords.ContextualKeyword._from)) {
      // This is an export...from, so throw away the normal named export code
      // and use the Object.defineProperty code from ImportProcessor.
      this.tokens.removeToken();
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);
    } else {
      // This is a normal named export, so use that.
      this.tokens.appendCode(exportStatements.join(" "));
    }
    if (this.tokens.matches1(_types.TokenType.semi)) {
      this.tokens.removeToken();
    }
  }
  processExportStar() {
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(_types.TokenType.string)) {
      this.tokens.removeToken();
    }
    const path = this.tokens.stringValue();
    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
    _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);
    if (this.tokens.matches1(_types.TokenType.semi)) {
      this.tokens.removeToken();
    }
  }
  shouldElideExportedIdentifier(name) {
    return this.isTypeScriptTransformEnabled && !this.declarationInfo.valueDeclarations.has(name);
  }
}
exports.default = CJSImportTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/ESMImportTransformer.js --- */
"node_modules/sucrase/dist/transformers/ESMImportTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _elideImportEquals = _kame_require_("node_modules/sucrase/dist/util/elideImportEquals.js");
var _elideImportEquals2 = _interopRequireDefault(_elideImportEquals);
var _getDeclarationInfo = _kame_require_("node_modules/sucrase/dist/util/getDeclarationInfo.js");
var _getDeclarationInfo2 = _interopRequireDefault(_getDeclarationInfo);
var _getImportExportSpecifierInfo = _kame_require_("node_modules/sucrase/dist/util/getImportExportSpecifierInfo.js");
var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = _kame_require_("node_modules/sucrase/dist/util/getNonTypeIdentifiers.js");
var _removeMaybeImportAssertion = _kame_require_("node_modules/sucrase/dist/util/removeMaybeImportAssertion.js");
var _shouldElideDefaultExport = _kame_require_("node_modules/sucrase/dist/util/shouldElideDefaultExport.js");
var _shouldElideDefaultExport2 = _interopRequireDefault(_shouldElideDefaultExport);
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
class ESMImportTransformer extends _Transformer2.default {
  constructor(tokens, nameManager, helperManager, reactHotLoaderTransformer, isTypeScriptTransformEnabled, options) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    this.helperManager = helperManager;
    this.reactHotLoaderTransformer = reactHotLoaderTransformer;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    ;
    this.nonTypeIdentifiers = isTypeScriptTransformEnabled ? _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, tokens, options) : new Set();
    this.declarationInfo = isTypeScriptTransformEnabled ? _getDeclarationInfo2.default.call(void 0, tokens) : _getDeclarationInfo.EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }
  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches4(_types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches5(_types.TokenType._export, _types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._type)) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.braceL)) {
      return this.processNamedExports();
    }
    if (this.tokens.matches3(_types.TokenType._export, _types.TokenType.name, _types.TokenType.braceL) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)) {
      // TS `export type {` case: just remove the export entirely.
      this.tokens.removeInitialToken();
      while (!this.tokens.matches1(_types.TokenType.braceR)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();

      // Remove type re-export `... } from './T'`
      if (this.tokens.matchesContextual(_keywords.ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.string)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);
      }
      return true;
    }
    return false;
  }
  processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.isTypeName(importName)) {
      // If this name is only used as a type, elide the whole import.
      _elideImportEquals2.default.call(void 0, this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }
  processImport() {
    if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }
    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(_types.TokenType.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);
      if (this.tokens.matches1(_types.TokenType.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
  removeImportTypeBindings() {
    this.tokens.copyExpectedToken(_types.TokenType._import);
    if (this.tokens.matchesContextual(_keywords.ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)) {
      // This is an "import type" statement, so exit early.
      return true;
    }
    if (this.tokens.matches1(_types.TokenType.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }
    let foundNonTypeImport = false;
    let needsComma = false;
    if (this.tokens.matches1(_types.TokenType.name)) {
      if (this.isTypeName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(_types.TokenType.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(_types.TokenType.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to add it back if necessary.
          needsComma = true;
          this.tokens.removeToken();
        }
      }
    }
    if (this.tokens.matches1(_types.TokenType.star)) {
      if (this.isTypeName(this.tokens.identifierNameAtRelativeIndex(2))) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        this.tokens.removeToken();
      } else {
        if (needsComma) {
          this.tokens.appendCode(",");
        }
        foundNonTypeImport = true;
        this.tokens.copyExpectedToken(_types.TokenType.star);
        this.tokens.copyExpectedToken(_types.TokenType.name);
        this.tokens.copyExpectedToken(_types.TokenType.name);
      }
    } else if (this.tokens.matches1(_types.TokenType.braceL)) {
      if (needsComma) {
        this.tokens.appendCode(",");
      }
      this.tokens.copyToken();
      while (!this.tokens.matches1(_types.TokenType.braceR)) {
        const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);
        if (specifierInfo.isType || this.isTypeName(specifierInfo.rightName)) {
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.removeToken();
          }
          if (this.tokens.matches1(_types.TokenType.comma)) {
            this.tokens.removeToken();
          }
        } else {
          foundNonTypeImport = true;
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.copyToken();
          }
          if (this.tokens.matches1(_types.TokenType.comma)) {
            this.tokens.copyToken();
          }
        }
      }
      this.tokens.copyExpectedToken(_types.TokenType.braceR);
    }
    return !foundNonTypeImport;
  }
  isTypeName(name) {
    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);
  }
  processExportDefault() {
    if (_shouldElideDefaultExport2.default.call(void 0, this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export default e`,
      // where `e` is an identifier.
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
      return true;
    }
    const alreadyHasName = this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._function, _types.TokenType.name) ||
    // export default async function
    this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType.name, _types.TokenType._function, _types.TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._async) || this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._class, _types.TokenType.name) || this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType._abstract, _types.TokenType._class, _types.TokenType.name);
    if (!alreadyHasName && this.reactHotLoaderTransformer) {
      // This is a plain "export default E" statement and we need to assign E to a variable.
      // Change "export default E" to "let _default; export default _default = E"
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; export`);
      this.tokens.copyToken();
      this.tokens.appendCode(` ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
      return true;
    }
    return false;
  }

  /**
   * In TypeScript, we need to remove named exports that were never declared or only declared as a
   * type.
   */
  processNamedExports() {
    if (!this.isTypeScriptTransformEnabled) {
      return false;
    }
    this.tokens.copyExpectedToken(_types.TokenType._export);
    this.tokens.copyExpectedToken(_types.TokenType.braceL);
    while (!this.tokens.matches1(_types.TokenType.braceR)) {
      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);
      if (specifierInfo.isType || this.shouldElideExportedName(specifierInfo.leftName)) {
        // Type export, so remove all tokens, including any comma.
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.removeToken();
        }
        if (this.tokens.matches1(_types.TokenType.comma)) {
          this.tokens.removeToken();
        }
      } else {
        // Non-type export, so copy all tokens, including any comma.
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.copyToken();
        }
        if (this.tokens.matches1(_types.TokenType.comma)) {
          this.tokens.copyToken();
        }
      }
    }
    this.tokens.copyExpectedToken(_types.TokenType.braceR);
    return true;
  }

  /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */
  shouldElideExportedName(name) {
    return this.isTypeScriptTransformEnabled && this.declarationInfo.typeDeclarations.has(name) && !this.declarationInfo.valueDeclarations.has(name);
  }
}
exports.default = ESMImportTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/FlowTransformer.js --- */
"node_modules/sucrase/dist/transformers/FlowTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);
class FlowTransformer extends _Transformer2.default {
  constructor(rootTransformer, tokens, isImportsTransformEnabled) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.isImportsTransformEnabled = isImportsTransformEnabled;
    ;
  }
  process() {
    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._enum)) {
      this.processEnum();
      return true;
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum)) {
      this.processNamedExportEnum();
      return true;
    }
    if (this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType._enum)) {
      this.processDefaultExportEnum();
      return true;
    }
    return false;
  }

  /**
   * Handle a declaration like:
   * export enum E ...
   *
   * With this imports transform, this becomes:
   * const E = [[enum]]; exports.E = E;
   *
   * otherwise, it becomes:
   * export const E = [[enum]];
   */
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      // export
      this.tokens.removeInitialToken();
      const enumName = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum();
      this.tokens.appendCode(` exports.${enumName} = ${enumName};`);
    } else {
      this.tokens.copyToken();
      this.processEnum();
    }
  }

  /**
   * Handle a declaration like:
   * export default enum E
   *
   * With the imports transform, this becomes:
   * const E = [[enum]]; exports.default = E;
   *
   * otherwise, it becomes:
   * const E = [[enum]]; export default E;
   */
  processDefaultExportEnum() {
    // export
    this.tokens.removeInitialToken();
    // default
    this.tokens.removeToken();
    const enumName = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum();
    if (this.isImportsTransformEnabled) {
      this.tokens.appendCode(` exports.default = ${enumName};`);
    } else {
      this.tokens.appendCode(` export default ${enumName};`);
    }
  }

  /**
   * Transpile flow enums to invoke the "flow-enums-runtime" library.
   *
   * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
   * but if future flexibility is needed, we could expose a config option for
   * this string (similar to configurable JSX). Even when targeting ESM, the
   * default behavior of babel-plugin-transform-flow-enums is to use require
   * rather than injecting an import.
   *
   * Flow enums are quite a bit simpler than TS enums and have some convenient
   * constraints:
   * - Element initializers must be either always present or always absent. That
   *   means that we can use fixed lookahead on the first element (if any) and
   *   assume that all elements are like that.
   * - The right-hand side of an element initializer must be a literal value,
   *   not a complex expression and not referencing other elements. That means
   *   we can simply copy a single token.
   *
   * Enums can be broken up into three basic cases:
   *
   * Mirrored enums:
   * enum E {A, B}
   *   ->
   * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
   *
   * Initializer enums:
   * enum E {A = 1, B = 2}
   *   ->
   * const E = require("flow-enums-runtime")({A: 1, B: 2});
   *
   * Symbol enums:
   * enum E of symbol {A, B}
   *   ->
   * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
   *
   * We can statically detect which of the three cases this is by looking at the
   * "of" declaration (if any) and seeing if the first element has an initializer.
   * Since the other transform details are so similar between the three cases, we
   * use a single implementation and vary the transform within processEnumElement
   * based on case.
   */
  processEnum() {
    // enum E -> const E
    this.tokens.replaceToken("const");
    this.tokens.copyExpectedToken(_types.TokenType.name);
    let isSymbolEnum = false;
    if (this.tokens.matchesContextual(_keywords.ContextualKeyword._of)) {
      this.tokens.removeToken();
      isSymbolEnum = this.tokens.matchesContextual(_keywords.ContextualKeyword._symbol);
      this.tokens.removeToken();
    }
    const hasInitializers = this.tokens.matches3(_types.TokenType.braceL, _types.TokenType.name, _types.TokenType.eq);
    this.tokens.appendCode(' = require("flow-enums-runtime")');
    const isMirrored = !isSymbolEnum && !hasInitializers;
    this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored ? ".Mirrored([" : "({");
    while (!this.tokens.matches1(_types.TokenType.braceR)) {
      // ... is allowed at the end and has no runtime behavior.
      if (this.tokens.matches1(_types.TokenType.ellipsis)) {
        this.tokens.removeToken();
        break;
      }
      this.processEnumElement(isSymbolEnum, hasInitializers);
      if (this.tokens.matches1(_types.TokenType.comma)) {
        this.tokens.copyToken();
      }
    }
    this.tokens.replaceToken(isMirrored ? "]);" : "});");
  }

  /**
   * Process an individual enum element, producing either an array element or an
   * object element based on what type of enum this is.
   */
  processEnumElement(isSymbolEnum, hasInitializers) {
    if (isSymbolEnum) {
      // Symbol enums never have initializers and are expanded to object elements.
      // A, -> A: Symbol("A"),
      const elementName = this.tokens.identifierName();
      this.tokens.copyToken();
      this.tokens.appendCode(`: Symbol("${elementName}")`);
    } else if (hasInitializers) {
      // Initializers are expanded to object elements.
      // A = 1, -> A: 1,
      this.tokens.copyToken();
      this.tokens.replaceTokenTrimmingLeftWhitespace(":");
      this.tokens.copyToken();
    } else {
      // Enum elements without initializers become string literal array elements.
      // A, -> "A",
      this.tokens.replaceToken(`"${this.tokens.identifierName()}"`);
    }
  }
}
exports.default = FlowTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/JestHoistTransformer.js --- */
"node_modules/sucrase/dist/transformers/JestHoistTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _optionalChain(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
      return undefined;
    }
    if (op === 'access' || op === 'optionalAccess') {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === 'call' || op === 'optionalCall') {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);
const JEST_GLOBAL_NAME = "jest";
const HOISTED_METHODS = ["mock", "unmock", "enableAutomock", "disableAutomock"];

/**
 * Implementation of babel-plugin-jest-hoist, which hoists up some jest method
 * calls above the imports to allow them to override other imports.
 *
 * To preserve line numbers, rather than directly moving the jest.mock code, we
 * wrap each invocation in a function statement and then call the function from
 * the top of the file.
 */
class JestHoistTransformer extends _Transformer2.default {
  __init() {
    this.hoistedFunctionNames = [];
  }
  constructor(rootTransformer, tokens, nameManager, importProcessor) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.nameManager = nameManager;
    this.importProcessor = importProcessor;
    JestHoistTransformer.prototype.__init.call(this);
    ;
  }
  process() {
    if (this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(_types.TokenType.name, _types.TokenType.dot, _types.TokenType.name, _types.TokenType.parenL) && this.tokens.identifierName() === JEST_GLOBAL_NAME) {
      // TODO: This only works if imports transform is active, which it will be for jest.
      //       But if jest adds module support and we no longer need the import transform, this needs fixing.
      if (_optionalChain([this, 'access', _ => _.importProcessor, 'optionalAccess', _2 => _2.getGlobalNames, 'call', _3 => _3(), 'optionalAccess', _4 => _4.has, 'call', _5 => _5(JEST_GLOBAL_NAME)])) {
        return false;
      }
      return this.extractHoistedCalls();
    }
    return false;
  }
  getHoistedCode() {
    if (this.hoistedFunctionNames.length > 0) {
      // This will be placed before module interop code, but that's fine since
      // imports aren't allowed in module mock factories.
      return this.hoistedFunctionNames.map(name => `${name}();`).join("");
    }
    return "";
  }

  /**
   * Extracts any methods calls on the jest-object that should be hoisted.
   *
   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,
   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.
   *
   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.
   */
  extractHoistedCalls() {
    // We're handling a chain of calls where `jest` may or may not need to be inserted for each call
    // in the chain, so remove the initial `jest` to make the loop implementation cleaner.
    this.tokens.removeToken();
    // Track some state so that multiple non-hoisted chained calls in a row keep their chaining
    // syntax.
    let followsNonHoistedJestCall = false;

    // Iterate through all chained calls on the jest object.
    while (this.tokens.matches3(_types.TokenType.dot, _types.TokenType.name, _types.TokenType.parenL)) {
      const methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
      const shouldHoist = HOISTED_METHODS.includes(methodName);
      if (shouldHoist) {
        // We've matched e.g. `.mock(...)` or similar call.
        // Replace the initial `.` with `function __jestHoist(){jest.`
        const hoistedFunctionName = this.nameManager.claimFreeName("__jestHoist");
        this.hoistedFunctionNames.push(hoistedFunctionName);
        this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(_types.TokenType.parenR);
        this.tokens.appendCode(";}");
        followsNonHoistedJestCall = false;
      } else {
        // This is a non-hoisted method, so just transform the code as usual.
        if (followsNonHoistedJestCall) {
          // If we didn't hoist the previous call, we can leave the code as-is to chain off of the
          // previous method call. It's important to preserve the code here because we don't know
          // for sure that the method actually returned the jest object for chaining.
          this.tokens.copyToken();
        } else {
          // If we hoisted the previous call, we know it returns the jest object back, so we insert
          // the identifier `jest` to continue the chain.
          this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`);
        }
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(_types.TokenType.parenR);
        followsNonHoistedJestCall = true;
      }
    }
    return true;
  }
}
exports.default = JestHoistTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/JSXTransformer.js --- */
"node_modules/sucrase/dist/transformers/JSXTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _xhtml = _kame_require_("node_modules/sucrase/dist/parser/plugins/jsx/xhtml.js");
var _xhtml2 = _interopRequireDefault(_xhtml);
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _getJSXPragmaInfo = _kame_require_("node_modules/sucrase/dist/util/getJSXPragmaInfo.js");
var _getJSXPragmaInfo2 = _interopRequireDefault(_getJSXPragmaInfo);
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);
class JSXTransformer extends _Transformer2.default {
  // State for calculating the line number of each JSX tag in development.
  __init() {
    this.lastLineNumber = 1;
  }
  __init2() {
    this.lastIndex = 0;
  }

  // In development, variable name holding the name of the current file.
  __init3() {
    this.filenameVarName = null;
  }
  // Mapping of claimed names for imports in the automatic transform, e,g.
  // {jsx: "_jsx"}. This determines which imports to generate in the prefix.
  __init4() {
    this.esmAutomaticImportNameResolutions = {};
  }
  // When automatically adding imports in CJS mode, we store the variable name
  // holding the imported CJS module so we can require it in the prefix.
  __init5() {
    this.cjsAutomaticModuleNameResolutions = {};
  }
  constructor(rootTransformer, tokens, importProcessor, nameManager, options) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.nameManager = nameManager;
    this.options = options;
    JSXTransformer.prototype.__init.call(this);
    JSXTransformer.prototype.__init2.call(this);
    JSXTransformer.prototype.__init3.call(this);
    JSXTransformer.prototype.__init4.call(this);
    JSXTransformer.prototype.__init5.call(this);
    ;
    this.jsxPragmaInfo = _getJSXPragmaInfo2.default.call(void 0, options);
    this.isAutomaticRuntime = options.jsxRuntime === "automatic";
    this.jsxImportSource = options.jsxImportSource || "react";
  }
  process() {
    if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {
      this.processJSXTag();
      return true;
    }
    return false;
  }
  getPrefixCode() {
    let prefix = "";
    if (this.filenameVarName) {
      prefix += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`;
    }
    if (this.isAutomaticRuntime) {
      if (this.importProcessor) {
        // CJS mode: emit require statements for all modules that were referenced.
        for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions)) {
          prefix += `var ${resolvedName} = require("${path}");`;
        }
      } else {
        // ESM mode: consolidate and emit import statements for referenced names.
        const {
          createElement: createElementResolution,
          ...otherResolutions
        } = this.esmAutomaticImportNameResolutions;
        if (createElementResolution) {
          prefix += `import {createElement as ${createElementResolution}} from "${this.jsxImportSource}";`;
        }
        const importSpecifiers = Object.entries(otherResolutions).map(([name, resolvedName]) => `${name} as ${resolvedName}`).join(", ");
        if (importSpecifiers) {
          const importPath = this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
          prefix += `import {${importSpecifiers}} from "${importPath}";`;
        }
      }
    }
    return prefix;
  }
  processJSXTag() {
    const {
      jsxRole,
      start
    } = this.tokens.currentToken();
    // Calculate line number information at the very start (if in development
    // mode) so that the information is guaranteed to be queried in token order.
    const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);
    if (this.isAutomaticRuntime && jsxRole !== _tokenizer.JSXRole.KeyAfterPropSpread) {
      this.transformTagToJSXFunc(elementLocationCode, jsxRole);
    } else {
      this.transformTagToCreateElement(elementLocationCode);
    }
  }
  getElementLocationCode(firstTokenStart) {
    const lineNumber = this.getLineNumberForIndex(firstTokenStart);
    return `lineNumber: ${lineNumber}`;
  }

  /**
   * Get the line number for this source position. This is calculated lazily and
   * must be called in increasing order by index.
   */
  getLineNumberForIndex(index) {
    const code = this.tokens.code;
    while (this.lastIndex < index && this.lastIndex < code.length) {
      if (code[this.lastIndex] === "\n") {
        this.lastLineNumber++;
      }
      this.lastIndex++;
    }
    return this.lastLineNumber;
  }

  /**
   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is
   * the primary transformation for the automatic transform.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * jsxs('div', {a: 1, children: ["Hello", x]}, 2)
   */
  transformTagToJSXFunc(elementLocationCode, jsxRole) {
    const isStatic = jsxRole === _tokenizer.JSXRole.StaticChildren;
    // First tag is always jsxTagStart.
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));
    let keyCode = null;
    if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
      // Fragment syntax.
      this.tokens.replaceToken(`${this.getFragmentCode()}, {`);
      this.processAutomaticChildrenAndEndProps(jsxRole);
    } else {
      // Normal open tag or self-closing tag.
      this.processTagIntro();
      this.tokens.appendCode(", {");
      keyCode = this.processProps(true);
      if (this.tokens.matches2(_types.TokenType.slash, _types.TokenType.jsxTagEnd)) {
        // Self-closing tag, no children to add, so close the props.
        this.tokens.appendCode("}");
      } else if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
        // Tag with children.
        this.tokens.removeToken();
        this.processAutomaticChildrenAndEndProps(jsxRole);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
      // If a key was present, move it to its own arg. Note that moving code
      // like this will cause line numbers to get out of sync within the JSX
      // element if the key expression has a newline in it. This is unfortunate,
      // but hopefully should be rare.
      if (keyCode) {
        this.tokens.appendCode(`, ${keyCode}`);
      }
    }
    if (!this.options.production) {
      // If the key wasn't already added, add it now so we can correctly set
      // positional args for jsxDEV.
      if (keyCode === null) {
        this.tokens.appendCode(", void 0");
      }
      this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);
    }
    // We're at the close-tag or the end of a self-closing tag, so remove
    // everything else and close the function call.
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }

  /**
   * Convert the current JSX element to a createElement call. In the classic
   * runtime, this is the only case. In the automatic runtime, this is called
   * as a fallback in some situations.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * React.createElement('div', {a: 1, key: 2}, "Hello", x)
   */
  transformTagToCreateElement(elementLocationCode) {
    // First tag is always jsxTagStart.
    this.tokens.replaceToken(this.getCreateElementInvocationCode());
    if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
      // Fragment syntax.
      this.tokens.replaceToken(`${this.getFragmentCode()}, null`);
      this.processChildren(true);
    } else {
      // Normal open tag or self-closing tag.
      this.processTagIntro();
      this.processPropsObjectWithDevInfo(elementLocationCode);
      if (this.tokens.matches2(_types.TokenType.slash, _types.TokenType.jsxTagEnd)) {
        // Self-closing tag; no children to process.
      } else if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
        // Tag with children and a close-tag; process the children as args.
        this.tokens.removeToken();
        this.processChildren(true);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
    }
    // We're at the close-tag or the end of a self-closing tag, so remove
    // everything else and close the function call.
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }

  /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */
  getJSXFuncInvocationCode(isStatic) {
    if (this.options.production) {
      if (isStatic) {
        return this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime");
      } else {
        return this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime");
      }
    } else {
      return this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
    }
  }

  /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedFuncInvocation("createElement", "");
    } else {
      const {
        jsxPragmaInfo
      } = this;
      const resolvedPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base : jsxPragmaInfo.base;
      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;
    }
  }

  /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */
  getFragmentCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedName("Fragment", this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
    } else {
      const {
        jsxPragmaInfo
      } = this;
      const resolvedFragmentPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) || jsxPragmaInfo.fragmentBase : jsxPragmaInfo.fragmentBase;
      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;
    }
  }

  /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */
  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {
    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);
    if (this.importProcessor) {
      return `${funcCode}.call(void 0, `;
    } else {
      return `${funcCode}(`;
    }
  }
  claimAutoImportedName(funcName, importPathSuffix) {
    if (this.importProcessor) {
      // CJS mode: claim a name for the module and mark it for import.
      const path = this.jsxImportSource + importPathSuffix;
      if (!this.cjsAutomaticModuleNameResolutions[path]) {
        this.cjsAutomaticModuleNameResolutions[path] = this.importProcessor.getFreeIdentifierForPath(path);
      }
      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;
    } else {
      // ESM mode: claim a name for this function and add it to the names that
      // should be auto-imported when the prefix is generated.
      if (!this.esmAutomaticImportNameResolutions[funcName]) {
        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(`_${funcName}`);
      }
      return this.esmAutomaticImportNameResolutions[funcName];
    }
  }

  /**
   * Process the first part of a tag, before any props.
   */
  processTagIntro() {
    // Walk forward until we see one of these patterns:
    // jsxName to start the first prop, preceded by another jsxName to end the tag name.
    // jsxName to start the first prop, preceded by greaterThan to end the type argument.
    // [open brace] to start the first prop.
    // [jsxTagEnd] to end the open-tag.
    // [slash, jsxTagEnd] to end the self-closing tag.
    let introEnd = this.tokens.currentIndex() + 1;
    while (this.tokens.tokens[introEnd].isType || !this.tokens.matches2AtIndex(introEnd - 1, _types.TokenType.jsxName, _types.TokenType.jsxName) && !this.tokens.matches2AtIndex(introEnd - 1, _types.TokenType.greaterThan, _types.TokenType.jsxName) && !this.tokens.matches1AtIndex(introEnd, _types.TokenType.braceL) && !this.tokens.matches1AtIndex(introEnd, _types.TokenType.jsxTagEnd) && !this.tokens.matches2AtIndex(introEnd, _types.TokenType.slash, _types.TokenType.jsxTagEnd)) {
      introEnd++;
    }
    if (introEnd === this.tokens.currentIndex() + 1) {
      const tagName = this.tokens.identifierName();
      if (startsWithLowerCase(tagName)) {
        this.tokens.replaceToken(`'${tagName}'`);
      }
    }
    while (this.tokens.currentIndex() < introEnd) {
      this.rootTransformer.processToken();
    }
  }

  /**
   * Starting at the beginning of the props, add the props argument to
   * React.createElement, including the comma before it.
   */
  processPropsObjectWithDevInfo(elementLocationCode) {
    const devProps = this.options.production ? "" : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;
    if (!this.tokens.matches1(_types.TokenType.jsxName) && !this.tokens.matches1(_types.TokenType.braceL)) {
      if (devProps) {
        this.tokens.appendCode(`, {${devProps}}`);
      } else {
        this.tokens.appendCode(`, null`);
      }
      return;
    }
    this.tokens.appendCode(`, {`);
    this.processProps(false);
    if (devProps) {
      this.tokens.appendCode(` ${devProps}}`);
    } else {
      this.tokens.appendCode("}");
    }
  }

  /**
   * Transform the core part of the props, assuming that a { has already been
   * inserted before us and that a } will be inserted after us.
   *
   * If extractKeyCode is true (i.e. when using any jsx... function), any prop
   * named "key" has its code captured and returned rather than being emitted to
   * the output code. This shifts line numbers, and emitting the code later will
   * correct line numbers again. If no key is found or if extractKeyCode is
   * false, this function returns null.
   */
  processProps(extractKeyCode) {
    let keyCode = null;
    while (true) {
      if (this.tokens.matches2(_types.TokenType.jsxName, _types.TokenType.eq)) {
        // This is a regular key={value} or key="value" prop.
        const propName = this.tokens.identifierName();
        if (extractKeyCode && propName === "key") {
          if (keyCode !== null) {
            // The props list has multiple keys. Different implementations are
            // inconsistent about what to do here: as of this writing, Babel and
            // swc keep the *last* key and completely remove the rest, while
            // TypeScript uses the *first* key and leaves the others as regular
            // props. The React team collaborated with Babel on the
            // implementation of this behavior, so presumably the Babel behavior
            // is the one to use.
            // Since we won't ever be emitting the previous key code, we need to
            // at least emit its newlines here so that the line numbers match up
            // in the long run.
            this.tokens.appendCode(keyCode.replace(/[^\n]/g, ""));
          }
          // key
          this.tokens.removeToken();
          // =
          this.tokens.removeToken();
          const snapshot = this.tokens.snapshot();
          this.processPropValue();
          keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);
          // Don't add a comma
          continue;
        } else {
          this.processPropName(propName);
          this.tokens.replaceToken(": ");
          this.processPropValue();
        }
      } else if (this.tokens.matches1(_types.TokenType.jsxName)) {
        // This is a shorthand prop like <input disabled />.
        const propName = this.tokens.identifierName();
        this.processPropName(propName);
        this.tokens.appendCode(": true");
      } else if (this.tokens.matches1(_types.TokenType.braceL)) {
        // This is prop spread, like <div {...getProps()}>, which we can pass
        // through fairly directly as an object spread.
        this.tokens.replaceToken("");
        this.rootTransformer.processBalancedCode();
        this.tokens.replaceToken("");
      } else {
        break;
      }
      this.tokens.appendCode(",");
    }
    return keyCode;
  }
  processPropName(propName) {
    if (propName.includes("-")) {
      this.tokens.replaceToken(`'${propName}'`);
    } else {
      this.tokens.copyToken();
    }
  }
  processPropValue() {
    if (this.tokens.matches1(_types.TokenType.braceL)) {
      this.tokens.replaceToken("");
      this.rootTransformer.processBalancedCode();
      this.tokens.replaceToken("");
    } else if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {
      this.processJSXTag();
    } else {
      this.processStringPropValue();
    }
  }
  processStringPropValue() {
    const token = this.tokens.currentToken();
    const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXStringValueLiteral(valueCode);
    this.tokens.replaceToken(literalCode + replacementCode);
  }

  /**
   * Starting in the middle of the props object literal, produce an additional
   * prop for the children and close the object literal.
   */
  processAutomaticChildrenAndEndProps(jsxRole) {
    if (jsxRole === _tokenizer.JSXRole.StaticChildren) {
      this.tokens.appendCode(" children: [");
      this.processChildren(false);
      this.tokens.appendCode("]}");
    } else {
      // The parser information tells us whether we will see a real child or if
      // all remaining children (if any) will resolve to empty. If there are no
      // non-empty children, don't emit a children prop at all, but still
      // process children so that we properly transform the code into nothing.
      if (jsxRole === _tokenizer.JSXRole.OneChild) {
        this.tokens.appendCode(" children: ");
      }
      this.processChildren(false);
      this.tokens.appendCode("}");
    }
  }

  /**
   * Transform children into a comma-separated list, which will be either
   * arguments to createElement or array elements of a children prop.
   */
  processChildren(needsInitialComma) {
    let needsComma = needsInitialComma;
    while (true) {
      if (this.tokens.matches2(_types.TokenType.jsxTagStart, _types.TokenType.slash)) {
        // Closing tag, so no more children.
        return;
      }
      let didEmitElement = false;
      if (this.tokens.matches1(_types.TokenType.braceL)) {
        if (this.tokens.matches2(_types.TokenType.braceL, _types.TokenType.braceR)) {
          // Empty interpolations and comment-only interpolations are allowed
          // and don't create an extra child arg.
          this.tokens.replaceToken("");
          this.tokens.replaceToken("");
        } else {
          // Interpolated expression.
          this.tokens.replaceToken(needsComma ? ", " : "");
          this.rootTransformer.processBalancedCode();
          this.tokens.replaceToken("");
          didEmitElement = true;
        }
      } else if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {
        // Child JSX element
        this.tokens.appendCode(needsComma ? ", " : "");
        this.processJSXTag();
        didEmitElement = true;
      } else if (this.tokens.matches1(_types.TokenType.jsxText) || this.tokens.matches1(_types.TokenType.jsxEmptyText)) {
        didEmitElement = this.processChildTextElement(needsComma);
      } else {
        throw new Error("Unexpected token when processing JSX children.");
      }
      if (didEmitElement) {
        needsComma = true;
      }
    }
  }

  /**
   * Turn a JSX text element into a string literal, or nothing at all if the JSX
   * text resolves to the empty string.
   *
   * Returns true if a string literal is emitted, false otherwise.
   */
  processChildTextElement(needsComma) {
    const token = this.tokens.currentToken();
    const valueCode = this.tokens.code.slice(token.start, token.end);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXTextLiteral(valueCode);
    if (literalCode === '""') {
      this.tokens.replaceToken(replacementCode);
      return false;
    } else {
      this.tokens.replaceToken(`${needsComma ? ", " : ""}${literalCode}${replacementCode}`);
      return true;
    }
  }
  getDevSource(elementLocationCode) {
    return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;
  }
  getFilenameVarName() {
    if (!this.filenameVarName) {
      this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName");
    }
    return this.filenameVarName;
  }
}
exports.default = JSXTransformer;

/**
 * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.
 *
 * Really only treat anything starting with a-z as tag names.  `_`, `$`, ``
 * should be treated as copmonent names
 */
function startsWithLowerCase(s) {
  const firstChar = s.charCodeAt(0);
  return firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ;
}
exports.startsWithLowerCase = startsWithLowerCase;

/**
 * Turn the given jsxText string into a JS string literal. Leading and trailing
 * whitespace on lines is removed, except immediately after the open-tag and
 * before the close-tag. Empty lines are completely removed, and spaces are
 * added between lines after that.
 *
 * We use JSON.stringify to introduce escape characters as necessary, and trim
 * the start and end of each line and remove blank lines.
 */
function formatJSXTextLiteral(text) {
  let result = "";
  let whitespace = "";
  let isInInitialLineWhitespace = false;
  let seenNonWhitespace = false;
  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    if (c === " " || c === "\t" || c === "\r") {
      if (!isInInitialLineWhitespace) {
        whitespace += c;
      }
    } else if (c === "\n") {
      whitespace = "";
      isInInitialLineWhitespace = true;
    } else {
      if (seenNonWhitespace && isInInitialLineWhitespace) {
        result += " ";
      }
      result += whitespace;
      whitespace = "";
      if (c === "&") {
        const {
          entity,
          newI
        } = processEntity(text, i + 1);
        i = newI - 1;
        result += entity;
      } else {
        result += c;
      }
      seenNonWhitespace = true;
      isInInitialLineWhitespace = false;
    }
  }
  if (!isInInitialLineWhitespace) {
    result += whitespace;
  }
  return JSON.stringify(result);
}

/**
 * Produce the code that should be printed after the JSX text string literal,
 * with most content removed, but all newlines preserved and all spacing at the
 * end preserved.
 */
function formatJSXTextReplacement(text) {
  let numNewlines = 0;
  let numSpaces = 0;
  for (const c of text) {
    if (c === "\n") {
      numNewlines++;
      numSpaces = 0;
    } else if (c === " ") {
      numSpaces++;
    }
  }
  return "\n".repeat(numNewlines) + " ".repeat(numSpaces);
}

/**
 * Format a string in the value position of a JSX prop.
 *
 * Use the same implementation as convertAttribute from
 * babel-helper-builder-react-jsx.
 */
function formatJSXStringValueLiteral(text) {
  let result = "";
  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    if (c === "\n") {
      if (/\s/.test(text[i + 1])) {
        result += " ";
        while (i < text.length && /\s/.test(text[i + 1])) {
          i++;
        }
      } else {
        result += "\n";
      }
    } else if (c === "&") {
      const {
        entity,
        newI
      } = processEntity(text, i + 1);
      result += entity;
      i = newI - 1;
    } else {
      result += c;
    }
  }
  return JSON.stringify(result);
}

/**
 * Starting at a &, see if there's an HTML entity (specified by name, decimal
 * char code, or hex char code) and return it if so.
 *
 * Modified from jsxReadString in babel-parser.
 */
function processEntity(text, indexAfterAmpersand) {
  let str = "";
  let count = 0;
  let entity;
  let i = indexAfterAmpersand;
  if (text[i] === "#") {
    let radix = 10;
    i++;
    let numStart;
    if (text[i] === "x") {
      radix = 16;
      i++;
      numStart = i;
      while (i < text.length && isHexDigit(text.charCodeAt(i))) {
        i++;
      }
    } else {
      numStart = i;
      while (i < text.length && isDecimalDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (text[i] === ";") {
      const numStr = text.slice(numStart, i);
      if (numStr) {
        i++;
        entity = String.fromCodePoint(parseInt(numStr, radix));
      }
    }
  } else {
    while (i < text.length && count++ < 10) {
      const ch = text[i];
      i++;
      if (ch === ";") {
        entity = _xhtml2.default.get(str);
        break;
      }
      str += ch;
    }
  }
  if (!entity) {
    return {
      entity: "&",
      newI: indexAfterAmpersand
    };
  }
  return {
    entity,
    newI: i
  };
}
function isDecimalDigit(code) {
  return code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9;
}
function isHexDigit(code) {
  return code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9 || code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF || code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF;
}
}),
/* --- node_modules/sucrase/dist/transformers/NumericSeparatorTransformer.js --- */
"node_modules/sucrase/dist/transformers/NumericSeparatorTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);
class NumericSeparatorTransformer extends _Transformer2.default {
  constructor(tokens) {
    super();
    this.tokens = tokens;
    ;
  }
  process() {
    if (this.tokens.matches1(_types.TokenType.num)) {
      const code = this.tokens.currentTokenCode();
      if (code.includes("_")) {
        this.tokens.replaceToken(code.replace(/_/g, ""));
        return true;
      }
    }
    return false;
  }
}
exports.default = NumericSeparatorTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/OptionalCatchBindingTransformer.js --- */
"node_modules/sucrase/dist/transformers/OptionalCatchBindingTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);
class OptionalCatchBindingTransformer extends _Transformer2.default {
  constructor(tokens, nameManager) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    ;
  }
  process() {
    if (this.tokens.matches2(_types.TokenType._catch, _types.TokenType.braceL)) {
      this.tokens.copyToken();
      this.tokens.appendCode(` (${this.nameManager.claimFreeName("e")})`);
      return true;
    }
    return false;
  }
}
exports.default = OptionalCatchBindingTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/OptionalChainingNullishTransformer.js --- */
"node_modules/sucrase/dist/transformers/OptionalChainingNullishTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);

/**
 * Transformer supporting the optional chaining and nullish coalescing operators.
 *
 * Tech plan here:
 * https://github.com/alangpierce/sucrase/wiki/Sucrase-Optional-Chaining-and-Nullish-Coalescing-Technical-Plan
 *
 * The prefix and suffix code snippets are handled by TokenProcessor, and this transformer handles
 * the operators themselves.
 */
class OptionalChainingNullishTransformer extends _Transformer2.default {
  constructor(tokens, nameManager) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    ;
  }
  process() {
    if (this.tokens.matches1(_types.TokenType.nullishCoalescing)) {
      const token = this.tokens.currentToken();
      if (this.tokens.tokens[token.nullishStartIndex].isAsyncOperation) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (");
      } else {
        this.tokens.replaceTokenTrimmingLeftWhitespace(", () => (");
      }
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._delete)) {
      const nextToken = this.tokens.tokenAtRelativeIndex(1);
      if (nextToken.isOptionalChainStart) {
        this.tokens.removeInitialToken();
        return true;
      }
    }
    const token = this.tokens.currentToken();
    const chainStart = token.subscriptStartIndex;
    if (chainStart != null && this.tokens.tokens[chainStart].isOptionalChainStart &&
    // Super subscripts can't be optional (since super is never null/undefined), and the syntax
    // relies on the subscript being intact, so leave this token alone.
    this.tokens.tokenAtRelativeIndex(-1).type !== _types.TokenType._super) {
      const param = this.nameManager.claimFreeName("_");
      let arrowStartSnippet;
      if (chainStart > 0 && this.tokens.matches1AtIndex(chainStart - 1, _types.TokenType._delete) && this.isLastSubscriptInChain()) {
        // Delete operations are special: we already removed the delete keyword, and to still
        // perform a delete, we need to insert a delete in the very last part of the chain, which
        // in correct code will always be a property access.
        arrowStartSnippet = `${param} => delete ${param}`;
      } else {
        arrowStartSnippet = `${param} => ${param}`;
      }
      if (this.tokens.tokens[chainStart].isAsyncOperation) {
        arrowStartSnippet = `async ${arrowStartSnippet}`;
      }
      if (this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.parenL) || this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.lessThan)) {
        if (this.justSkippedSuper()) {
          this.tokens.appendCode(".bind(this)");
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);
      } else if (this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.bracketL)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);
      } else if (this.tokens.matches1(_types.TokenType.questionDot)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);
      } else if (this.tokens.matches1(_types.TokenType.dot)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);
      } else if (this.tokens.matches1(_types.TokenType.bracketL)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);
      } else if (this.tokens.matches1(_types.TokenType.parenL)) {
        if (this.justSkippedSuper()) {
          this.tokens.appendCode(".bind(this)");
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);
      } else {
        throw new Error("Unexpected subscript operator in optional chain.");
      }
      return true;
    }
    return false;
  }

  /**
   * Determine if the current token is the last of its chain, so that we know whether it's eligible
   * to have a delete op inserted.
   *
   * We can do this by walking forward until we determine one way or another. Each
   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in
   * a nesting way, so we can track depth and walk to the end of the chain (the point where the
   * depth goes negative) and see if any other subscript token is after us in the chain.
   */
  isLastSubscriptInChain() {
    let depth = 0;
    for (let i = this.tokens.currentIndex() + 1;; i++) {
      if (i >= this.tokens.tokens.length) {
        throw new Error("Reached the end of the code while finding the end of the access chain.");
      }
      if (this.tokens.tokens[i].isOptionalChainStart) {
        depth++;
      } else if (this.tokens.tokens[i].isOptionalChainEnd) {
        depth--;
      }
      if (depth < 0) {
        return true;
      }

      // This subscript token is a later one in the same chain.
      if (depth === 0 && this.tokens.tokens[i].subscriptStartIndex != null) {
        return false;
      }
    }
  }

  /**
   * Determine if we are the open-paren in an expression like super.a()?.b.
   *
   * We can do this by walking backward to find the previous subscript. If that subscript was
   * preceded by a super, then we must be the subscript after it, so if this is a call expression,
   * we'll need to attach the right context.
   */
  justSkippedSuper() {
    let depth = 0;
    let index = this.tokens.currentIndex() - 1;
    while (true) {
      if (index < 0) {
        throw new Error("Reached the start of the code while finding the start of the access chain.");
      }
      if (this.tokens.tokens[index].isOptionalChainStart) {
        depth--;
      } else if (this.tokens.tokens[index].isOptionalChainEnd) {
        depth++;
      }
      if (depth < 0) {
        return false;
      }

      // This subscript token is a later one in the same chain.
      if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) {
        return this.tokens.tokens[index - 1].type === _types.TokenType._super;
      }
      index--;
    }
  }
}
exports.default = OptionalChainingNullishTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/ReactDisplayNameTransformer.js --- */
"node_modules/sucrase/dist/transformers/ReactDisplayNameTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);

/**
 * Implementation of babel-plugin-transform-react-display-name, which adds a
 * display name to usages of React.createClass and createReactClass.
 */
class ReactDisplayNameTransformer extends _Transformer2.default {
  constructor(rootTransformer, tokens, importProcessor, options) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.options = options;
    ;
  }
  process() {
    const startIndex = this.tokens.currentIndex();
    if (this.tokens.identifierName() === "createReactClass") {
      const newName = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
      if (newName) {
        this.tokens.replaceToken(`(0, ${newName})`);
      } else {
        this.tokens.copyToken();
      }
      this.tryProcessCreateClassCall(startIndex);
      return true;
    }
    if (this.tokens.matches3(_types.TokenType.name, _types.TokenType.dot, _types.TokenType.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
      const newName = this.importProcessor ? this.importProcessor.getIdentifierReplacement("React") || "React" : "React";
      if (newName) {
        this.tokens.replaceToken(newName);
        this.tokens.copyToken();
        this.tokens.copyToken();
      } else {
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.tokens.copyToken();
      }
      this.tryProcessCreateClassCall(startIndex);
      return true;
    }
    return false;
  }

  /**
   * This is called with the token position at the open-paren.
   */
  tryProcessCreateClassCall(startIndex) {
    const displayName = this.findDisplayName(startIndex);
    if (!displayName) {
      return;
    }
    if (this.classNeedsDisplayName()) {
      this.tokens.copyExpectedToken(_types.TokenType.parenL);
      this.tokens.copyExpectedToken(_types.TokenType.braceL);
      this.tokens.appendCode(`displayName: '${displayName}',`);
      this.rootTransformer.processBalancedCode();
      this.tokens.copyExpectedToken(_types.TokenType.braceR);
      this.tokens.copyExpectedToken(_types.TokenType.parenR);
    }
  }
  findDisplayName(startIndex) {
    if (startIndex < 2) {
      return null;
    }
    if (this.tokens.matches2AtIndex(startIndex - 2, _types.TokenType.name, _types.TokenType.eq)) {
      // This is an assignment (or declaration) and the LHS is either an identifier or a member
      // expression ending in an identifier, so use that identifier name.
      return this.tokens.identifierNameAtIndex(startIndex - 2);
    }
    if (startIndex >= 2 && this.tokens.tokens[startIndex - 2].identifierRole === _tokenizer.IdentifierRole.ObjectKey) {
      // This is an object literal value.
      return this.tokens.identifierNameAtIndex(startIndex - 2);
    }
    if (this.tokens.matches2AtIndex(startIndex - 2, _types.TokenType._export, _types.TokenType._default)) {
      return this.getDisplayNameFromFilename();
    }
    return null;
  }
  getDisplayNameFromFilename() {
    const filePath = this.options.filePath || "unknown";
    const pathSegments = filePath.split("/");
    const filename = pathSegments[pathSegments.length - 1];
    const dotIndex = filename.lastIndexOf(".");
    const baseFilename = dotIndex === -1 ? filename : filename.slice(0, dotIndex);
    if (baseFilename === "index" && pathSegments[pathSegments.length - 2]) {
      return pathSegments[pathSegments.length - 2];
    } else {
      return baseFilename;
    }
  }

  /**
   * We only want to add a display name when this is a function call containing
   * one argument, which is an object literal without `displayName` as an
   * existing key.
   */
  classNeedsDisplayName() {
    let index = this.tokens.currentIndex();
    if (!this.tokens.matches2(_types.TokenType.parenL, _types.TokenType.braceL)) {
      return false;
    }
    // The block starts on the {, and we expect any displayName key to be in
    // that context. We need to ignore other other contexts to avoid matching
    // nested displayName keys.
    const objectStartIndex = index + 1;
    const objectContextId = this.tokens.tokens[objectStartIndex].contextId;
    if (objectContextId == null) {
      throw new Error("Expected non-null context ID on object open-brace.");
    }
    for (; index < this.tokens.tokens.length; index++) {
      const token = this.tokens.tokens[index];
      if (token.type === _types.TokenType.braceR && token.contextId === objectContextId) {
        index++;
        break;
      }
      if (this.tokens.identifierNameAtIndex(index) === "displayName" && this.tokens.tokens[index].identifierRole === _tokenizer.IdentifierRole.ObjectKey && token.contextId === objectContextId) {
        // We found a displayName key, so bail out.
        return false;
      }
    }
    if (index === this.tokens.tokens.length) {
      throw new Error("Unexpected end of input when processing React class.");
    }

    // If we got this far, we know we have createClass with an object with no
    // display name, so we want to proceed as long as that was the only argument.
    return this.tokens.matches1AtIndex(index, _types.TokenType.parenR) || this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.parenR);
  }
}
exports.default = ReactDisplayNameTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/ReactHotLoaderTransformer.js --- */
"node_modules/sucrase/dist/transformers/ReactHotLoaderTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);
class ReactHotLoaderTransformer extends _Transformer2.default {
  __init() {
    this.extractedDefaultExportName = null;
  }
  constructor(tokens, filePath) {
    super();
    this.tokens = tokens;
    this.filePath = filePath;
    ReactHotLoaderTransformer.prototype.__init.call(this);
    ;
  }
  setExtractedDefaultExportName(extractedDefaultExportName) {
    this.extractedDefaultExportName = extractedDefaultExportName;
  }
  getPrefixCode() {
    return `
      (function () {
        var enterModule = require('react-hot-loader').enterModule;
        enterModule && enterModule(module);
      })();`.replace(/\s+/g, " ").trim();
  }
  getSuffixCode() {
    const topLevelNames = new Set();
    for (const token of this.tokens.tokens) {
      if (!token.isType && _tokenizer.isTopLevelDeclaration.call(void 0, token) && token.identifierRole !== _tokenizer.IdentifierRole.ImportDeclaration) {
        topLevelNames.add(this.tokens.identifierNameForToken(token));
      }
    }
    const namesToRegister = Array.from(topLevelNames).map(name => ({
      variableName: name,
      uniqueLocalName: name
    }));
    if (this.extractedDefaultExportName) {
      namesToRegister.push({
        variableName: this.extractedDefaultExportName,
        uniqueLocalName: "default"
      });
    }
    return `
;(function () {
  var reactHotLoader = require('react-hot-loader').default;
  var leaveModule = require('react-hot-loader').leaveModule;
  if (!reactHotLoader) {
    return;
  }
${namesToRegister.map(({
      variableName,
      uniqueLocalName
    }) => `  reactHotLoader.register(${variableName}, "${uniqueLocalName}", ${JSON.stringify(this.filePath || "")});`).join("\n")}
  leaveModule(module);
})();`;
  }
  process() {
    return false;
  }
}
exports.default = ReactHotLoaderTransformer;
}),
/* --- node_modules/sucrase/dist/transformers/TypeScriptTransformer.js --- */
"node_modules/sucrase/dist/transformers/TypeScriptTransformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _isIdentifier = _kame_require_("node_modules/sucrase/dist/util/isIdentifier.js");
var _isIdentifier2 = _interopRequireDefault(_isIdentifier);
var _Transformer = _kame_require_("node_modules/sucrase/dist/transformers/Transformer.js");
var _Transformer2 = _interopRequireDefault(_Transformer);
class TypeScriptTransformer extends _Transformer2.default {
  constructor(rootTransformer, tokens, isImportsTransformEnabled) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.isImportsTransformEnabled = isImportsTransformEnabled;
    ;
  }
  process() {
    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._public) || this.tokens.matches1(_types.TokenType._protected) || this.tokens.matches1(_types.TokenType._private) || this.tokens.matches1(_types.TokenType._abstract) || this.tokens.matches1(_types.TokenType._readonly) || this.tokens.matches1(_types.TokenType._override) || this.tokens.matches1(_types.TokenType.nonNullAssertion)) {
      this.tokens.removeInitialToken();
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._enum) || this.tokens.matches2(_types.TokenType._const, _types.TokenType._enum)) {
      this.processEnum();
      return true;
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum) || this.tokens.matches3(_types.TokenType._export, _types.TokenType._const, _types.TokenType._enum)) {
      this.processEnum(true);
      return true;
    }
    return false;
  }
  processEnum(isExport = false) {
    // We might have "export const enum", so just remove all relevant tokens.
    this.tokens.removeInitialToken();
    while (this.tokens.matches1(_types.TokenType._const) || this.tokens.matches1(_types.TokenType._enum)) {
      this.tokens.removeToken();
    }
    const enumName = this.tokens.identifierName();
    this.tokens.removeToken();
    if (isExport && !this.isImportsTransformEnabled) {
      this.tokens.appendCode("export ");
    }
    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);
    this.tokens.copyExpectedToken(_types.TokenType.braceL);
    this.processEnumBody(enumName);
    this.tokens.copyExpectedToken(_types.TokenType.braceR);
    if (isExport && this.isImportsTransformEnabled) {
      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);
    } else {
      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);
    }
  }

  /**
   * Transform an enum into equivalent JS. This has complexity in a few places:
   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.
   * - Enum keys are allowed to be referenced in later enum values.
   * - Enum keys are allowed to be strings.
   * - When enum values are omitted, they should follow an auto-increment behavior.
   */
  processEnumBody(enumName) {
    // Code that can be used to reference the previous enum member, or null if this is the first
    // enum member.
    let previousValueCode = null;
    while (true) {
      if (this.tokens.matches1(_types.TokenType.braceR)) {
        break;
      }
      const {
        nameStringCode,
        variableName
      } = this.extractEnumKeyInfo(this.tokens.currentToken());
      this.tokens.removeInitialToken();
      if (this.tokens.matches3(_types.TokenType.eq, _types.TokenType.string, _types.TokenType.comma) || this.tokens.matches3(_types.TokenType.eq, _types.TokenType.string, _types.TokenType.braceR)) {
        this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);
      } else if (this.tokens.matches1(_types.TokenType.eq)) {
        this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);
      } else {
        this.processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode);
      }
      if (this.tokens.matches1(_types.TokenType.comma)) {
        this.tokens.removeToken();
      }
      if (variableName != null) {
        previousValueCode = variableName;
      } else {
        previousValueCode = `${enumName}[${nameStringCode}]`;
      }
    }
  }

  /**
   * Detect name information about this enum key, which will be used to determine which code to emit
   * and whether we should declare a variable as part of this declaration.
   *
   * Some cases to keep in mind:
   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement
   *   this by declaring a variable `X` so that later expressions can use it.
   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,
   *   e.g. `"hello world" = 3,`. Template literal syntax is NOT allowed.
   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier
   *   later, e.g. `"X" = 1, Y = X`. That means that we need to detect whether or not a string
   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an
   *   identifier.
   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later
   *   and would be a syntax error if we emitted a variable, so we need to skip the variable
   *   declaration in those cases.
   *
   * The variableName return value captures these nuances: if non-null, we can and must emit a
   * variable declaration, and if null, we can't and shouldn't.
   */
  extractEnumKeyInfo(nameToken) {
    if (nameToken.type === _types.TokenType.name) {
      const name = this.tokens.identifierNameForToken(nameToken);
      return {
        nameStringCode: `"${name}"`,
        variableName: _isIdentifier2.default.call(void 0, name) ? name : null
      };
    } else if (nameToken.type === _types.TokenType.string) {
      const name = this.tokens.stringValueForToken(nameToken);
      return {
        nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),
        variableName: _isIdentifier2.default.call(void 0, name) ? name : null
      };
    } else {
      throw new Error("Expected name or string at beginning of enum element.");
    }
  }

  /**
   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and
   * not a complex expression). This is the typical form for TS string enums, and in this case, we
   * do *not* create a reverse mapping.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = "some value"
   * ->
   * const someKey = "some value"; MyEnum["someKey"] = someKey;
   *
   * Example 2:
   * "some key" = "some value"
   * ->
   * MyEnum["some key"] = "some value";
   */
  processStringLiteralEnumMember(enumName, nameStringCode, variableName) {
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName}`);
      // =
      this.tokens.copyToken();
      // value string
      this.tokens.copyToken();
      this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);
    } else {
      this.tokens.appendCode(`${enumName}[${nameStringCode}]`);
      // =
      this.tokens.copyToken();
      // value string
      this.tokens.copyToken();
      this.tokens.appendCode(";");
    }
  }

  /**
   * Handle an enum member initialized with an expression on the right-hand side (other than a
   * string literal). In these cases, we should transform the expression and emit code that sets up
   * a reverse mapping.
   *
   * The TypeScript implementation of this operation distinguishes between expressions that can be
   * "constant folded" at compile time (i.e. consist of number literals and simple math operations
   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved
   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at
   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the
   * expression as-is, and will later emit something like `MyEnum["previousKey"] + 1` to implement
   * auto-incrementing.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = 1 + 1
   * ->
   * const someKey = 1 + 1; MyEnum[MyEnum["someKey"] = someKey] = "someKey";
   *
   * Example 2:
   * "some key" = 1 + 1
   * ->
   * MyEnum[MyEnum["some key"] = 1 + 1] = "some key";
   */
  processExplicitValueEnumMember(enumName, nameStringCode, variableName) {
    const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;
    if (rhsEndIndex == null) {
      throw new Error("Expected rhsEndIndex on enum assign.");
    }
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName}`);
      this.tokens.copyToken();
      while (this.tokens.currentIndex() < rhsEndIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(`; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`);
    } else {
      this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);
      this.tokens.copyToken();
      while (this.tokens.currentIndex() < rhsEndIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(`] = ${nameStringCode};`);
    }
  }

  /**
   * Handle an enum member with no right-hand side expression. In this case, the value is the
   * previous value plus 1, or 0 if there was no previous value. We should also always emit a
   * reverse mapping.
   *
   * Example 1:
   * someKey2
   * ->
   * const someKey2 = someKey1 + 1; MyEnum[MyEnum["someKey2"] = someKey2] = "someKey2";
   *
   * Example 2:
   * "some key 2"
   * ->
   * MyEnum[MyEnum["some key 2"] = someKey1 + 1] = "some key 2";
   */
  processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode) {
    let valueCode = previousValueCode != null ? `${previousValueCode} + 1` : "0";
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);
      valueCode = variableName;
    }
    this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`);
  }
}
exports.default = TypeScriptTransformer;
}),
/* --- node_modules/lines-and-columns/build/index.js --- */
"node_modules/lines-and-columns/build/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

exports.__esModule = true;
exports.LinesAndColumns = void 0;
var LF = '\n';
var CR = '\r';
var LinesAndColumns = /** @class */function () {
  function LinesAndColumns(string) {
    this.string = string;
    var offsets = [0];
    for (var offset = 0; offset < string.length;) {
      switch (string[offset]) {
        case LF:
          offset += LF.length;
          offsets.push(offset);
          break;
        case CR:
          offset += CR.length;
          if (string[offset] === LF) {
            offset += LF.length;
          }
          offsets.push(offset);
          break;
        default:
          offset++;
          break;
      }
    }
    this.offsets = offsets;
  }
  LinesAndColumns.prototype.locationForIndex = function (index) {
    if (index < 0 || index > this.string.length) {
      return null;
    }
    var line = 0;
    var offsets = this.offsets;
    while (offsets[line + 1] <= index) {
      line++;
    }
    var column = index - offsets[line];
    return {
      line: line,
      column: column
    };
  };
  LinesAndColumns.prototype.indexForLocation = function (location) {
    var line = location.line,
      column = location.column;
    if (line < 0 || line >= this.offsets.length) {
      return null;
    }
    if (column < 0 || column > this.lengthOfLine(line)) {
      return null;
    }
    return this.offsets[line] + column;
  };
  LinesAndColumns.prototype.lengthOfLine = function (line) {
    var offset = this.offsets[line];
    var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
    return nextOffset - offset;
  };
  return LinesAndColumns;
}();
exports.LinesAndColumns = LinesAndColumns;
exports["default"] = LinesAndColumns;
}),
/* --- node_modules/coffeescript/lib/coffeescript/lexer.js --- */
"node_modules/coffeescript/lib/coffeescript/lexer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  // The CoffeeScript Lexer. Uses a series of token-matching regexes to attempt
  // matches against the beginning of the source code. When a match is found,
  // a token is produced, we consume the match, and start again. Tokens are in the
  // form:

  //     [tag, value, locationData]

  // where locationData is {first_line, first_column, last_line, last_column, last_line_exclusive, last_column_exclusive}, which is a
  // format that can be fed directly into [Jison](https://github.com/zaach/jison).  These
  // are read by jison in the `parser.lexer` function defined in coffeescript.coffee.
  var BOM,
    BOOL,
    CALLABLE,
    CODE,
    COFFEE_ALIASES,
    COFFEE_ALIAS_MAP,
    COFFEE_KEYWORDS,
    COMMENT,
    COMPARABLE_LEFT_SIDE,
    COMPARE,
    COMPOUND_ASSIGN,
    HERECOMMENT_ILLEGAL,
    HEREDOC_DOUBLE,
    HEREDOC_INDENT,
    HEREDOC_SINGLE,
    HEREGEX,
    HEREGEX_COMMENT,
    HERE_JSTOKEN,
    IDENTIFIER,
    INDENTABLE_CLOSERS,
    INDEXABLE,
    INSIDE_JSX,
    INVERSES,
    JSTOKEN,
    JSX_ATTRIBUTE,
    JSX_FRAGMENT_IDENTIFIER,
    JSX_IDENTIFIER,
    JSX_IDENTIFIER_PART,
    JSX_INTERPOLATION,
    JS_KEYWORDS,
    LINE_BREAK,
    LINE_CONTINUER,
    Lexer,
    MATH,
    MULTI_DENT,
    NOT_REGEX,
    NUMBER,
    OPERATOR,
    POSSIBLY_DIVISION,
    REGEX,
    REGEX_FLAGS,
    REGEX_ILLEGAL,
    REGEX_INVALID_ESCAPE,
    RELATION,
    RESERVED,
    Rewriter,
    SHIFT,
    STRICT_PROSCRIBED,
    STRING_DOUBLE,
    STRING_INVALID_ESCAPE,
    STRING_SINGLE,
    STRING_START,
    TRAILING_SPACES,
    UNARY,
    UNARY_MATH,
    UNFINISHED,
    VALID_FLAGS,
    WHITESPACE,
    addTokenData,
    attachCommentsToNode,
    compact,
    count,
    flatten,
    invertLiterate,
    isForFrom,
    isUnassignable,
    key,
    locationDataToString,
    merge,
    parseNumber,
    repeat,
    replaceUnicodeCodePointEscapes,
    starts,
    throwSyntaxError,
    indexOf = [].indexOf,
    slice = [].slice;
  ({
    Rewriter,
    INVERSES,
    UNFINISHED
  } = _kame_require_("node_modules/coffeescript/lib/coffeescript/rewriter.js"));

  // Import the helpers we need.
  ({
    count,
    starts,
    compact,
    repeat,
    invertLiterate,
    merge,
    attachCommentsToNode,
    locationDataToString,
    throwSyntaxError,
    replaceUnicodeCodePointEscapes,
    flatten,
    parseNumber
  } = _kame_require_("node_modules/coffeescript/lib/coffeescript/helpers.js"));

  // The Lexer Class
  // ---------------

  // The Lexer class reads a stream of CoffeeScript and divvies it up into tagged
  // tokens. Some potential ambiguity in the grammar has been avoided by
  // pushing some extra smarts into the Lexer.
  exports.Lexer = Lexer = class Lexer {
    constructor() {
      // Throws an error at either a given offset from the current chunk or at the
      // location of a token (`token[2]`).
      this.error = this.error.bind(this);
    }

    // **tokenize** is the Lexer's main method. Scan by attempting to match tokens
    // one at a time, using a regular expression anchored at the start of the
    // remaining code, or a custom recursive token-matching method
    // (for interpolations). When the next token has been recorded, we move forward
    // within the code past the token, and begin again.

    // Each tokenizing method is responsible for returning the number of characters
    // it has consumed.

    // Before returning the token stream, run it through the [Rewriter](rewriter.html).
    tokenize(code, opts = {}) {
      var consumed, end, i, ref;
      this.literate = opts.literate; // Are we lexing literate CoffeeScript?
      this.indent = 0; // The current indentation level.
      this.baseIndent = 0; // The overall minimum indentation level.
      this.continuationLineAdditionalIndent = 0; // The over-indentation at the current level.
      this.outdebt = 0; // The under-outdentation at the current level.
      this.indents = []; // The stack of all current indentation levels.
      this.indentLiteral = ''; // The indentation.
      this.ends = []; // The stack for pairing up tokens.
      this.tokens = []; // Stream of parsed tokens in the form `['TYPE', value, location data]`.
      this.seenFor = false; // Used to recognize `FORIN`, `FOROF` and `FORFROM` tokens.
      this.seenImport = false; // Used to recognize `IMPORT FROM? AS?` tokens.
      this.seenExport = false; // Used to recognize `EXPORT FROM? AS?` tokens.
      this.importSpecifierList = false; // Used to identify when in an `IMPORT {...} FROM? ...`.
      this.exportSpecifierList = false; // Used to identify when in an `EXPORT {...} FROM? ...`.
      this.jsxDepth = 0; // Used to optimize JSX checks, how deep in JSX we are.
      this.jsxObjAttribute = {}; // Used to detect if JSX attributes is wrapped in {} (<div {props...} />).
      this.chunkLine = opts.line || 0; // The start line for the current @chunk.
      this.chunkColumn = opts.column || 0; // The start column of the current @chunk.
      this.chunkOffset = opts.offset || 0; // The start offset for the current @chunk.
      this.locationDataCompensations = opts.locationDataCompensations || {};
      code = this.clean(code); // The stripped, cleaned original source code.

      // At every position, run through this list of attempted matches,
      // short-circuiting if any of them succeed. Their order determines precedence:
      // `@literalToken` is the fallback catch-all.
      i = 0;
      while (this.chunk = code.slice(i)) {
        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.jsxToken() || this.regexToken() || this.jsToken() || this.literalToken();
        // Update position.
        [this.chunkLine, this.chunkColumn, this.chunkOffset] = this.getLineAndColumnFromChunk(consumed);
        i += consumed;
        if (opts.untilBalanced && this.ends.length === 0) {
          return {
            tokens: this.tokens,
            index: i
          };
        }
      }
      this.closeIndentation();
      if (end = this.ends.pop()) {
        this.error(`missing ${end.tag}`, ((ref = end.origin) != null ? ref : end)[2]);
      }
      if (opts.rewrite === false) {
        return this.tokens;
      }
      return new Rewriter().rewrite(this.tokens);
    }

    // Preprocess the code to remove leading and trailing whitespace, carriage
    // returns, etc. If were lexing literate CoffeeScript, strip external Markdown
    // by removing all lines that arent indented by at least four spaces or a tab.
    clean(code) {
      var base, thusFar;
      thusFar = 0;
      if (code.charCodeAt(0) === BOM) {
        code = code.slice(1);
        this.locationDataCompensations[0] = 1;
        thusFar += 1;
      }
      if (WHITESPACE.test(code)) {
        code = `\n${code}`;
        this.chunkLine--;
        if ((base = this.locationDataCompensations)[0] == null) {
          base[0] = 0;
        }
        this.locationDataCompensations[0] -= 1;
      }
      code = code.replace(/\r/g, (match, offset) => {
        this.locationDataCompensations[thusFar + offset] = 1;
        return '';
      }).replace(TRAILING_SPACES, '');
      if (this.literate) {
        code = invertLiterate(code);
      }
      return code;
    }

    // Tokenizers
    // ----------

    // Matches identifying literals: variables, keywords, method names, etc.
    // Check to ensure that JavaScript reserved words arent being used as
    // identifiers. Because CoffeeScript reserves a handful of keywords that are
    // allowed in JavaScript, were careful not to tag them as keywords when
    // referenced as property names here, so you can still do `jQuery.is()` even
    // though `is` means `===` otherwise.
    identifierToken() {
      var alias, colon, colonOffset, colonToken, id, idLength, inJSXTag, input, match, poppedToken, prev, prevprev, ref, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, regExSuper, regex, sup, tag, tagToken, tokenData;
      inJSXTag = this.atJSXTag();
      regex = inJSXTag ? JSX_ATTRIBUTE : IDENTIFIER;
      if (!(match = regex.exec(this.chunk))) {
        return 0;
      }
      [input, id, colon] = match;
      // Preserve length of id for location data
      idLength = id.length;
      poppedToken = void 0;
      if (id === 'own' && this.tag() === 'FOR') {
        this.token('OWN', id);
        return id.length;
      }
      if (id === 'from' && this.tag() === 'YIELD') {
        this.token('FROM', id);
        return id.length;
      }
      if (id === 'as' && this.seenImport) {
        if (this.value() === '*') {
          this.tokens[this.tokens.length - 1][0] = 'IMPORT_ALL';
        } else if (ref = this.value(true), indexOf.call(COFFEE_KEYWORDS, ref) >= 0) {
          prev = this.prev();
          [prev[0], prev[1]] = ['IDENTIFIER', this.value(true)];
        }
        if ((ref1 = this.tag()) === 'DEFAULT' || ref1 === 'IMPORT_ALL' || ref1 === 'IDENTIFIER') {
          this.token('AS', id);
          return id.length;
        }
      }
      if (id === 'as' && this.seenExport) {
        if ((ref2 = this.tag()) === 'IDENTIFIER' || ref2 === 'DEFAULT') {
          this.token('AS', id);
          return id.length;
        }
        if (ref3 = this.value(true), indexOf.call(COFFEE_KEYWORDS, ref3) >= 0) {
          prev = this.prev();
          [prev[0], prev[1]] = ['IDENTIFIER', this.value(true)];
          this.token('AS', id);
          return id.length;
        }
      }
      if (id === 'default' && this.seenExport && ((ref4 = this.tag()) === 'EXPORT' || ref4 === 'AS')) {
        this.token('DEFAULT', id);
        return id.length;
      }
      if (id === 'assert' && (this.seenImport || this.seenExport) && this.tag() === 'STRING') {
        this.token('ASSERT', id);
        return id.length;
      }
      if (id === 'do' && (regExSuper = /^(\s*super)(?!\(\))/.exec(this.chunk.slice(3)))) {
        this.token('SUPER', 'super');
        this.token('CALL_START', '(');
        this.token('CALL_END', ')');
        [input, sup] = regExSuper;
        return sup.length + 3;
      }
      prev = this.prev();
      tag = colon || prev != null && ((ref5 = prev[0]) === '.' || ref5 === '?.' || ref5 === '::' || ref5 === '?::' || !prev.spaced && prev[0] === '@') ? 'PROPERTY' : 'IDENTIFIER';
      tokenData = {};
      if (tag === 'IDENTIFIER' && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {
        tag = id.toUpperCase();
        if (tag === 'WHEN' && (ref6 = this.tag(), indexOf.call(LINE_BREAK, ref6) >= 0)) {
          tag = 'LEADING_WHEN';
        } else if (tag === 'FOR') {
          this.seenFor = {
            endsLength: this.ends.length
          };
        } else if (tag === 'UNLESS') {
          tag = 'IF';
        } else if (tag === 'IMPORT') {
          this.seenImport = true;
        } else if (tag === 'EXPORT') {
          this.seenExport = true;
        } else if (indexOf.call(UNARY, tag) >= 0) {
          tag = 'UNARY';
        } else if (indexOf.call(RELATION, tag) >= 0) {
          if (tag !== 'INSTANCEOF' && this.seenFor) {
            tag = 'FOR' + tag;
            this.seenFor = false;
          } else {
            tag = 'RELATION';
            if (this.value() === '!') {
              poppedToken = this.tokens.pop();
              tokenData.invert = (ref7 = (ref8 = poppedToken.data) != null ? ref8.original : void 0) != null ? ref7 : poppedToken[1];
            }
          }
        }
      } else if (tag === 'IDENTIFIER' && this.seenFor && id === 'from' && isForFrom(prev)) {
        tag = 'FORFROM';
        this.seenFor = false;
        // Throw an error on attempts to use `get` or `set` as keywords, or
        // what CoffeeScript would normally interpret as calls to functions named
        // `get` or `set`, i.e. `get({foo: function () {}})`.
      } else if (tag === 'PROPERTY' && prev) {
        if (prev.spaced && (ref9 = prev[0], indexOf.call(CALLABLE, ref9) >= 0) && /^[gs]et$/.test(prev[1]) && this.tokens.length > 1 && (ref10 = this.tokens[this.tokens.length - 2][0]) !== '.' && ref10 !== '?.' && ref10 !== '@') {
          this.error(`'${prev[1]}' cannot be used as a keyword, or as a function call without parentheses`, prev[2]);
        } else if (prev[0] === '.' && this.tokens.length > 1 && (prevprev = this.tokens[this.tokens.length - 2])[0] === 'UNARY' && prevprev[1] === 'new') {
          prevprev[0] = 'NEW_TARGET';
        } else if (prev[0] === '.' && this.tokens.length > 1 && (prevprev = this.tokens[this.tokens.length - 2])[0] === 'IMPORT' && prevprev[1] === 'import') {
          this.seenImport = false;
          prevprev[0] = 'IMPORT_META';
        } else if (this.tokens.length > 2) {
          prevprev = this.tokens[this.tokens.length - 2];
          if (((ref11 = prev[0]) === '@' || ref11 === 'THIS') && prevprev && prevprev.spaced && /^[gs]et$/.test(prevprev[1]) && (ref12 = this.tokens[this.tokens.length - 3][0]) !== '.' && ref12 !== '?.' && ref12 !== '@') {
            this.error(`'${prevprev[1]}' cannot be used as a keyword, or as a function call without parentheses`, prevprev[2]);
          }
        }
      }
      if (tag === 'IDENTIFIER' && indexOf.call(RESERVED, id) >= 0 && !inJSXTag) {
        this.error(`reserved word '${id}'`, {
          length: id.length
        });
      }
      if (!(tag === 'PROPERTY' || this.exportSpecifierList || this.importSpecifierList)) {
        if (indexOf.call(COFFEE_ALIASES, id) >= 0) {
          alias = id;
          id = COFFEE_ALIAS_MAP[id];
          tokenData.original = alias;
        }
        tag = function () {
          switch (id) {
            case '!':
              return 'UNARY';
            case '==':
            case '!=':
              return 'COMPARE';
            case 'true':
            case 'false':
              return 'BOOL';
            case 'break':
            case 'continue':
            case 'debugger':
              return 'STATEMENT';
            case '&&':
            case '||':
              return id;
            default:
              return tag;
          }
        }();
      }
      tagToken = this.token(tag, id, {
        length: idLength,
        data: tokenData
      });
      if (alias) {
        tagToken.origin = [tag, alias, tagToken[2]];
      }
      if (poppedToken) {
        [tagToken[2].first_line, tagToken[2].first_column, tagToken[2].range[0]] = [poppedToken[2].first_line, poppedToken[2].first_column, poppedToken[2].range[0]];
      }
      if (colon) {
        colonOffset = input.lastIndexOf(inJSXTag ? '=' : ':');
        colonToken = this.token(':', ':', {
          offset: colonOffset
        });
        if (inJSXTag) {
          // used by rewriter
          colonToken.jsxColon = true;
        }
      }
      if (inJSXTag && tag === 'IDENTIFIER' && prev[0] !== ':') {
        this.token(',', ',', {
          length: 0,
          origin: tagToken,
          generated: true
        });
      }
      return input.length;
    }

    // Matches numbers, including decimals, hex, and exponential notation.
    // Be careful not to interfere with ranges in progress.
    numberToken() {
      var lexedLength, match, number, parsedValue, tag, tokenData;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      lexedLength = number.length;
      switch (false) {
        case !/^0[BOX]/.test(number):
          this.error(`radix prefix in '${number}' must be lowercase`, {
            offset: 1
          });
          break;
        case !/^(?!0x).*E/.test(number):
          this.error(`exponential notation in '${number}' must be indicated with a lowercase 'e'`, {
            offset: number.indexOf('E')
          });
          break;
        case !/^0\d*[89]/.test(number):
          this.error(`decimal literal '${number}' must not be prefixed with '0'`, {
            length: lexedLength
          });
          break;
        case !/^0\d+/.test(number):
          this.error(`octal literal '${number}' must be prefixed with '0o'`, {
            length: lexedLength
          });
      }
      parsedValue = parseNumber(number);
      tokenData = {
        parsedValue
      };
      tag = parsedValue === 2e308 ? 'INFINITY' : 'NUMBER';
      if (tag === 'INFINITY') {
        tokenData.original = number;
      }
      this.token(tag, number, {
        length: lexedLength,
        data: tokenData
      });
      return lexedLength;
    }

    // Matches strings, including multiline strings, as well as heredocs, with or without
    // interpolation.
    stringToken() {
      var attempt, delimiter, doc, end, heredoc, i, indent, match, prev, quote, ref, regex, token, tokens;
      [quote] = STRING_START.exec(this.chunk) || [];
      if (!quote) {
        return 0;
      }
      // If the preceding token is `from` and this is an import or export statement,
      // properly tag the `from`.
      prev = this.prev();
      if (prev && this.value() === 'from' && (this.seenImport || this.seenExport)) {
        prev[0] = 'FROM';
      }
      regex = function () {
        switch (quote) {
          case "'":
            return STRING_SINGLE;
          case '"':
            return STRING_DOUBLE;
          case "'''":
            return HEREDOC_SINGLE;
          case '"""':
            return HEREDOC_DOUBLE;
        }
      }();
      ({
        tokens,
        index: end
      } = this.matchWithInterpolations(regex, quote));
      heredoc = quote.length === 3;
      if (heredoc) {
        // Find the smallest indentation. It will be removed from all lines later.
        indent = null;
        doc = function () {
          var j, len, results;
          results = [];
          for (i = j = 0, len = tokens.length; j < len; i = ++j) {
            token = tokens[i];
            if (token[0] === 'NEOSTRING') {
              results.push(token[1]);
            }
          }
          return results;
        }().join('#{}');
        while (match = HEREDOC_INDENT.exec(doc)) {
          attempt = match[1];
          if (indent === null || 0 < (ref = attempt.length) && ref < indent.length) {
            indent = attempt;
          }
        }
      }
      delimiter = quote.charAt(0);
      this.mergeInterpolationTokens(tokens, {
        quote,
        indent,
        endOffset: end
      }, value => {
        return this.validateUnicodeCodePointEscapes(value, {
          delimiter: quote
        });
      });
      if (this.atJSXTag()) {
        this.token(',', ',', {
          length: 0,
          origin: this.prev,
          generated: true
        });
      }
      return end;
    }

    // Matches and consumes comments. The comments are taken out of the token
    // stream and saved for later, to be reinserted into the output after
    // everything has been parsed and the JavaScript code generated.
    commentToken(chunk = this.chunk, {
      heregex,
      returnCommentTokens = false,
      offsetInChunk = 0
    } = {}) {
      var commentAttachment, commentAttachments, commentWithSurroundingWhitespace, content, contents, getIndentSize, hasSeenFirstCommentLine, hereComment, hereLeadingWhitespace, hereTrailingWhitespace, i, indentSize, leadingNewline, leadingNewlineOffset, leadingNewlines, leadingWhitespace, length, lineComment, match, matchIllegal, noIndent, nonInitial, placeholderToken, precededByBlankLine, precedingNonCommentLines, prev;
      if (!(match = chunk.match(COMMENT))) {
        return 0;
      }
      [commentWithSurroundingWhitespace, hereLeadingWhitespace, hereComment, hereTrailingWhitespace, lineComment] = match;
      contents = null;
      // Does this comment follow code on the same line?
      leadingNewline = /^\s*\n+\s*#/.test(commentWithSurroundingWhitespace);
      if (hereComment) {
        matchIllegal = HERECOMMENT_ILLEGAL.exec(hereComment);
        if (matchIllegal) {
          this.error(`block comments cannot contain ${matchIllegal[0]}`, {
            offset: '###'.length + matchIllegal.index,
            length: matchIllegal[0].length
          });
        }
        // Parse indentation or outdentation as if this block comment didnt exist.
        chunk = chunk.replace(`###${hereComment}###`, '');
        // Remove leading newlines, like `Rewriter::removeLeadingNewlines`, to
        // avoid the creation of unwanted `TERMINATOR` tokens.
        chunk = chunk.replace(/^\n+/, '');
        this.lineToken({
          chunk
        });
        // Pull out the ###-style comments content, and format it.
        content = hereComment;
        contents = [{
          content,
          length: commentWithSurroundingWhitespace.length - hereLeadingWhitespace.length - hereTrailingWhitespace.length,
          leadingWhitespace: hereLeadingWhitespace
        }];
      } else {
        // The `COMMENT` regex captures successive line comments as one token.
        // Remove any leading newlines before the first comment, but preserve
        // blank lines between line comments.
        leadingNewlines = '';
        content = lineComment.replace(/^(\n*)/, function (leading) {
          leadingNewlines = leading;
          return '';
        });
        precedingNonCommentLines = '';
        hasSeenFirstCommentLine = false;
        contents = content.split('\n').map(function (line, index) {
          var comment, leadingWhitespace;
          if (!(line.indexOf('#') > -1)) {
            precedingNonCommentLines += `\n${line}`;
            return;
          }
          leadingWhitespace = '';
          content = line.replace(/^([ |\t]*)#/, function (_, whitespace) {
            leadingWhitespace = whitespace;
            return '';
          });
          comment = {
            content,
            length: '#'.length + content.length,
            leadingWhitespace: `${!hasSeenFirstCommentLine ? leadingNewlines : ''}${precedingNonCommentLines}${leadingWhitespace}`,
            precededByBlankLine: !!precedingNonCommentLines
          };
          hasSeenFirstCommentLine = true;
          precedingNonCommentLines = '';
          return comment;
        }).filter(function (comment) {
          return comment;
        });
      }
      getIndentSize = function ({
        leadingWhitespace,
        nonInitial
      }) {
        var lastNewlineIndex;
        lastNewlineIndex = leadingWhitespace.lastIndexOf('\n');
        if (hereComment != null || !nonInitial) {
          if (!(lastNewlineIndex > -1)) {
            return null;
          }
        } else {
          if (lastNewlineIndex == null) {
            lastNewlineIndex = -1;
          }
        }
        return leadingWhitespace.length - 1 - lastNewlineIndex;
      };
      commentAttachments = function () {
        var j, len, results;
        results = [];
        for (i = j = 0, len = contents.length; j < len; i = ++j) {
          ({
            content,
            length,
            leadingWhitespace,
            precededByBlankLine
          } = contents[i]);
          nonInitial = i !== 0;
          leadingNewlineOffset = nonInitial ? 1 : 0;
          offsetInChunk += leadingNewlineOffset + leadingWhitespace.length;
          indentSize = getIndentSize({
            leadingWhitespace,
            nonInitial
          });
          noIndent = indentSize == null || indentSize === -1;
          commentAttachment = {
            content,
            here: hereComment != null,
            newLine: leadingNewline || nonInitial,
            // Line comments after the first one start new lines, by definition.
            locationData: this.makeLocationData({
              offsetInChunk,
              length
            }),
            precededByBlankLine,
            indentSize,
            indented: !noIndent && indentSize > this.indent,
            outdented: !noIndent && indentSize < this.indent
          };
          if (heregex) {
            commentAttachment.heregex = true;
          }
          offsetInChunk += length;
          results.push(commentAttachment);
        }
        return results;
      }.call(this);
      prev = this.prev();
      if (!prev) {
        // If theres no previous token, create a placeholder token to attach
        // this comment to; and follow with a newline.
        commentAttachments[0].newLine = true;
        this.lineToken({
          chunk: this.chunk.slice(commentWithSurroundingWhitespace.length),
          offset: commentWithSurroundingWhitespace.length // Set the indent.
        });

        placeholderToken = this.makeToken('JS', '', {
          offset: commentWithSurroundingWhitespace.length,
          generated: true
        });
        placeholderToken.comments = commentAttachments;
        this.tokens.push(placeholderToken);
        this.newlineToken(commentWithSurroundingWhitespace.length);
      } else {
        attachCommentsToNode(commentAttachments, prev);
      }
      if (returnCommentTokens) {
        return commentAttachments;
      }
      return commentWithSurroundingWhitespace.length;
    }

    // Matches JavaScript interpolated directly into the source via backticks.
    jsToken() {
      var length, match, matchedHere, script;
      if (!(this.chunk.charAt(0) === '`' && (match = (matchedHere = HERE_JSTOKEN.exec(this.chunk)) || JSTOKEN.exec(this.chunk)))) {
        return 0;
      }
      // Convert escaped backticks to backticks, and escaped backslashes
      // just before escaped backticks to backslashes
      script = match[1];
      ({
        length
      } = match[0]);
      this.token('JS', script, {
        length,
        data: {
          here: !!matchedHere
        }
      });
      return length;
    }

    // Matches regular expression literals, as well as multiline extended ones.
    // Lexing regular expressions is difficult to distinguish from division, so we
    // borrow some basic heuristics from JavaScript and Ruby.
    regexToken() {
      var body, closed, comment, commentIndex, commentOpts, commentTokens, comments, delimiter, end, flags, fullMatch, index, leadingWhitespace, match, matchedComment, origin, prev, ref, ref1, regex, tokens;
      switch (false) {
        case !(match = REGEX_ILLEGAL.exec(this.chunk)):
          this.error(`regular expressions cannot begin with ${match[2]}`, {
            offset: match.index + match[1].length
          });
          break;
        case !(match = this.matchWithInterpolations(HEREGEX, '///')):
          ({
            tokens,
            index
          } = match);
          comments = [];
          while (matchedComment = HEREGEX_COMMENT.exec(this.chunk.slice(0, index))) {
            ({
              index: commentIndex
            } = matchedComment);
            [fullMatch, leadingWhitespace, comment] = matchedComment;
            comments.push({
              comment,
              offsetInChunk: commentIndex + leadingWhitespace.length
            });
          }
          commentTokens = flatten(function () {
            var j, len, results;
            results = [];
            for (j = 0, len = comments.length; j < len; j++) {
              commentOpts = comments[j];
              results.push(this.commentToken(commentOpts.comment, Object.assign(commentOpts, {
                heregex: true,
                returnCommentTokens: true
              })));
            }
            return results;
          }.call(this));
          break;
        case !(match = REGEX.exec(this.chunk)):
          [regex, body, closed] = match;
          this.validateEscapes(body, {
            isRegex: true,
            offsetInChunk: 1
          });
          index = regex.length;
          prev = this.prev();
          if (prev) {
            if (prev.spaced && (ref = prev[0], indexOf.call(CALLABLE, ref) >= 0)) {
              if (!closed || POSSIBLY_DIVISION.test(regex)) {
                return 0;
              }
            } else if (ref1 = prev[0], indexOf.call(NOT_REGEX, ref1) >= 0) {
              return 0;
            }
          }
          if (!closed) {
            this.error('missing / (unclosed regex)');
          }
          break;
        default:
          return 0;
      }
      [flags] = REGEX_FLAGS.exec(this.chunk.slice(index));
      end = index + flags.length;
      origin = this.makeToken('REGEX', null, {
        length: end
      });
      switch (false) {
        case !!VALID_FLAGS.test(flags):
          this.error(`invalid regular expression flags ${flags}`, {
            offset: index,
            length: flags.length
          });
          break;
        case !(regex || tokens.length === 1):
          delimiter = body ? '/' : '///';
          if (body == null) {
            body = tokens[0][1];
          }
          this.validateUnicodeCodePointEscapes(body, {
            delimiter
          });
          this.token('REGEX', `/${body}/${flags}`, {
            length: end,
            origin,
            data: {
              delimiter
            }
          });
          break;
        default:
          this.token('REGEX_START', '(', {
            length: 0,
            origin,
            generated: true
          });
          this.token('IDENTIFIER', 'RegExp', {
            length: 0,
            generated: true
          });
          this.token('CALL_START', '(', {
            length: 0,
            generated: true
          });
          this.mergeInterpolationTokens(tokens, {
            double: true,
            heregex: {
              flags
            },
            endOffset: end - flags.length,
            quote: '///'
          }, str => {
            return this.validateUnicodeCodePointEscapes(str, {
              delimiter
            });
          });
          if (flags) {
            this.token(',', ',', {
              offset: index - 1,
              length: 0,
              generated: true
            });
            this.token('STRING', '"' + flags + '"', {
              offset: index,
              length: flags.length
            });
          }
          this.token(')', ')', {
            offset: end,
            length: 0,
            generated: true
          });
          this.token('REGEX_END', ')', {
            offset: end,
            length: 0,
            generated: true
          });
      }
      // Explicitly attach any heregex comments to the REGEX/REGEX_END token.
      if (commentTokens != null ? commentTokens.length : void 0) {
        addTokenData(this.tokens[this.tokens.length - 1], {
          heregexCommentTokens: commentTokens
        });
      }
      return end;
    }

    // Matches newlines, indents, and outdents, and determines which is which.
    // If we can detect that the current line is continued onto the next line,
    // then the newline is suppressed:

    //     elements
    //       .each( ... )
    //       .map( ... )

    // Keeps track of the level of indentation, because a single outdent token
    // can close multiple indents, so we need to know how far in we happen to be.
    lineToken({
      chunk = this.chunk,
      offset = 0
    } = {}) {
      var backslash, diff, endsContinuationLineIndentation, indent, match, minLiteralLength, newIndentLiteral, noNewlines, prev, ref, size;
      if (!(match = MULTI_DENT.exec(chunk))) {
        return 0;
      }
      indent = match[0];
      prev = this.prev();
      backslash = (prev != null ? prev[0] : void 0) === '\\';
      if (!((backslash || ((ref = this.seenFor) != null ? ref.endsLength : void 0) < this.ends.length) && this.seenFor)) {
        this.seenFor = false;
      }
      if (!(backslash && this.seenImport || this.importSpecifierList)) {
        this.seenImport = false;
      }
      if (!(backslash && this.seenExport || this.exportSpecifierList)) {
        this.seenExport = false;
      }
      size = indent.length - 1 - indent.lastIndexOf('\n');
      noNewlines = this.unfinished();
      newIndentLiteral = size > 0 ? indent.slice(-size) : '';
      if (!/^(.?)\1*$/.exec(newIndentLiteral)) {
        this.error('mixed indentation', {
          offset: indent.length
        });
        return indent.length;
      }
      minLiteralLength = Math.min(newIndentLiteral.length, this.indentLiteral.length);
      if (newIndentLiteral.slice(0, minLiteralLength) !== this.indentLiteral.slice(0, minLiteralLength)) {
        this.error('indentation mismatch', {
          offset: indent.length
        });
        return indent.length;
      }
      if (size - this.continuationLineAdditionalIndent === this.indent) {
        if (noNewlines) {
          this.suppressNewlines();
        } else {
          this.newlineToken(offset);
        }
        return indent.length;
      }
      if (size > this.indent) {
        if (noNewlines) {
          if (!backslash) {
            this.continuationLineAdditionalIndent = size - this.indent;
          }
          if (this.continuationLineAdditionalIndent) {
            prev.continuationLineIndent = this.indent + this.continuationLineAdditionalIndent;
          }
          this.suppressNewlines();
          return indent.length;
        }
        if (!this.tokens.length) {
          this.baseIndent = this.indent = size;
          this.indentLiteral = newIndentLiteral;
          return indent.length;
        }
        diff = size - this.indent + this.outdebt;
        this.token('INDENT', diff, {
          offset: offset + indent.length - size,
          length: size
        });
        this.indents.push(diff);
        this.ends.push({
          tag: 'OUTDENT'
        });
        this.outdebt = this.continuationLineAdditionalIndent = 0;
        this.indent = size;
        this.indentLiteral = newIndentLiteral;
      } else if (size < this.baseIndent) {
        this.error('missing indentation', {
          offset: offset + indent.length
        });
      } else {
        endsContinuationLineIndentation = this.continuationLineAdditionalIndent > 0;
        this.continuationLineAdditionalIndent = 0;
        this.outdentToken({
          moveOut: this.indent - size,
          noNewlines,
          outdentLength: indent.length,
          offset,
          indentSize: size,
          endsContinuationLineIndentation
        });
      }
      return indent.length;
    }

    // Record an outdent token or multiple tokens, if we happen to be moving back
    // inwards past several recorded indents. Sets new @indent value.
    outdentToken({
      moveOut,
      noNewlines,
      outdentLength = 0,
      offset = 0,
      indentSize,
      endsContinuationLineIndentation
    }) {
      var decreasedIndent, dent, lastIndent, ref, terminatorToken;
      decreasedIndent = this.indent - moveOut;
      while (moveOut > 0) {
        lastIndent = this.indents[this.indents.length - 1];
        if (!lastIndent) {
          this.outdebt = moveOut = 0;
        } else if (this.outdebt && moveOut <= this.outdebt) {
          this.outdebt -= moveOut;
          moveOut = 0;
        } else {
          dent = this.indents.pop() + this.outdebt;
          if (outdentLength && (ref = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref) >= 0)) {
            decreasedIndent -= dent - moveOut;
            moveOut = dent;
          }
          this.outdebt = 0;
          // pair might call outdentToken, so preserve decreasedIndent
          this.pair('OUTDENT');
          this.token('OUTDENT', moveOut, {
            length: outdentLength,
            indentSize: indentSize + moveOut - dent
          });
          moveOut -= dent;
        }
      }
      if (dent) {
        this.outdebt -= moveOut;
      }
      this.suppressSemicolons();
      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {
        terminatorToken = this.token('TERMINATOR', '\n', {
          offset: offset + outdentLength,
          length: 0
        });
        if (endsContinuationLineIndentation) {
          terminatorToken.endsContinuationLineIndentation = {
            preContinuationLineIndent: this.indent
          };
        }
      }
      this.indent = decreasedIndent;
      this.indentLiteral = this.indentLiteral.slice(0, decreasedIndent);
      return this;
    }

    // Matches and consumes non-meaningful whitespace. Tag the previous token
    // as being spaced, because there are some cases where it makes a difference.
    whitespaceToken() {
      var match, nline, prev;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      prev = this.prev();
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    }

    // Generate a newline token. Consecutive newlines get merged together.
    newlineToken(offset) {
      this.suppressSemicolons();
      if (this.tag() !== 'TERMINATOR') {
        this.token('TERMINATOR', '\n', {
          offset,
          length: 0
        });
      }
      return this;
    }

    // Use a `\` at a line-ending to suppress the newline.
    // The slash is removed here once its job is done.
    suppressNewlines() {
      var prev;
      prev = this.prev();
      if (prev[1] === '\\') {
        if (prev.comments && this.tokens.length > 1) {
          // `@tokens.length` should be at least 2 (some code, then `\`).
          // If something puts a `\` after nothing, they deserve to lose any
          // comments that trail it.
          attachCommentsToNode(prev.comments, this.tokens[this.tokens.length - 2]);
        }
        this.tokens.pop();
      }
      return this;
    }
    jsxToken() {
      var afterTag, end, endToken, firstChar, fullId, fullTagName, id, input, j, jsxTag, len, match, offset, openingTagToken, prev, prevChar, properties, property, ref, tagToken, token, tokens;
      firstChar = this.chunk[0];
      // Check the previous token to detect if attribute is spread.
      prevChar = this.tokens.length > 0 ? this.tokens[this.tokens.length - 1][0] : '';
      if (firstChar === '<') {
        match = JSX_IDENTIFIER.exec(this.chunk.slice(1)) || JSX_FRAGMENT_IDENTIFIER.exec(this.chunk.slice(1));
        // Not the right hand side of an unspaced comparison (i.e. `a<b`).
        if (!(match && (this.jsxDepth > 0 || !(prev = this.prev()) || prev.spaced || (ref = prev[0], indexOf.call(COMPARABLE_LEFT_SIDE, ref) < 0)))) {
          return 0;
        }
        [input, id] = match;
        fullId = id;
        if (indexOf.call(id, '.') >= 0) {
          [id, ...properties] = id.split('.');
        } else {
          properties = [];
        }
        tagToken = this.token('JSX_TAG', id, {
          length: id.length + 1,
          data: {
            openingBracketToken: this.makeToken('<', '<'),
            tagNameToken: this.makeToken('IDENTIFIER', id, {
              offset: 1
            })
          }
        });
        offset = id.length + 1;
        for (j = 0, len = properties.length; j < len; j++) {
          property = properties[j];
          this.token('.', '.', {
            offset
          });
          offset += 1;
          this.token('PROPERTY', property, {
            offset
          });
          offset += property.length;
        }
        this.token('CALL_START', '(', {
          generated: true
        });
        this.token('[', '[', {
          generated: true
        });
        this.ends.push({
          tag: '/>',
          origin: tagToken,
          name: id,
          properties
        });
        this.jsxDepth++;
        return fullId.length + 1;
      } else if (jsxTag = this.atJSXTag()) {
        if (this.chunk.slice(0, 2) === '/>') {
          // Self-closing tag.
          this.pair('/>');
          this.token(']', ']', {
            length: 2,
            generated: true
          });
          this.token('CALL_END', ')', {
            length: 2,
            generated: true,
            data: {
              selfClosingSlashToken: this.makeToken('/', '/'),
              closingBracketToken: this.makeToken('>', '>', {
                offset: 1
              })
            }
          });
          this.jsxDepth--;
          return 2;
        } else if (firstChar === '{') {
          if (prevChar === ':') {
            // This token represents the start of a JSX attribute value
            // thats an expression (e.g. the `{b}` in `<div a={b} />`).
            // Our grammar represents the beginnings of expressions as `(`
            // tokens, so make this into a `(` token that displays as `{`.
            token = this.token('(', '{');
            this.jsxObjAttribute[this.jsxDepth] = false;
            // tag attribute name as JSX
            addTokenData(this.tokens[this.tokens.length - 3], {
              jsx: true
            });
          } else {
            token = this.token('{', '{');
            this.jsxObjAttribute[this.jsxDepth] = true;
          }
          this.ends.push({
            tag: '}',
            origin: token
          });
          return 1;
        } else if (firstChar === '>') {
          // end of opening tag
          ({
            // Ignore terminators inside a tag.
            origin: openingTagToken
          } = this.pair('/>')); // As if the current tag was self-closing.
          this.token(']', ']', {
            generated: true,
            data: {
              closingBracketToken: this.makeToken('>', '>')
            }
          });
          this.token(',', 'JSX_COMMA', {
            generated: true
          });
          ({
            tokens,
            index: end
          } = this.matchWithInterpolations(INSIDE_JSX, '>', '</', JSX_INTERPOLATION));
          this.mergeInterpolationTokens(tokens, {
            endOffset: end,
            jsx: true
          }, value => {
            return this.validateUnicodeCodePointEscapes(value, {
              delimiter: '>'
            });
          });
          match = JSX_IDENTIFIER.exec(this.chunk.slice(end)) || JSX_FRAGMENT_IDENTIFIER.exec(this.chunk.slice(end));
          if (!match || match[1] !== `${jsxTag.name}${function () {
            var k, len1, ref1, results;
            ref1 = jsxTag.properties;
            results = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              property = ref1[k];
              results.push(`.${property}`);
            }
            return results;
          }().join('')}`) {
            this.error(`expected corresponding JSX closing tag for ${jsxTag.name}`, jsxTag.origin.data.tagNameToken[2]);
          }
          [, fullTagName] = match;
          afterTag = end + fullTagName.length;
          if (this.chunk[afterTag] !== '>') {
            this.error("missing closing > after tag name", {
              offset: afterTag,
              length: 1
            });
          }
          // -2/+2 for the opening `</` and +1 for the closing `>`.
          endToken = this.token('CALL_END', ')', {
            offset: end - 2,
            length: fullTagName.length + 3,
            generated: true,
            data: {
              closingTagOpeningBracketToken: this.makeToken('<', '<', {
                offset: end - 2
              }),
              closingTagSlashToken: this.makeToken('/', '/', {
                offset: end - 1
              }),
              // TODO: individual tokens for complex tag name? eg < / A . B >
              closingTagNameToken: this.makeToken('IDENTIFIER', fullTagName, {
                offset: end
              }),
              closingTagClosingBracketToken: this.makeToken('>', '>', {
                offset: end + fullTagName.length
              })
            }
          });
          // make the closing tag location data more easily accessible to the grammar
          addTokenData(openingTagToken, endToken.data);
          this.jsxDepth--;
          return afterTag + 1;
        } else {
          return 0;
        }
      } else if (this.atJSXTag(1)) {
        if (firstChar === '}') {
          this.pair(firstChar);
          if (this.jsxObjAttribute[this.jsxDepth]) {
            this.token('}', '}');
            this.jsxObjAttribute[this.jsxDepth] = false;
          } else {
            this.token(')', '}');
          }
          this.token(',', ',', {
            generated: true
          });
          return 1;
        } else {
          return 0;
        }
      } else {
        return 0;
      }
    }
    atJSXTag(depth = 0) {
      var i, last, ref;
      if (this.jsxDepth === 0) {
        return false;
      }
      i = this.ends.length - 1;
      while (((ref = this.ends[i]) != null ? ref.tag : void 0) === 'OUTDENT' || depth-- > 0) {
        // Ignore indents.
        i--;
      }
      last = this.ends[i];
      return (last != null ? last.tag : void 0) === '/>' && last;
    }

    // We treat all other single characters as a token. E.g.: `( ) , . !`
    // Multi-character operators are also literal tokens, so that Jison can assign
    // the proper order of operations. There are some symbols that we tag specially
    // here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
    // parentheses that indicate a method call from regular parentheses, and so on.
    literalToken() {
      var match, message, origin, prev, ref, ref1, ref2, ref3, ref4, ref5, skipToken, tag, token, value;
      if (match = OPERATOR.exec(this.chunk)) {
        [value] = match;
        if (CODE.test(value)) {
          this.tagParameters();
        }
      } else {
        value = this.chunk.charAt(0);
      }
      tag = value;
      prev = this.prev();
      if (prev && indexOf.call(['=', ...COMPOUND_ASSIGN], value) >= 0) {
        skipToken = false;
        if (value === '=' && ((ref = prev[1]) === '||' || ref === '&&') && !prev.spaced) {
          prev[0] = 'COMPOUND_ASSIGN';
          prev[1] += '=';
          if ((ref1 = prev.data) != null ? ref1.original : void 0) {
            prev.data.original += '=';
          }
          prev[2].range = [prev[2].range[0], prev[2].range[1] + 1];
          prev[2].last_column += 1;
          prev[2].last_column_exclusive += 1;
          prev = this.tokens[this.tokens.length - 2];
          skipToken = true;
        }
        if (prev && prev[0] !== 'PROPERTY') {
          origin = (ref2 = prev.origin) != null ? ref2 : prev;
          message = isUnassignable(prev[1], origin[1]);
          if (message) {
            this.error(message, origin[2]);
          }
        }
        if (skipToken) {
          return value.length;
        }
      }
      if (value === '(' && (prev != null ? prev[0] : void 0) === 'IMPORT') {
        prev[0] = 'DYNAMIC_IMPORT';
      }
      if (value === '{' && this.seenImport) {
        this.importSpecifierList = true;
      } else if (this.importSpecifierList && value === '}') {
        this.importSpecifierList = false;
      } else if (value === '{' && (prev != null ? prev[0] : void 0) === 'EXPORT') {
        this.exportSpecifierList = true;
      } else if (this.exportSpecifierList && value === '}') {
        this.exportSpecifierList = false;
      }
      if (value === ';') {
        if (ref3 = prev != null ? prev[0] : void 0, indexOf.call(['=', ...UNFINISHED], ref3) >= 0) {
          this.error('unexpected ;');
        }
        this.seenFor = this.seenImport = this.seenExport = false;
        tag = 'TERMINATOR';
      } else if (value === '*' && (prev != null ? prev[0] : void 0) === 'EXPORT') {
        tag = 'EXPORT_ALL';
      } else if (indexOf.call(MATH, value) >= 0) {
        tag = 'MATH';
      } else if (indexOf.call(COMPARE, value) >= 0) {
        tag = 'COMPARE';
      } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {
        tag = 'COMPOUND_ASSIGN';
      } else if (indexOf.call(UNARY, value) >= 0) {
        tag = 'UNARY';
      } else if (indexOf.call(UNARY_MATH, value) >= 0) {
        tag = 'UNARY_MATH';
      } else if (indexOf.call(SHIFT, value) >= 0) {
        tag = 'SHIFT';
      } else if (value === '?' && (prev != null ? prev.spaced : void 0)) {
        tag = 'BIN?';
      } else if (prev) {
        if (value === '(' && !prev.spaced && (ref4 = prev[0], indexOf.call(CALLABLE, ref4) >= 0)) {
          if (prev[0] === '?') {
            prev[0] = 'FUNC_EXIST';
          }
          tag = 'CALL_START';
        } else if (value === '[' && ((ref5 = prev[0], indexOf.call(INDEXABLE, ref5) >= 0) && !prev.spaced || prev[0] === '::')) {
          // `.prototype` cant be a method you can call.
          tag = 'INDEX_START';
          switch (prev[0]) {
            case '?':
              prev[0] = 'INDEX_SOAK';
          }
        }
      }
      token = this.makeToken(tag, value);
      switch (value) {
        case '(':
        case '{':
        case '[':
          this.ends.push({
            tag: INVERSES[value],
            origin: token
          });
          break;
        case ')':
        case '}':
        case ']':
          this.pair(value);
      }
      this.tokens.push(this.makeToken(tag, value));
      return value.length;
    }

    // Token Manipulators
    // ------------------

    // A source of ambiguity in our grammar used to be parameter lists in function
    // definitions versus argument lists in function calls. Walk backwards, tagging
    // parameters specially in order to make things easier for the parser.
    tagParameters() {
      var i, paramEndToken, stack, tok, tokens;
      if (this.tag() !== ')') {
        return this.tagDoIife();
      }
      stack = [];
      ({
        tokens
      } = this);
      i = tokens.length;
      paramEndToken = tokens[--i];
      paramEndToken[0] = 'PARAM_END';
      while (tok = tokens[--i]) {
        switch (tok[0]) {
          case ')':
            stack.push(tok);
            break;
          case '(':
          case 'CALL_START':
            if (stack.length) {
              stack.pop();
            } else if (tok[0] === '(') {
              tok[0] = 'PARAM_START';
              return this.tagDoIife(i - 1);
            } else {
              paramEndToken[0] = 'CALL_END';
              return this;
            }
        }
      }
      return this;
    }

    // Tag `do` followed by a function differently than `do` followed by eg an
    // identifier to allow for different grammar precedence
    tagDoIife(tokenIndex) {
      var tok;
      tok = this.tokens[tokenIndex != null ? tokenIndex : this.tokens.length - 1];
      if ((tok != null ? tok[0] : void 0) !== 'DO') {
        return this;
      }
      tok[0] = 'DO_IIFE';
      return this;
    }

    // Close up all remaining open blocks at the end of the file.
    closeIndentation() {
      return this.outdentToken({
        moveOut: this.indent,
        indentSize: 0
      });
    }

    // Match the contents of a delimited token and expand variables and expressions
    // inside it using Ruby-like notation for substitution of arbitrary
    // expressions.

    //     "Hello #{name.capitalize()}."

    // If it encounters an interpolation, this method will recursively create a new
    // Lexer and tokenize until the `{` of `#{` is balanced with a `}`.

    //  - `regex` matches the contents of a token (but not `delimiter`, and not
    //    `#{` if interpolations are desired).
    //  - `delimiter` is the delimiter of the token. Examples are `'`, `"`, `'''`,
    //    `"""` and `///`.
    //  - `closingDelimiter` is different from `delimiter` only in JSX
    //  - `interpolators` matches the start of an interpolation, for JSX it's both
    //    `{` and `<` (i.e. nested JSX tag)

    // This method allows us to have strings within interpolations within strings,
    // ad infinitum.
    matchWithInterpolations(regex, delimiter, closingDelimiter = delimiter, interpolators = /^#\{/) {
      var braceInterpolator, close, column, index, interpolationOffset, interpolator, line, match, nested, offset, offsetInChunk, open, ref, ref1, rest, str, strPart, tokens;
      tokens = [];
      offsetInChunk = delimiter.length;
      if (this.chunk.slice(0, offsetInChunk) !== delimiter) {
        return null;
      }
      str = this.chunk.slice(offsetInChunk);
      while (true) {
        [strPart] = regex.exec(str);
        this.validateEscapes(strPart, {
          isRegex: delimiter.charAt(0) === '/',
          offsetInChunk
        });
        // Push a fake `'NEOSTRING'` token, which will get turned into a real string later.
        tokens.push(this.makeToken('NEOSTRING', strPart, {
          offset: offsetInChunk
        }));
        str = str.slice(strPart.length);
        offsetInChunk += strPart.length;
        if (!(match = interpolators.exec(str))) {
          break;
        }
        [interpolator] = match;
        // To remove the `#` in `#{`.
        interpolationOffset = interpolator.length - 1;
        [line, column, offset] = this.getLineAndColumnFromChunk(offsetInChunk + interpolationOffset);
        rest = str.slice(interpolationOffset);
        ({
          tokens: nested,
          index
        } = new Lexer().tokenize(rest, {
          line,
          column,
          offset,
          untilBalanced: true,
          locationDataCompensations: this.locationDataCompensations
        }));
        // Account for the `#` in `#{`.
        index += interpolationOffset;
        braceInterpolator = str[index - 1] === '}';
        if (braceInterpolator) {
          // Turn the leading and trailing `{` and `}` into parentheses. Unnecessary
          // parentheses will be removed later.
          [open] = nested, [close] = slice.call(nested, -1);
          open[0] = 'INTERPOLATION_START';
          open[1] = '(';
          open[2].first_column -= interpolationOffset;
          open[2].range = [open[2].range[0] - interpolationOffset, open[2].range[1]];
          close[0] = 'INTERPOLATION_END';
          close[1] = ')';
          close.origin = ['', 'end of interpolation', close[2]];
        }
        if (((ref = nested[1]) != null ? ref[0] : void 0) === 'TERMINATOR') {
          // Remove leading `'TERMINATOR'` (if any).
          nested.splice(1, 1);
        }
        if (((ref1 = nested[nested.length - 3]) != null ? ref1[0] : void 0) === 'INDENT' && nested[nested.length - 2][0] === 'OUTDENT') {
          // Remove trailing `'INDENT'/'OUTDENT'` pair (if any).
          nested.splice(-3, 2);
        }
        if (!braceInterpolator) {
          // We are not using `{` and `}`, so wrap the interpolated tokens instead.
          open = this.makeToken('INTERPOLATION_START', '(', {
            offset: offsetInChunk,
            length: 0,
            generated: true
          });
          close = this.makeToken('INTERPOLATION_END', ')', {
            offset: offsetInChunk + index,
            length: 0,
            generated: true
          });
          nested = [open, ...nested, close];
        }
        // Push a fake `'TOKENS'` token, which will get turned into real tokens later.
        tokens.push(['TOKENS', nested]);
        str = str.slice(index);
        offsetInChunk += index;
      }
      if (str.slice(0, closingDelimiter.length) !== closingDelimiter) {
        this.error(`missing ${closingDelimiter}`, {
          length: delimiter.length
        });
      }
      return {
        tokens,
        index: offsetInChunk + closingDelimiter.length
      };
    }

    // Merge the array `tokens` of the fake token types `'TOKENS'` and `'NEOSTRING'`
    // (as returned by `matchWithInterpolations`) into the token stream. The value
    // of `'NEOSTRING'`s are converted using `fn` and turned into strings using
    // `options` first.
    mergeInterpolationTokens(tokens, options, fn) {
      var $, converted, double, endOffset, firstIndex, heregex, i, indent, j, jsx, k, lastToken, len, len1, locationToken, lparen, placeholderToken, quote, ref, ref1, rparen, tag, token, tokensToPush, val, value;
      ({
        quote,
        indent,
        double,
        heregex,
        endOffset,
        jsx
      } = options);
      if (tokens.length > 1) {
        lparen = this.token('STRING_START', '(', {
          length: (ref = quote != null ? quote.length : void 0) != null ? ref : 0,
          data: {
            quote
          },
          generated: !(quote != null ? quote.length : void 0)
        });
      }
      firstIndex = this.tokens.length;
      $ = tokens.length - 1;
      for (i = j = 0, len = tokens.length; j < len; i = ++j) {
        token = tokens[i];
        [tag, value] = token;
        switch (tag) {
          case 'TOKENS':
            // There are comments (and nothing else) in this interpolation.
            if (value.length === 2 && (value[0].comments || value[1].comments)) {
              placeholderToken = this.makeToken('JS', '', {
                generated: true
              });
              // Use the same location data as the first parenthesis.
              placeholderToken[2] = value[0][2];
              for (k = 0, len1 = value.length; k < len1; k++) {
                val = value[k];
                if (!val.comments) {
                  continue;
                }
                if (placeholderToken.comments == null) {
                  placeholderToken.comments = [];
                }
                placeholderToken.comments.push(...val.comments);
              }
              value.splice(1, 0, placeholderToken);
            }
            // Push all the tokens in the fake `'TOKENS'` token. These already have
            // sane location data.
            locationToken = value[0];
            tokensToPush = value;
            break;
          case 'NEOSTRING':
            // Convert `'NEOSTRING'` into `'STRING'`.
            converted = fn.call(this, token[1], i);
            if (i === 0) {
              addTokenData(token, {
                initialChunk: true
              });
            }
            if (i === $) {
              addTokenData(token, {
                finalChunk: true
              });
            }
            addTokenData(token, {
              indent,
              quote,
              double
            });
            if (heregex) {
              addTokenData(token, {
                heregex
              });
            }
            if (jsx) {
              addTokenData(token, {
                jsx
              });
            }
            token[0] = 'STRING';
            token[1] = '"' + converted + '"';
            if (tokens.length === 1 && quote != null) {
              token[2].first_column -= quote.length;
              if (token[1].substr(-2, 1) === '\n') {
                token[2].last_line += 1;
                token[2].last_column = quote.length - 1;
              } else {
                token[2].last_column += quote.length;
                if (token[1].length === 2) {
                  token[2].last_column -= 1;
                }
              }
              token[2].last_column_exclusive += quote.length;
              token[2].range = [token[2].range[0] - quote.length, token[2].range[1] + quote.length];
            }
            locationToken = token;
            tokensToPush = [token];
        }
        this.tokens.push(...tokensToPush);
      }
      if (lparen) {
        [lastToken] = slice.call(tokens, -1);
        lparen.origin = ['STRING', null, {
          first_line: lparen[2].first_line,
          first_column: lparen[2].first_column,
          last_line: lastToken[2].last_line,
          last_column: lastToken[2].last_column,
          last_line_exclusive: lastToken[2].last_line_exclusive,
          last_column_exclusive: lastToken[2].last_column_exclusive,
          range: [lparen[2].range[0], lastToken[2].range[1]]
        }];
        if (!(quote != null ? quote.length : void 0)) {
          lparen[2] = lparen.origin[2];
        }
        return rparen = this.token('STRING_END', ')', {
          offset: endOffset - (quote != null ? quote : '').length,
          length: (ref1 = quote != null ? quote.length : void 0) != null ? ref1 : 0,
          generated: !(quote != null ? quote.length : void 0)
        });
      }
    }

    // Pairs up a closing token, ensuring that all listed pairs of tokens are
    // correctly balanced throughout the course of the token stream.
    pair(tag) {
      var lastIndent, prev, ref, ref1, wanted;
      ref = this.ends, [prev] = slice.call(ref, -1);
      if (tag !== (wanted = prev != null ? prev.tag : void 0)) {
        if ('OUTDENT' !== wanted) {
          this.error(`unmatched ${tag}`);
        }
        // Auto-close `INDENT` to support syntax like this:

        //     el.click((event) ->
        //       el.hide())

        ref1 = this.indents, [lastIndent] = slice.call(ref1, -1);
        this.outdentToken({
          moveOut: lastIndent,
          noNewlines: true
        });
        return this.pair(tag);
      }
      return this.ends.pop();
    }

    // Helpers
    // -------

    // Compensate for the things we strip out initially (e.g. carriage returns)
    // so that location data stays accurate with respect to the original source file.
    getLocationDataCompensation(start, end) {
      var compensation, current, initialEnd, totalCompensation;
      totalCompensation = 0;
      initialEnd = end;
      current = start;
      while (current <= end) {
        if (current === end && start !== initialEnd) {
          break;
        }
        compensation = this.locationDataCompensations[current];
        if (compensation != null) {
          totalCompensation += compensation;
          end += compensation;
        }
        current++;
      }
      return totalCompensation;
    }

    // Returns the line and column number from an offset into the current chunk.

    // `offset` is a number of characters into `@chunk`.
    getLineAndColumnFromChunk(offset) {
      var column, columnCompensation, compensation, lastLine, lineCount, previousLinesCompensation, ref, string;
      compensation = this.getLocationDataCompensation(this.chunkOffset, this.chunkOffset + offset);
      if (offset === 0) {
        return [this.chunkLine, this.chunkColumn + compensation, this.chunkOffset + compensation];
      }
      if (offset >= this.chunk.length) {
        string = this.chunk;
      } else {
        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
      }
      lineCount = count(string, '\n');
      column = this.chunkColumn;
      if (lineCount > 0) {
        ref = string.split('\n'), [lastLine] = slice.call(ref, -1);
        column = lastLine.length;
        previousLinesCompensation = this.getLocationDataCompensation(this.chunkOffset, this.chunkOffset + offset - column);
        if (previousLinesCompensation < 0) {
          // Don't recompensate for initially inserted newline.
          previousLinesCompensation = 0;
        }
        columnCompensation = this.getLocationDataCompensation(this.chunkOffset + offset + previousLinesCompensation - column, this.chunkOffset + offset + previousLinesCompensation);
      } else {
        column += string.length;
        columnCompensation = compensation;
      }
      return [this.chunkLine + lineCount, column + columnCompensation, this.chunkOffset + offset + compensation];
    }
    makeLocationData({
      offsetInChunk,
      length
    }) {
      var endOffset, lastCharacter, locationData;
      locationData = {
        range: []
      };
      [locationData.first_line, locationData.first_column, locationData.range[0]] = this.getLineAndColumnFromChunk(offsetInChunk);
      // Use length - 1 for the final offset - were supplying the last_line and the last_column,
      // so if last_column == first_column, then were looking at a character of length 1.
      lastCharacter = length > 0 ? length - 1 : 0;
      [locationData.last_line, locationData.last_column, endOffset] = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter);
      [locationData.last_line_exclusive, locationData.last_column_exclusive] = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter + (length > 0 ? 1 : 0));
      locationData.range[1] = length > 0 ? endOffset + 1 : endOffset;
      return locationData;
    }

    // Same as `token`, except this just returns the token without adding it
    // to the results.
    makeToken(tag, value, {
      offset: offsetInChunk = 0,
      length = value.length,
      origin,
      generated,
      indentSize
    } = {}) {
      var token;
      token = [tag, value, this.makeLocationData({
        offsetInChunk,
        length
      })];
      if (origin) {
        token.origin = origin;
      }
      if (generated) {
        token.generated = true;
      }
      if (indentSize != null) {
        token.indentSize = indentSize;
      }
      return token;
    }

    // Add a token to the results.
    // `offset` is the offset into the current `@chunk` where the token starts.
    // `length` is the length of the token in the `@chunk`, after the offset.  If
    // not specified, the length of `value` will be used.

    // Returns the new token.
    token(tag, value, {
      offset,
      length,
      origin,
      data,
      generated,
      indentSize
    } = {}) {
      var token;
      token = this.makeToken(tag, value, {
        offset,
        length,
        origin,
        generated,
        indentSize
      });
      if (data) {
        addTokenData(token, data);
      }
      this.tokens.push(token);
      return token;
    }

    // Peek at the last tag in the token stream.
    tag() {
      var ref, token;
      ref = this.tokens, [token] = slice.call(ref, -1);
      return token != null ? token[0] : void 0;
    }

    // Peek at the last value in the token stream.
    value(useOrigin = false) {
      var ref, token;
      ref = this.tokens, [token] = slice.call(ref, -1);
      if (useOrigin && (token != null ? token.origin : void 0) != null) {
        return token.origin[1];
      } else {
        return token != null ? token[1] : void 0;
      }
    }

    // Get the previous token in the token stream.
    prev() {
      return this.tokens[this.tokens.length - 1];
    }

    // Are we in the midst of an unfinished expression?
    unfinished() {
      var ref;
      return LINE_CONTINUER.test(this.chunk) || (ref = this.tag(), indexOf.call(UNFINISHED, ref) >= 0);
    }
    validateUnicodeCodePointEscapes(str, options) {
      return replaceUnicodeCodePointEscapes(str, merge(options, {
        error: this.error
      }));
    }

    // Validates escapes in strings and regexes.
    validateEscapes(str, options = {}) {
      var before, hex, invalidEscape, invalidEscapeRegex, match, message, octal, ref, unicode, unicodeCodePoint;
      invalidEscapeRegex = options.isRegex ? REGEX_INVALID_ESCAPE : STRING_INVALID_ESCAPE;
      match = invalidEscapeRegex.exec(str);
      if (!match) {
        return;
      }
      match[0], before = match[1], octal = match[2], hex = match[3], unicodeCodePoint = match[4], unicode = match[5];
      message = octal ? "octal escape sequences are not allowed" : "invalid escape sequence";
      invalidEscape = `\\${octal || hex || unicodeCodePoint || unicode}`;
      return this.error(`${message} ${invalidEscape}`, {
        offset: ((ref = options.offsetInChunk) != null ? ref : 0) + match.index + before.length,
        length: invalidEscape.length
      });
    }
    suppressSemicolons() {
      var ref, ref1, results;
      results = [];
      while (this.value() === ';') {
        this.tokens.pop();
        if (ref = (ref1 = this.prev()) != null ? ref1[0] : void 0, indexOf.call(['=', ...UNFINISHED], ref) >= 0) {
          results.push(this.error('unexpected ;'));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
    error(message, options = {}) {
      var first_column, first_line, location, ref, ref1;
      location = 'first_line' in options ? options : ([first_line, first_column] = this.getLineAndColumnFromChunk((ref = options.offset) != null ? ref : 0), {
        first_line,
        first_column,
        last_column: first_column + ((ref1 = options.length) != null ? ref1 : 1) - 1
      });
      return throwSyntaxError(message, location);
    }
  };

  // Helper functions
  // ----------------
  isUnassignable = function (name, displayName = name) {
    switch (false) {
      case indexOf.call([...JS_KEYWORDS, ...COFFEE_KEYWORDS], name) < 0:
        return `keyword '${displayName}' can't be assigned`;
      case indexOf.call(STRICT_PROSCRIBED, name) < 0:
        return `'${displayName}' can't be assigned`;
      case indexOf.call(RESERVED, name) < 0:
        return `reserved word '${displayName}' can't be assigned`;
      default:
        return false;
    }
  };
  exports.isUnassignable = isUnassignable;

  // `from` isnt a CoffeeScript keyword, but it behaves like one in `import` and
  // `export` statements (handled above) and in the declaration line of a `for`
  // loop. Try to detect when `from` is a variable identifier and when it is this
  // sometimes keyword.
  isForFrom = function (prev) {
    var ref;
    // `for i from iterable`
    if (prev[0] === 'IDENTIFIER') {
      return true;
      // `for from`
    } else if (prev[0] === 'FOR') {
      return false;
      // `for {from}`, `for [from]`, `for {a, from}`, `for {a: from}`
    } else if ((ref = prev[1]) === '{' || ref === '[' || ref === ',' || ref === ':') {
      return false;
    } else {
      return true;
    }
  };
  addTokenData = function (token, data) {
    return Object.assign(token.data != null ? token.data : token.data = {}, data);
  };

  // Constants
  // ---------

  // Keywords that CoffeeScript shares in common with JavaScript.
  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'await', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'import', 'export', 'default'];

  // CoffeeScript-only keywords.
  COFFEE_KEYWORDS = ['undefined', 'Infinity', 'NaN', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];
  COFFEE_ALIAS_MAP = {
    and: '&&',
    or: '||',
    is: '==',
    isnt: '!=',
    not: '!',
    yes: 'true',
    no: 'false',
    on: 'true',
    off: 'false'
  };
  COFFEE_ALIASES = function () {
    var results;
    results = [];
    for (key in COFFEE_ALIAS_MAP) {
      results.push(key);
    }
    return results;
  }();
  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

  // The list of keywords that are reserved by JavaScript, but not used, or are
  // used by CoffeeScript internally. We throw an error when these are encountered,
  // to avoid having a JavaScript error at runtime.
  RESERVED = ['case', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];
  STRICT_PROSCRIBED = ['arguments', 'eval'];

  // The superset of both JavaScript keywords and reserved words, none of which may
  // be used as identifiers or properties.
  exports.JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

  // The character code of the nasty Microsoft madness otherwise known as the BOM.
  BOM = 65279;

  // Token matching regexes.
  IDENTIFIER = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)([^\n\S]*:(?!:))?/; // Is this a property name?

  // Like `IDENTIFIER`, but includes `-`s
  JSX_IDENTIFIER_PART = /(?:(?!\s)[\-$\w\x7f-\uffff])+/.source;

  // In https://facebook.github.io/jsx/ spec, JSXElementName can be
  // JSXIdentifier, JSXNamespacedName (JSXIdentifier : JSXIdentifier), or
  // JSXMemberExpression (two or more JSXIdentifier connected by `.`s).
  JSX_IDENTIFIER = RegExp(`^(?![\\d<])(${JSX_IDENTIFIER_PART // Must not start with `<`.
  // JSXNamespacedName
  // JSXMemberExpression
  }(?:\\s*:\\s*${JSX_IDENTIFIER_PART}|(?:\\s*\\.\\s*${JSX_IDENTIFIER_PART})+)?)`);

  // Fragment: <></>
  JSX_FRAGMENT_IDENTIFIER = /^()>/; // Ends immediately with `>`.

  // In https://facebook.github.io/jsx/ spec, JSXAttributeName can be either
  // JSXIdentifier or JSXNamespacedName which is JSXIdentifier : JSXIdentifier
  JSX_ATTRIBUTE = RegExp(`^(?!\\d)(${JSX_IDENTIFIER_PART // JSXNamespacedName
  // Is this an attribute with a value?
  }(?:\\s*:\\s*${JSX_IDENTIFIER_PART})?)([^\\S]*=(?!=))?`);
  NUMBER = /^0b[01](?:_?[01])*n?|^0o[0-7](?:_?[0-7])*n?|^0x[\da-f](?:_?[\da-f])*n?|^\d+n|^(?:\d(?:_?\d)*)?\.?(?:\d(?:_?\d)*)+(?:e[+-]?(?:\d(?:_?\d)*)+)?/i; // binary
  // octal
  // hex
  // decimal bigint
  // decimal
  // decimal without support for numeric literal separators for reference:
  // \d*\.?\d+ (?:e[+-]?\d+)?

  OPERATOR = /^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.{2,3})/; // function
  // compound assign / compare
  // zero-fill right shift
  // doubles
  // logic / shift / power / floor division / modulo
  // soak access
  // range or splat

  WHITESPACE = /^[^\n\S]+/;
  COMMENT = /^(\s*)###([^#][\s\S]*?)(?:###([^\n\S]*)|###$)|^((?:\s*#(?!##[^#]).*)+)/;
  CODE = /^[-=]>/;
  MULTI_DENT = /^(?:\n[^\n\S]*)+/;
  JSTOKEN = /^`(?!``)((?:[^`\\]|\\[\s\S])*)`/;
  HERE_JSTOKEN = /^```((?:[^`\\]|\\[\s\S]|`(?!``))*)```/;

  // String-matching-regexes.
  STRING_START = /^(?:'''|"""|'|")/;
  STRING_SINGLE = /^(?:[^\\']|\\[\s\S])*/;
  STRING_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|\#(?!\{))*/;
  HEREDOC_SINGLE = /^(?:[^\\']|\\[\s\S]|'(?!''))*/;
  HEREDOC_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|"(?!"")|\#(?!\{))*/;
  INSIDE_JSX = /^(?:[^\{<])*/; // Start of CoffeeScript interpolation. // Similar to `HEREDOC_DOUBLE` but there is no escaping.
  // Maybe JSX tag (`<` not allowed even if bare).

  JSX_INTERPOLATION = /^(?:\{|<(?!\/))/; // CoffeeScript interpolation.
  // JSX opening tag.

  HEREDOC_INDENT = /\n+([^\n\S]*)(?=\S)/g;

  // Regex-matching-regexes.
  REGEX = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/; // Every other thing.
  // Anything but newlines escaped.
  // Character class.

  REGEX_FLAGS = /^\w*/;
  VALID_FLAGS = /^(?!.*(.).*\1)[gimsuy]*$/;
  HEREGEX = /^(?:[^\\\/#\s]|\\[\s\S]|\/(?!\/\/)|\#(?!\{)|\s+(?:#(?!\{).*)?)*/; // Match any character, except those that need special handling below.
  // Match `\` followed by any character.
  // Match any `/` except `///`.
  // Match `#` which is not part of interpolation, e.g. `#{}`.
  // Comments consume everything until the end of the line, including `///`.

  HEREGEX_COMMENT = /(\s+)(#(?!{).*)/gm;
  REGEX_ILLEGAL = /^(\/|\/{3}\s*)(\*)/;
  POSSIBLY_DIVISION = /^\/=?\s/;

  // Other regexes.
  HERECOMMENT_ILLEGAL = /\*\//;
  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|\??::)/;
  STRING_INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0\d|[1-7])|(x(?![\da-fA-F]{2}).{0,2})|(u\{(?![\da-fA-F]{1,}\})[^}]*\}?)|(u(?!\{|[\da-fA-F]{4}).{0,4}))/; // Make sure the escape isnt escaped.
  // octal escape
  // hex escape
  // unicode code point escape
  // unicode escape

  REGEX_INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0\d)|(x(?![\da-fA-F]{2}).{0,2})|(u\{(?![\da-fA-F]{1,}\})[^}]*\}?)|(u(?!\{|[\da-fA-F]{4}).{0,4}))/; // Make sure the escape isnt escaped.
  // octal escape
  // hex escape
  // unicode code point escape
  // unicode escape

  TRAILING_SPACES = /\s+$/;

  // Compound assignment tokens.
  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];

  // Unary tokens.
  UNARY = ['NEW', 'TYPEOF', 'DELETE'];
  UNARY_MATH = ['!', '~'];

  // Bit-shifting tokens.
  SHIFT = ['<<', '>>', '>>>'];

  // Comparison tokens.
  COMPARE = ['==', '!=', '<', '>', '<=', '>='];

  // Mathematical tokens.
  MATH = ['*', '/', '%', '//', '%%'];

  // Relational tokens that are negatable with `not` prefix.
  RELATION = ['IN', 'OF', 'INSTANCEOF'];

  // Boolean tokens.
  BOOL = ['TRUE', 'FALSE'];

  // Tokens which could legitimately be invoked or indexed. An opening
  // parentheses or bracket following these tokens will be recorded as the start
  // of a function invocation or indexing operation.
  CALLABLE = ['IDENTIFIER', 'PROPERTY', ')', ']', '?', '@', 'THIS', 'SUPER', 'DYNAMIC_IMPORT'];
  INDEXABLE = CALLABLE.concat(['NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '}', '::']);

  // Tokens which can be the left-hand side of a less-than comparison, i.e. `a<b`.
  COMPARABLE_LEFT_SIDE = ['IDENTIFIER', ')', ']', 'NUMBER'];

  // Tokens which a regular expression will never immediately follow (except spaced
  // CALLABLEs in some cases), but which a division operator can.

  // See: http://www-archive.mozilla.org/js/language/js20-2002-04/rationale/syntax.html#regular-expressions
  NOT_REGEX = INDEXABLE.concat(['++', '--']);

  // Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
  // occurs at the start of a line. We disambiguate these from trailing whens to
  // avoid an ambiguity in the grammar.
  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];

  // Additional indent in front of these is ignored.
  INDENTABLE_CLOSERS = [')', '}', ']'];
}).call(void 0);
}),
/* --- node_modules/coffeescript/lib/coffeescript/parser.js --- */
"node_modules/coffeescript/lib/coffeescript/parser.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = function () {
  var o = function (k, v, o, l) {
      for (o = o || {}, l = k.length; l--; o[k[l]] = v);
      return o;
    },
    $V0 = [1, 24],
    $V1 = [1, 59],
    $V2 = [1, 98],
    $V3 = [1, 99],
    $V4 = [1, 94],
    $V5 = [1, 100],
    $V6 = [1, 101],
    $V7 = [1, 96],
    $V8 = [1, 97],
    $V9 = [1, 68],
    $Va = [1, 70],
    $Vb = [1, 71],
    $Vc = [1, 72],
    $Vd = [1, 73],
    $Ve = [1, 74],
    $Vf = [1, 76],
    $Vg = [1, 80],
    $Vh = [1, 77],
    $Vi = [1, 78],
    $Vj = [1, 62],
    $Vk = [1, 45],
    $Vl = [1, 38],
    $Vm = [1, 83],
    $Vn = [1, 84],
    $Vo = [1, 81],
    $Vp = [1, 82],
    $Vq = [1, 93],
    $Vr = [1, 57],
    $Vs = [1, 63],
    $Vt = [1, 64],
    $Vu = [1, 79],
    $Vv = [1, 50],
    $Vw = [1, 58],
    $Vx = [1, 75],
    $Vy = [1, 88],
    $Vz = [1, 89],
    $VA = [1, 90],
    $VB = [1, 91],
    $VC = [1, 56],
    $VD = [1, 87],
    $VE = [1, 40],
    $VF = [1, 41],
    $VG = [1, 61],
    $VH = [1, 42],
    $VI = [1, 43],
    $VJ = [1, 44],
    $VK = [1, 46],
    $VL = [1, 47],
    $VM = [1, 102],
    $VN = [1, 6, 35, 52, 155],
    $VO = [1, 6, 33, 35, 52, 74, 76, 96, 137, 144, 155, 158, 166],
    $VP = [1, 120],
    $VQ = [1, 121],
    $VR = [1, 122],
    $VS = [1, 117],
    $VT = [1, 105],
    $VU = [1, 104],
    $VV = [1, 103],
    $VW = [1, 106],
    $VX = [1, 107],
    $VY = [1, 108],
    $VZ = [1, 109],
    $V_ = [1, 110],
    $V$ = [1, 111],
    $V01 = [1, 112],
    $V11 = [1, 113],
    $V21 = [1, 114],
    $V31 = [1, 115],
    $V41 = [1, 116],
    $V51 = [1, 124],
    $V61 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $V71 = [2, 222],
    $V81 = [1, 130],
    $V91 = [1, 135],
    $Va1 = [1, 131],
    $Vb1 = [1, 132],
    $Vc1 = [1, 133],
    $Vd1 = [1, 136],
    $Ve1 = [1, 129],
    $Vf1 = [1, 6, 33, 35, 52, 74, 76, 96, 137, 144, 155, 157, 158, 159, 165, 166, 183],
    $Vg1 = [1, 6, 33, 35, 46, 47, 52, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $Vh1 = [2, 129],
    $Vi1 = [2, 133],
    $Vj1 = [6, 33, 91, 96],
    $Vk1 = [2, 106],
    $Vl1 = [1, 148],
    $Vm1 = [1, 147],
    $Vn1 = [1, 142],
    $Vo1 = [1, 151],
    $Vp1 = [1, 156],
    $Vq1 = [1, 154],
    $Vr1 = [1, 160],
    $Vs1 = [1, 166],
    $Vt1 = [1, 162],
    $Vu1 = [1, 163],
    $Vv1 = [1, 165],
    $Vw1 = [1, 170],
    $Vx1 = [1, 6, 33, 35, 46, 47, 52, 66, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $Vy1 = [2, 126],
    $Vz1 = [1, 6, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $VA1 = [2, 31],
    $VB1 = [1, 195],
    $VC1 = [1, 196],
    $VD1 = [2, 93],
    $VE1 = [1, 202],
    $VF1 = [1, 208],
    $VG1 = [1, 223],
    $VH1 = [1, 218],
    $VI1 = [1, 227],
    $VJ1 = [1, 224],
    $VK1 = [1, 229],
    $VL1 = [1, 230],
    $VM1 = [1, 232],
    $VN1 = [2, 227],
    $VO1 = [1, 234],
    $VP1 = [14, 32, 33, 39, 40, 44, 46, 47, 54, 55, 59, 60, 61, 62, 63, 64, 73, 75, 82, 85, 87, 88, 89, 93, 94, 108, 109, 117, 120, 122, 131, 139, 149, 153, 154, 157, 159, 162, 165, 176, 182, 185, 186, 187, 188, 189, 190, 191, 192],
    $VQ1 = [1, 6, 33, 35, 46, 47, 52, 66, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 121, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205],
    $VR1 = [1, 247],
    $VS1 = [1, 248],
    $VT1 = [2, 156],
    $VU1 = [1, 264],
    $VV1 = [1, 265],
    $VW1 = [1, 267],
    $VX1 = [1, 277],
    $VY1 = [1, 278],
    $VZ1 = [1, 6, 33, 35, 46, 47, 52, 70, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $V_1 = [1, 6, 33, 35, 36, 46, 47, 52, 66, 70, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 121, 128, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 173, 174, 175, 183, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205],
    $V$1 = [1, 6, 33, 35, 46, 47, 49, 51, 52, 57, 70, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 123, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $V02 = [1, 283],
    $V12 = [46, 47, 136],
    $V22 = [1, 322],
    $V32 = [1, 321],
    $V42 = [6, 33],
    $V52 = [2, 104],
    $V62 = [1, 328],
    $V72 = [6, 33, 35, 91, 96],
    $V82 = [6, 33, 35, 66, 76, 91, 96],
    $V92 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $Va2 = [2, 377],
    $Vb2 = [2, 378],
    $Vc2 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 194, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $Vd2 = [46, 47, 105, 106, 110, 111, 112, 115, 135, 136],
    $Ve2 = [1, 357],
    $Vf2 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183],
    $Vg2 = [2, 91],
    $Vh2 = [1, 375],
    $Vi2 = [1, 377],
    $Vj2 = [1, 382],
    $Vk2 = [1, 384],
    $Vl2 = [6, 33, 74, 96],
    $Vm2 = [2, 247],
    $Vn2 = [2, 248],
    $Vo2 = [1, 6, 33, 35, 46, 47, 52, 66, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 173, 174, 175, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $Vp2 = [1, 398],
    $Vq2 = [14, 32, 33, 35, 39, 40, 44, 46, 47, 54, 55, 59, 60, 61, 62, 63, 64, 73, 74, 75, 76, 82, 85, 87, 88, 89, 93, 94, 96, 108, 109, 117, 120, 122, 131, 139, 149, 153, 154, 157, 159, 162, 165, 176, 182, 185, 186, 187, 188, 189, 190, 191, 192],
    $Vr2 = [1, 400],
    $Vs2 = [6, 33, 35, 74, 96],
    $Vt2 = [6, 14, 32, 33, 35, 39, 40, 44, 46, 47, 54, 55, 59, 60, 61, 62, 63, 64, 73, 74, 75, 76, 82, 85, 87, 88, 89, 93, 94, 96, 108, 109, 117, 120, 122, 131, 139, 149, 153, 154, 157, 159, 162, 165, 176, 182, 185, 186, 187, 188, 189, 190, 191, 192],
    $Vu2 = [6, 33, 35, 74, 96, 137],
    $Vv2 = [1, 6, 33, 35, 46, 47, 52, 57, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $Vw2 = [1, 411],
    $Vx2 = [1, 6, 33, 35, 46, 47, 52, 66, 70, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 121, 135, 136, 137, 144, 155, 157, 158, 159, 165, 166, 173, 174, 175, 183, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205],
    $Vy2 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 166, 183],
    $Vz2 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 158, 166, 183],
    $VA2 = [2, 300],
    $VB2 = [173, 174, 175],
    $VC2 = [96, 173, 174, 175],
    $VD2 = [6, 33, 119],
    $VE2 = [1, 431],
    $VF2 = [6, 33, 35, 96, 119],
    $VG2 = [6, 33, 35, 70, 96, 119],
    $VH2 = [6, 33, 35, 66, 70, 76, 96, 105, 106, 110, 111, 112, 115, 119, 135, 136],
    $VI2 = [6, 33, 35, 76, 96, 105, 106, 110, 111, 112, 115, 119, 135, 136],
    $VJ2 = [46, 47, 49, 51],
    $VK2 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 189, 190, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $VL2 = [2, 367],
    $VM2 = [2, 366],
    $VN2 = [35, 107],
    $VO2 = [14, 32, 35, 39, 40, 44, 46, 47, 54, 55, 59, 60, 61, 62, 63, 64, 73, 75, 82, 85, 87, 88, 89, 93, 94, 107, 108, 109, 117, 120, 122, 131, 139, 149, 153, 154, 157, 159, 162, 165, 176, 182, 185, 186, 187, 188, 189, 190, 191, 192],
    $VP2 = [2, 233],
    $VQ2 = [6, 33, 35],
    $VR2 = [2, 105],
    $VS2 = [1, 470],
    $VT2 = [1, 471],
    $VU2 = [1, 6, 33, 35, 46, 47, 52, 74, 76, 91, 96, 105, 106, 107, 110, 111, 112, 115, 119, 135, 136, 137, 144, 151, 152, 155, 157, 158, 159, 165, 166, 178, 180, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $VV2 = [1, 337],
    $VW2 = [35, 178, 180],
    $VX2 = [1, 6, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 158, 166, 183],
    $VY2 = [1, 509],
    $VZ2 = [1, 516],
    $V_2 = [1, 6, 33, 35, 52, 74, 76, 96, 137, 144, 155, 158, 166, 183],
    $V$2 = [2, 120],
    $V03 = [1, 529],
    $V13 = [33, 35, 74],
    $V23 = [1, 537],
    $V33 = [6, 33, 35, 96, 137],
    $V43 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 178, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $V53 = [1, 6, 33, 35, 52, 74, 76, 96, 137, 144, 155, 158, 166, 178],
    $V63 = [2, 314],
    $V73 = [2, 315],
    $V83 = [2, 330],
    $V93 = [1, 557],
    $Va3 = [1, 558],
    $Vb3 = [6, 33, 35, 119],
    $Vc3 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 159, 165, 166, 183],
    $Vd3 = [6, 33, 35, 96],
    $Ve3 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 151, 155, 157, 158, 159, 165, 166, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204],
    $Vf3 = [33, 96],
    $Vg3 = [1, 611],
    $Vh3 = [1, 612],
    $Vi3 = [1, 619],
    $Vj3 = [1, 620],
    $Vk3 = [1, 638],
    $Vl3 = [1, 639],
    $Vm3 = [2, 285],
    $Vn3 = [2, 288],
    $Vo3 = [2, 301],
    $Vp3 = [2, 316],
    $Vq3 = [2, 320],
    $Vr3 = [2, 317],
    $Vs3 = [2, 321],
    $Vt3 = [2, 318],
    $Vu3 = [2, 319],
    $Vv3 = [2, 331],
    $Vw3 = [2, 332],
    $Vx3 = [1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 183],
    $Vy3 = [2, 322],
    $Vz3 = [2, 324],
    $VA3 = [2, 326],
    $VB3 = [2, 328],
    $VC3 = [2, 323],
    $VD3 = [2, 325],
    $VE3 = [2, 327],
    $VF3 = [2, 329];
  var parser = {
    trace: function trace() {},
    yy: {},
    symbols_: {
      "error": 2,
      "Root": 3,
      "Body": 4,
      "Line": 5,
      "TERMINATOR": 6,
      "Expression": 7,
      "ExpressionLine": 8,
      "Statement": 9,
      "FuncDirective": 10,
      "YieldReturn": 11,
      "AwaitReturn": 12,
      "Return": 13,
      "STATEMENT": 14,
      "Import": 15,
      "Export": 16,
      "Value": 17,
      "Code": 18,
      "Operation": 19,
      "Assign": 20,
      "If": 21,
      "Try": 22,
      "While": 23,
      "For": 24,
      "Switch": 25,
      "Class": 26,
      "Throw": 27,
      "Yield": 28,
      "CodeLine": 29,
      "IfLine": 30,
      "OperationLine": 31,
      "YIELD": 32,
      "INDENT": 33,
      "Object": 34,
      "OUTDENT": 35,
      "FROM": 36,
      "Block": 37,
      "Identifier": 38,
      "IDENTIFIER": 39,
      "JSX_TAG": 40,
      "Property": 41,
      "PROPERTY": 42,
      "AlphaNumeric": 43,
      "NUMBER": 44,
      "String": 45,
      "STRING": 46,
      "STRING_START": 47,
      "Interpolations": 48,
      "STRING_END": 49,
      "InterpolationChunk": 50,
      "INTERPOLATION_START": 51,
      "INTERPOLATION_END": 52,
      "Regex": 53,
      "REGEX": 54,
      "REGEX_START": 55,
      "Invocation": 56,
      "REGEX_END": 57,
      "Literal": 58,
      "JS": 59,
      "UNDEFINED": 60,
      "NULL": 61,
      "BOOL": 62,
      "INFINITY": 63,
      "NAN": 64,
      "Assignable": 65,
      "=": 66,
      "AssignObj": 67,
      "ObjAssignable": 68,
      "ObjRestValue": 69,
      ":": 70,
      "SimpleObjAssignable": 71,
      "ThisProperty": 72,
      "[": 73,
      "]": 74,
      "@": 75,
      "...": 76,
      "ObjSpreadExpr": 77,
      "ObjSpreadIdentifier": 78,
      "Parenthetical": 79,
      "Super": 80,
      "This": 81,
      "SUPER": 82,
      "OptFuncExist": 83,
      "Arguments": 84,
      "DYNAMIC_IMPORT": 85,
      "Accessor": 86,
      "RETURN": 87,
      "AWAIT": 88,
      "PARAM_START": 89,
      "ParamList": 90,
      "PARAM_END": 91,
      "FuncGlyph": 92,
      "->": 93,
      "=>": 94,
      "OptComma": 95,
      ",": 96,
      "Param": 97,
      "ParamVar": 98,
      "Array": 99,
      "Splat": 100,
      "SimpleAssignable": 101,
      "Range": 102,
      "DoIife": 103,
      "MetaProperty": 104,
      ".": 105,
      "INDEX_START": 106,
      "INDEX_END": 107,
      "NEW_TARGET": 108,
      "IMPORT_META": 109,
      "?.": 110,
      "::": 111,
      "?::": 112,
      "Index": 113,
      "IndexValue": 114,
      "INDEX_SOAK": 115,
      "Slice": 116,
      "{": 117,
      "AssignList": 118,
      "}": 119,
      "CLASS": 120,
      "EXTENDS": 121,
      "IMPORT": 122,
      "ASSERT": 123,
      "ImportDefaultSpecifier": 124,
      "ImportNamespaceSpecifier": 125,
      "ImportSpecifierList": 126,
      "ImportSpecifier": 127,
      "AS": 128,
      "DEFAULT": 129,
      "IMPORT_ALL": 130,
      "EXPORT": 131,
      "ExportSpecifierList": 132,
      "EXPORT_ALL": 133,
      "ExportSpecifier": 134,
      "FUNC_EXIST": 135,
      "CALL_START": 136,
      "CALL_END": 137,
      "ArgList": 138,
      "THIS": 139,
      "Elisions": 140,
      "ArgElisionList": 141,
      "OptElisions": 142,
      "RangeDots": 143,
      "..": 144,
      "Arg": 145,
      "ArgElision": 146,
      "Elision": 147,
      "SimpleArgs": 148,
      "TRY": 149,
      "Catch": 150,
      "FINALLY": 151,
      "CATCH": 152,
      "THROW": 153,
      "(": 154,
      ")": 155,
      "WhileLineSource": 156,
      "WHILE": 157,
      "WHEN": 158,
      "UNTIL": 159,
      "WhileSource": 160,
      "Loop": 161,
      "LOOP": 162,
      "ForBody": 163,
      "ForLineBody": 164,
      "FOR": 165,
      "BY": 166,
      "ForStart": 167,
      "ForSource": 168,
      "ForLineSource": 169,
      "ForVariables": 170,
      "OWN": 171,
      "ForValue": 172,
      "FORIN": 173,
      "FOROF": 174,
      "FORFROM": 175,
      "SWITCH": 176,
      "Whens": 177,
      "ELSE": 178,
      "When": 179,
      "LEADING_WHEN": 180,
      "IfBlock": 181,
      "IF": 182,
      "POST_IF": 183,
      "IfBlockLine": 184,
      "UNARY": 185,
      "DO": 186,
      "DO_IIFE": 187,
      "UNARY_MATH": 188,
      "-": 189,
      "+": 190,
      "--": 191,
      "++": 192,
      "?": 193,
      "MATH": 194,
      "**": 195,
      "SHIFT": 196,
      "COMPARE": 197,
      "&": 198,
      "^": 199,
      "|": 200,
      "&&": 201,
      "||": 202,
      "BIN?": 203,
      "RELATION": 204,
      "COMPOUND_ASSIGN": 205,
      "$accept": 0,
      "$end": 1
    },
    terminals_: {
      2: "error",
      6: "TERMINATOR",
      14: "STATEMENT",
      32: "YIELD",
      33: "INDENT",
      35: "OUTDENT",
      36: "FROM",
      39: "IDENTIFIER",
      40: "JSX_TAG",
      42: "PROPERTY",
      44: "NUMBER",
      46: "STRING",
      47: "STRING_START",
      49: "STRING_END",
      51: "INTERPOLATION_START",
      52: "INTERPOLATION_END",
      54: "REGEX",
      55: "REGEX_START",
      57: "REGEX_END",
      59: "JS",
      60: "UNDEFINED",
      61: "NULL",
      62: "BOOL",
      63: "INFINITY",
      64: "NAN",
      66: "=",
      70: ":",
      73: "[",
      74: "]",
      75: "@",
      76: "...",
      82: "SUPER",
      85: "DYNAMIC_IMPORT",
      87: "RETURN",
      88: "AWAIT",
      89: "PARAM_START",
      91: "PARAM_END",
      93: "->",
      94: "=>",
      96: ",",
      105: ".",
      106: "INDEX_START",
      107: "INDEX_END",
      108: "NEW_TARGET",
      109: "IMPORT_META",
      110: "?.",
      111: "::",
      112: "?::",
      115: "INDEX_SOAK",
      117: "{",
      119: "}",
      120: "CLASS",
      121: "EXTENDS",
      122: "IMPORT",
      123: "ASSERT",
      128: "AS",
      129: "DEFAULT",
      130: "IMPORT_ALL",
      131: "EXPORT",
      133: "EXPORT_ALL",
      135: "FUNC_EXIST",
      136: "CALL_START",
      137: "CALL_END",
      139: "THIS",
      144: "..",
      149: "TRY",
      151: "FINALLY",
      152: "CATCH",
      153: "THROW",
      154: "(",
      155: ")",
      157: "WHILE",
      158: "WHEN",
      159: "UNTIL",
      162: "LOOP",
      165: "FOR",
      166: "BY",
      171: "OWN",
      173: "FORIN",
      174: "FOROF",
      175: "FORFROM",
      176: "SWITCH",
      178: "ELSE",
      180: "LEADING_WHEN",
      182: "IF",
      183: "POST_IF",
      185: "UNARY",
      186: "DO",
      187: "DO_IIFE",
      188: "UNARY_MATH",
      189: "-",
      190: "+",
      191: "--",
      192: "++",
      193: "?",
      194: "MATH",
      195: "**",
      196: "SHIFT",
      197: "COMPARE",
      198: "&",
      199: "^",
      200: "|",
      201: "&&",
      202: "||",
      203: "BIN?",
      204: "RELATION",
      205: "COMPOUND_ASSIGN"
    },
    productions_: [0, [3, 0], [3, 1], [4, 1], [4, 3], [4, 2], [5, 1], [5, 1], [5, 1], [5, 1], [10, 1], [10, 1], [9, 1], [9, 1], [9, 1], [9, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [8, 1], [8, 1], [8, 1], [28, 1], [28, 2], [28, 4], [28, 3], [37, 2], [37, 3], [38, 1], [38, 1], [41, 1], [43, 1], [43, 1], [45, 1], [45, 3], [48, 1], [48, 2], [50, 3], [50, 5], [50, 2], [50, 1], [53, 1], [53, 3], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [20, 3], [20, 4], [20, 5], [67, 1], [67, 1], [67, 3], [67, 5], [67, 3], [67, 5], [71, 1], [71, 1], [71, 1], [68, 1], [68, 3], [68, 4], [68, 1], [69, 2], [69, 2], [69, 2], [69, 2], [77, 1], [77, 1], [77, 1], [77, 1], [77, 1], [77, 3], [77, 2], [77, 3], [77, 3], [78, 2], [78, 2], [13, 2], [13, 4], [13, 1], [11, 3], [11, 2], [12, 3], [12, 2], [18, 5], [18, 2], [29, 5], [29, 2], [92, 1], [92, 1], [95, 0], [95, 1], [90, 0], [90, 1], [90, 3], [90, 4], [90, 6], [97, 1], [97, 2], [97, 2], [97, 3], [97, 1], [98, 1], [98, 1], [98, 1], [98, 1], [100, 2], [100, 2], [101, 1], [101, 2], [101, 2], [101, 1], [65, 1], [65, 1], [65, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [80, 3], [80, 4], [80, 6], [104, 3], [104, 3], [86, 2], [86, 2], [86, 2], [86, 2], [86, 1], [86, 1], [86, 1], [113, 3], [113, 5], [113, 2], [114, 1], [114, 1], [34, 4], [118, 0], [118, 1], [118, 3], [118, 4], [118, 6], [26, 1], [26, 2], [26, 3], [26, 4], [26, 2], [26, 3], [26, 4], [26, 5], [15, 2], [15, 4], [15, 4], [15, 6], [15, 4], [15, 6], [15, 5], [15, 7], [15, 7], [15, 9], [15, 6], [15, 8], [15, 9], [15, 11], [126, 1], [126, 3], [126, 4], [126, 4], [126, 6], [127, 1], [127, 3], [127, 1], [127, 3], [124, 1], [125, 3], [16, 3], [16, 5], [16, 2], [16, 4], [16, 5], [16, 6], [16, 3], [16, 5], [16, 4], [16, 6], [16, 5], [16, 7], [16, 7], [16, 9], [132, 1], [132, 3], [132, 4], [132, 4], [132, 6], [134, 1], [134, 3], [134, 3], [134, 1], [134, 3], [56, 3], [56, 3], [56, 3], [56, 2], [83, 0], [83, 1], [84, 2], [84, 4], [81, 1], [81, 1], [72, 2], [99, 2], [99, 3], [99, 4], [143, 1], [143, 1], [102, 5], [102, 5], [116, 3], [116, 2], [116, 3], [116, 2], [116, 2], [116, 1], [138, 1], [138, 3], [138, 4], [138, 4], [138, 6], [145, 1], [145, 1], [145, 1], [145, 1], [141, 1], [141, 3], [141, 4], [141, 4], [141, 6], [146, 1], [146, 2], [142, 1], [142, 2], [140, 1], [140, 2], [147, 1], [147, 2], [148, 1], [148, 1], [148, 3], [148, 3], [22, 2], [22, 3], [22, 4], [22, 5], [150, 3], [150, 3], [150, 2], [27, 2], [27, 4], [79, 3], [79, 5], [156, 2], [156, 4], [156, 2], [156, 4], [160, 2], [160, 4], [160, 4], [160, 2], [160, 4], [160, 4], [23, 2], [23, 2], [23, 2], [23, 2], [23, 1], [161, 2], [161, 2], [24, 2], [24, 2], [24, 2], [24, 2], [163, 2], [163, 4], [163, 2], [164, 4], [164, 2], [167, 2], [167, 3], [167, 3], [172, 1], [172, 1], [172, 1], [172, 1], [170, 1], [170, 3], [168, 2], [168, 2], [168, 4], [168, 4], [168, 4], [168, 4], [168, 4], [168, 4], [168, 6], [168, 6], [168, 6], [168, 6], [168, 6], [168, 6], [168, 6], [168, 6], [168, 2], [168, 4], [168, 4], [169, 2], [169, 2], [169, 4], [169, 4], [169, 4], [169, 4], [169, 4], [169, 4], [169, 6], [169, 6], [169, 6], [169, 6], [169, 6], [169, 6], [169, 6], [169, 6], [169, 2], [169, 4], [169, 4], [25, 5], [25, 5], [25, 7], [25, 7], [25, 4], [25, 6], [177, 1], [177, 2], [179, 3], [179, 4], [181, 3], [181, 5], [21, 1], [21, 3], [21, 3], [21, 3], [184, 3], [184, 5], [30, 1], [30, 3], [30, 3], [30, 3], [31, 2], [31, 2], [31, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 4], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 5], [19, 4], [103, 2]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
      /* this == yyval */

      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Root(new yy.Block()));
          break;
        case 2:
          return this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Root($$[$0]));
          break;
        case 3:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(yy.Block.wrap([$$[$0]]));
          break;
        case 4:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)($$[$0 - 2].push($$[$0]));
          break;
        case 5:
          this.$ = $$[$0 - 1];
          break;
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 41:
        case 52:
        case 54:
        case 64:
        case 69:
        case 70:
        case 71:
        case 72:
        case 75:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 104:
        case 105:
        case 116:
        case 117:
        case 118:
        case 119:
        case 125:
        case 126:
        case 129:
        case 135:
        case 149:
        case 247:
        case 248:
        case 249:
        case 251:
        case 264:
        case 265:
        case 308:
        case 309:
        case 364:
        case 370:
          this.$ = $$[$0];
          break;
        case 13:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.StatementLiteral($$[$0]));
          break;
        case 31:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Op($$[$0], new yy.Value(new yy.Literal(''))));
          break;
        case 32:
        case 374:
        case 375:
        case 376:
        case 378:
        case 379:
        case 382:
        case 405:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Op($$[$0 - 1], $$[$0]));
          break;
        case 33:
        case 383:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Op($$[$0 - 3], $$[$0 - 1]));
          break;
        case 34:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Op($$[$0 - 2].concat($$[$0 - 1]), $$[$0]));
          break;
        case 35:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Block());
          break;
        case 36:
        case 150:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)($$[$0 - 1]);
          break;
        case 37:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.IdentifierLiteral($$[$0]));
          break;
        case 38:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(function () {
            var ref, ref1, ref2, ref3;
            return new yy.JSXTag($$[$0].toString(), {
              tagNameLocationData: $$[$0].tagNameToken[2],
              closingTagOpeningBracketLocationData: (ref = $$[$0].closingTagOpeningBracketToken) != null ? ref[2] : void 0,
              closingTagSlashLocationData: (ref1 = $$[$0].closingTagSlashToken) != null ? ref1[2] : void 0,
              closingTagNameLocationData: (ref2 = $$[$0].closingTagNameToken) != null ? ref2[2] : void 0,
              closingTagClosingBracketLocationData: (ref3 = $$[$0].closingTagClosingBracketToken) != null ? ref3[2] : void 0
            });
          }());
          break;
        case 39:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.PropertyName($$[$0].toString()));
          break;
        case 40:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.NumberLiteral($$[$0].toString(), {
            parsedValue: $$[$0].parsedValue
          }));
          break;
        case 42:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.StringLiteral($$[$0].slice(1, -1),
          // strip artificial quotes and unwrap to primitive string
          {
            quote: $$[$0].quote,
            initialChunk: $$[$0].initialChunk,
            finalChunk: $$[$0].finalChunk,
            indent: $$[$0].indent,
            double: $$[$0].double,
            heregex: $$[$0].heregex
          }));
          break;
        case 43:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.StringWithInterpolations(yy.Block.wrap($$[$0 - 1]), {
            quote: $$[$0 - 2].quote,
            startQuote: yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.Literal($$[$0 - 2].toString()))
          }));
          break;
        case 44:
        case 107:
        case 157:
        case 183:
        case 208:
        case 242:
        case 256:
        case 260:
        case 312:
        case 358:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)([$$[$0]]);
          break;
        case 45:
        case 257:
        case 261:
        case 359:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)($$[$0 - 1].concat($$[$0]));
          break;
        case 46:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Interpolation($$[$0 - 1]));
          break;
        case 47:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Interpolation($$[$0 - 2]));
          break;
        case 48:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Interpolation());
          break;
        case 49:
        case 293:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)($$[$0]);
          break;
        case 50:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.RegexLiteral($$[$0].toString(), {
            delimiter: $$[$0].delimiter,
            heregexCommentTokens: $$[$0].heregexCommentTokens
          }));
          break;
        case 51:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.RegexWithInterpolations($$[$0 - 1], {
            heregexCommentTokens: $$[$0].heregexCommentTokens
          }));
          break;
        case 53:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.PassthroughLiteral($$[$0].toString(), {
            here: $$[$0].here,
            generated: $$[$0].generated
          }));
          break;
        case 55:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.UndefinedLiteral($$[$0]));
          break;
        case 56:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.NullLiteral($$[$0]));
          break;
        case 57:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.BooleanLiteral($$[$0].toString(), {
            originalValue: $$[$0].original
          }));
          break;
        case 58:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.InfinityLiteral($$[$0].toString(), {
            originalValue: $$[$0].original
          }));
          break;
        case 59:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.NaNLiteral($$[$0]));
          break;
        case 60:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 2], $$[$0]));
          break;
        case 61:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 3], $$[$0]));
          break;
        case 62:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 4], $$[$0 - 1]));
          break;
        case 63:
        case 122:
        case 127:
        case 128:
        case 130:
        case 131:
        case 132:
        case 133:
        case 134:
        case 136:
        case 137:
        case 310:
        case 311:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Value($$[$0]));
          break;
        case 65:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Assign(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.Value($$[$0 - 2])), $$[$0], 'object', {
            operatorToken: yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Literal($$[$0 - 1]))
          }));
          break;
        case 66:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Assign(yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], null, null, true)(new yy.Value($$[$0 - 4])), $$[$0 - 1], 'object', {
            operatorToken: yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], null, null, true)(new yy.Literal($$[$0 - 3]))
          }));
          break;
        case 67:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Assign(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.Value($$[$0 - 2])), $$[$0], null, {
            operatorToken: yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Literal($$[$0 - 1]))
          }));
          break;
        case 68:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Assign(yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], null, null, true)(new yy.Value($$[$0 - 4])), $$[$0 - 1], null, {
            operatorToken: yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], null, null, true)(new yy.Literal($$[$0 - 3]))
          }));
          break;
        case 73:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Value(new yy.ComputedPropertyName($$[$0 - 1])));
          break;
        case 74:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Value(yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], null, null, true)(new yy.ThisLiteral($$[$0 - 3])), [yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.ComputedPropertyName($$[$0 - 1]))], 'this'));
          break;
        case 76:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Splat(new yy.Value($$[$0 - 1])));
          break;
        case 77:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Splat(new yy.Value($$[$0]), {
            postfix: false
          }));
          break;
        case 78:
        case 120:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Splat($$[$0 - 1]));
          break;
        case 79:
        case 121:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Splat($$[$0], {
            postfix: false
          }));
          break;
        case 85:
        case 220:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.SuperCall(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.Super()), $$[$0], $$[$0 - 1].soak, $$[$0 - 2]));
          break;
        case 86:
        case 221:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.DynamicImportCall(yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.DynamicImport()), $$[$0]));
          break;
        case 87:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Call(new yy.Value($$[$0 - 2]), $$[$0], $$[$0 - 1].soak));
          break;
        case 88:
        case 219:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Call($$[$0 - 2], $$[$0], $$[$0 - 1].soak));
          break;
        case 89:
        case 90:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Value($$[$0 - 1]).add($$[$0]));
          break;
        case 91:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Return($$[$0]));
          break;
        case 92:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Return(new yy.Value($$[$0 - 1])));
          break;
        case 93:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Return());
          break;
        case 94:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.YieldReturn($$[$0], {
            returnKeyword: yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Literal($$[$0 - 1]))
          }));
          break;
        case 95:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.YieldReturn(null, {
            returnKeyword: yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.Literal($$[$0]))
          }));
          break;
        case 96:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.AwaitReturn($$[$0], {
            returnKeyword: yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Literal($$[$0 - 1]))
          }));
          break;
        case 97:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.AwaitReturn(null, {
            returnKeyword: yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.Literal($$[$0]))
          }));
          break;
        case 98:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Code($$[$0 - 3], $$[$0], $$[$0 - 1], yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], null, null, true)(new yy.Literal($$[$0 - 4]))));
          break;
        case 99:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Code([], $$[$0], $$[$0 - 1]));
          break;
        case 100:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Code($$[$0 - 3], yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(yy.Block.wrap([$$[$0]])), $$[$0 - 1], yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], null, null, true)(new yy.Literal($$[$0 - 4]))));
          break;
        case 101:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Code([], yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(yy.Block.wrap([$$[$0]])), $$[$0 - 1]));
          break;
        case 102:
        case 103:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.FuncGlyph($$[$0]));
          break;
        case 106:
        case 156:
        case 258:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)([]);
          break;
        case 108:
        case 158:
        case 184:
        case 209:
        case 243:
        case 252:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)($$[$0 - 2].concat($$[$0]));
          break;
        case 109:
        case 159:
        case 185:
        case 210:
        case 244:
        case 253:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)($$[$0 - 3].concat($$[$0]));
          break;
        case 110:
        case 160:
        case 187:
        case 212:
        case 246:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)($$[$0 - 5].concat($$[$0 - 2]));
          break;
        case 111:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Param($$[$0]));
          break;
        case 112:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Param($$[$0 - 1], null, true));
          break;
        case 113:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Param($$[$0], null, {
            postfix: false
          }));
          break;
        case 114:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Param($$[$0 - 2], $$[$0]));
          break;
        case 115:
        case 250:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Expansion());
          break;
        case 123:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)($$[$0 - 1].add($$[$0]));
          break;
        case 124:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Value($$[$0 - 1]).add($$[$0]));
          break;
        case 138:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Super(yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.Access($$[$0])), yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.Literal($$[$0 - 2]))));
          break;
        case 139:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Super(yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Index($$[$0 - 1])), yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], null, null, true)(new yy.Literal($$[$0 - 3]))));
          break;
        case 140:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)(new yy.Super(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.Index($$[$0 - 2])), yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], null, null, true)(new yy.Literal($$[$0 - 5]))));
          break;
        case 141:
        case 142:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.MetaProperty(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.IdentifierLiteral($$[$0 - 2])), yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.Access($$[$0]))));
          break;
        case 143:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Access($$[$0]));
          break;
        case 144:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Access($$[$0], {
            soak: true
          }));
          break;
        case 145:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)([yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Access(new yy.PropertyName('prototype'), {
            shorthand: true
          })), yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.Access($$[$0]))]);
          break;
        case 146:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)([yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Access(new yy.PropertyName('prototype'), {
            shorthand: true,
            soak: true
          })), yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.Access($$[$0]))]);
          break;
        case 147:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Access(new yy.PropertyName('prototype'), {
            shorthand: true
          }));
          break;
        case 148:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Access(new yy.PropertyName('prototype'), {
            shorthand: true,
            soak: true
          }));
          break;
        case 151:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)($$[$0 - 2]);
          break;
        case 152:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(yy.extend($$[$0], {
            soak: true
          }));
          break;
        case 153:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Index($$[$0]));
          break;
        case 154:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Slice($$[$0]));
          break;
        case 155:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Obj($$[$0 - 2], $$[$0 - 3].generated));
          break;
        case 161:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Class());
          break;
        case 162:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Class(null, null, $$[$0]));
          break;
        case 163:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Class(null, $$[$0]));
          break;
        case 164:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Class(null, $$[$0 - 1], $$[$0]));
          break;
        case 165:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Class($$[$0]));
          break;
        case 166:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Class($$[$0 - 1], null, $$[$0]));
          break;
        case 167:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Class($$[$0 - 2], $$[$0]));
          break;
        case 168:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Class($$[$0 - 3], $$[$0 - 1], $$[$0]));
          break;
        case 169:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.ImportDeclaration(null, $$[$0]));
          break;
        case 170:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.ImportDeclaration(null, $$[$0 - 2], $$[$0]));
          break;
        case 171:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 2], null), $$[$0]));
          break;
        case 172:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 4], null), $$[$0 - 2], $$[$0]));
          break;
        case 173:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause(null, $$[$0 - 2]), $$[$0]));
          break;
        case 174:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause(null, $$[$0 - 4]), $$[$0 - 2], $$[$0]));
          break;
        case 175:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause(null, new yy.ImportSpecifierList([])), $$[$0]));
          break;
        case 176:
          this.$ = yy.addDataToNode(yy, _$[$0 - 6], $$[$0 - 6], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause(null, new yy.ImportSpecifierList([])), $$[$0 - 2], $$[$0]));
          break;
        case 177:
          this.$ = yy.addDataToNode(yy, _$[$0 - 6], $$[$0 - 6], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause(null, new yy.ImportSpecifierList($$[$0 - 4])), $$[$0]));
          break;
        case 178:
          this.$ = yy.addDataToNode(yy, _$[$0 - 8], $$[$0 - 8], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause(null, new yy.ImportSpecifierList($$[$0 - 6])), $$[$0 - 2], $$[$0]));
          break;
        case 179:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 4], $$[$0 - 2]), $$[$0]));
          break;
        case 180:
          this.$ = yy.addDataToNode(yy, _$[$0 - 7], $$[$0 - 7], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 6], $$[$0 - 4]), $$[$0 - 2], $$[$0]));
          break;
        case 181:
          this.$ = yy.addDataToNode(yy, _$[$0 - 8], $$[$0 - 8], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 7], new yy.ImportSpecifierList($$[$0 - 4])), $$[$0]));
          break;
        case 182:
          this.$ = yy.addDataToNode(yy, _$[$0 - 10], $$[$0 - 10], _$[$0], $$[$0], true)(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 9], new yy.ImportSpecifierList($$[$0 - 6])), $$[$0 - 2], $$[$0]));
          break;
        case 186:
        case 211:
        case 245:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)($$[$0 - 2]);
          break;
        case 188:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.ImportSpecifier($$[$0]));
          break;
        case 189:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.ImportSpecifier($$[$0 - 2], $$[$0]));
          break;
        case 190:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.ImportSpecifier(yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.DefaultLiteral($$[$0]))));
          break;
        case 191:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.ImportSpecifier(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.DefaultLiteral($$[$0 - 2])), $$[$0]));
          break;
        case 192:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.ImportDefaultSpecifier($$[$0]));
          break;
        case 193:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.ImportNamespaceSpecifier(new yy.Literal($$[$0 - 2]), $$[$0]));
          break;
        case 194:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList([])));
          break;
        case 195:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList($$[$0 - 2])));
          break;
        case 196:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration($$[$0]));
          break;
        case 197:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 2], $$[$0], null, {
            moduleDeclaration: 'export'
          }))));
          break;
        case 198:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 3], $$[$0], null, {
            moduleDeclaration: 'export'
          }))));
          break;
        case 199:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 4], $$[$0 - 1], null, {
            moduleDeclaration: 'export'
          }))));
          break;
        case 200:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.ExportDefaultDeclaration($$[$0]));
          break;
        case 201:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.ExportDefaultDeclaration(new yy.Value($$[$0 - 1])));
          break;
        case 202:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.ExportAllDeclaration(new yy.Literal($$[$0 - 2]), $$[$0]));
          break;
        case 203:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)(new yy.ExportAllDeclaration(new yy.Literal($$[$0 - 4]), $$[$0 - 2], $$[$0]));
          break;
        case 204:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList([]), $$[$0]));
          break;
        case 205:
          this.$ = yy.addDataToNode(yy, _$[$0 - 6], $$[$0 - 6], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList([]), $$[$0 - 2], $$[$0]));
          break;
        case 206:
          this.$ = yy.addDataToNode(yy, _$[$0 - 6], $$[$0 - 6], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList($$[$0 - 4]), $$[$0]));
          break;
        case 207:
          this.$ = yy.addDataToNode(yy, _$[$0 - 8], $$[$0 - 8], _$[$0], $$[$0], true)(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList($$[$0 - 6]), $$[$0 - 2], $$[$0]));
          break;
        case 213:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.ExportSpecifier($$[$0]));
          break;
        case 214:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.ExportSpecifier($$[$0 - 2], $$[$0]));
          break;
        case 215:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.ExportSpecifier($$[$0 - 2], yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.DefaultLiteral($$[$0]))));
          break;
        case 216:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.ExportSpecifier(yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.DefaultLiteral($$[$0]))));
          break;
        case 217:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.ExportSpecifier(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.DefaultLiteral($$[$0 - 2])), $$[$0]));
          break;
        case 218:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.TaggedTemplateCall($$[$0 - 2], $$[$0], $$[$0 - 1].soak));
          break;
        case 222:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)({
            soak: false
          });
          break;
        case 223:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)({
            soak: true
          });
          break;
        case 224:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)([]);
          break;
        case 225:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(function () {
            $$[$0 - 2].implicit = $$[$0 - 3].generated;
            return $$[$0 - 2];
          }());
          break;
        case 226:
        case 227:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Value(new yy.ThisLiteral($$[$0])));
          break;
        case 228:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Value(yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.ThisLiteral($$[$0 - 1])), [yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.Access($$[$0]))], 'this'));
          break;
        case 229:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Arr([]));
          break;
        case 230:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Arr($$[$0 - 1]));
          break;
        case 231:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Arr([].concat($$[$0 - 2], $$[$0 - 1])));
          break;
        case 232:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)({
            exclusive: false
          });
          break;
        case 233:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)({
            exclusive: true
          });
          break;
        case 234:
        case 235:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Range($$[$0 - 3], $$[$0 - 1], $$[$0 - 2].exclusive ? 'exclusive' : 'inclusive'));
          break;
        case 236:
        case 238:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Range($$[$0 - 2], $$[$0], $$[$0 - 1].exclusive ? 'exclusive' : 'inclusive'));
          break;
        case 237:
        case 239:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Range($$[$0 - 1], null, $$[$0].exclusive ? 'exclusive' : 'inclusive'));
          break;
        case 240:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Range(null, $$[$0], $$[$0 - 1].exclusive ? 'exclusive' : 'inclusive'));
          break;
        case 241:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Range(null, null, $$[$0].exclusive ? 'exclusive' : 'inclusive'));
          break;
        case 254:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)($$[$0 - 2].concat($$[$0 - 1]));
          break;
        case 255:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)($$[$0 - 5].concat($$[$0 - 4], $$[$0 - 2], $$[$0 - 1]));
          break;
        case 259:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)([].concat($$[$0]));
          break;
        case 262:
          this.$ = yy.addDataToNode(yy, _$[$0], $$[$0], _$[$0], $$[$0], true)(new yy.Elision());
          break;
        case 263:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)($$[$0 - 1]);
          break;
        case 266:
        case 267:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)([].concat($$[$0 - 2], $$[$0]));
          break;
        case 268:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Try($$[$0]));
          break;
        case 269:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Try($$[$0 - 1], $$[$0]));
          break;
        case 270:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Try($$[$0 - 2], null, $$[$0], yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Literal($$[$0 - 1]))));
          break;
        case 271:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Try($$[$0 - 3], $$[$0 - 2], $$[$0], yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Literal($$[$0 - 1]))));
          break;
        case 272:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Catch($$[$0], $$[$0 - 1]));
          break;
        case 273:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Catch($$[$0], yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Value($$[$0 - 1]))));
          break;
        case 274:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Catch($$[$0]));
          break;
        case 275:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Throw($$[$0]));
          break;
        case 276:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Throw(new yy.Value($$[$0 - 1])));
          break;
        case 277:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Parens($$[$0 - 1]));
          break;
        case 278:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Parens($$[$0 - 2]));
          break;
        case 279:
        case 283:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.While($$[$0]));
          break;
        case 280:
        case 284:
        case 285:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.While($$[$0 - 2], {
            guard: $$[$0]
          }));
          break;
        case 281:
        case 286:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.While($$[$0], {
            invert: true
          }));
          break;
        case 282:
        case 287:
        case 288:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.While($$[$0 - 2], {
            invert: true,
            guard: $$[$0]
          }));
          break;
        case 289:
        case 290:
        case 298:
        case 299:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)($$[$0 - 1].addBody($$[$0]));
          break;
        case 291:
        case 292:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(Object.assign($$[$0], {
            postfix: true
          }).addBody(yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(yy.Block.wrap([$$[$0 - 1]]))));
          break;
        case 294:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.While(yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.BooleanLiteral('true')), {
            isLoop: true
          }).addBody($$[$0]));
          break;
        case 295:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.While(yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.BooleanLiteral('true')), {
            isLoop: true
          }).addBody(yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(yy.Block.wrap([$$[$0]]))));
          break;
        case 296:
        case 297:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(function () {
            $$[$0].postfix = true;
            return $$[$0].addBody($$[$0 - 1]);
          }());
          break;
        case 300:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.For([], {
            source: yy.addDataToNode(yy, _$[$0], $$[$0], null, null, true)(new yy.Value($$[$0]))
          }));
          break;
        case 301:
        case 303:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.For([], {
            source: yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(new yy.Value($$[$0 - 2])),
            step: $$[$0]
          }));
          break;
        case 302:
        case 304:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)($$[$0 - 1].addSource($$[$0]));
          break;
        case 305:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.For([], {
            name: $$[$0][0],
            index: $$[$0][1]
          }));
          break;
        case 306:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(function () {
            var index, name;
            [name, index] = $$[$0];
            return new yy.For([], {
              name,
              index,
              await: true,
              awaitTag: yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Literal($$[$0 - 1]))
            });
          }());
          break;
        case 307:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(function () {
            var index, name;
            [name, index] = $$[$0];
            return new yy.For([], {
              name,
              index,
              own: true,
              ownTag: yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], null, null, true)(new yy.Literal($$[$0 - 1]))
            });
          }());
          break;
        case 313:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)([$$[$0 - 2], $$[$0]]);
          break;
        case 314:
        case 333:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)({
            source: $$[$0]
          });
          break;
        case 315:
        case 334:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)({
            source: $$[$0],
            object: true
          });
          break;
        case 316:
        case 317:
        case 335:
        case 336:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)({
            source: $$[$0 - 2],
            guard: $$[$0]
          });
          break;
        case 318:
        case 319:
        case 337:
        case 338:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)({
            source: $$[$0 - 2],
            guard: $$[$0],
            object: true
          });
          break;
        case 320:
        case 321:
        case 339:
        case 340:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)({
            source: $$[$0 - 2],
            step: $$[$0]
          });
          break;
        case 322:
        case 323:
        case 324:
        case 325:
        case 341:
        case 342:
        case 343:
        case 344:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)({
            source: $$[$0 - 4],
            guard: $$[$0 - 2],
            step: $$[$0]
          });
          break;
        case 326:
        case 327:
        case 328:
        case 329:
        case 345:
        case 346:
        case 347:
        case 348:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)({
            source: $$[$0 - 4],
            step: $$[$0 - 2],
            guard: $$[$0]
          });
          break;
        case 330:
        case 349:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)({
            source: $$[$0],
            from: true
          });
          break;
        case 331:
        case 332:
        case 350:
        case 351:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)({
            source: $$[$0 - 2],
            guard: $$[$0],
            from: true
          });
          break;
        case 352:
        case 353:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Switch($$[$0 - 3], $$[$0 - 1]));
          break;
        case 354:
        case 355:
          this.$ = yy.addDataToNode(yy, _$[$0 - 6], $$[$0 - 6], _$[$0], $$[$0], true)(new yy.Switch($$[$0 - 5], $$[$0 - 3], yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0 - 1], $$[$0 - 1], true)($$[$0 - 1])));
          break;
        case 356:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Switch(null, $$[$0 - 1]));
          break;
        case 357:
          this.$ = yy.addDataToNode(yy, _$[$0 - 5], $$[$0 - 5], _$[$0], $$[$0], true)(new yy.Switch(null, $$[$0 - 3], yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0 - 1], $$[$0 - 1], true)($$[$0 - 1])));
          break;
        case 360:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.SwitchWhen($$[$0 - 1], $$[$0]));
          break;
        case 361:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], false)(yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0 - 1], $$[$0 - 1], true)(new yy.SwitchWhen($$[$0 - 2], $$[$0 - 1])));
          break;
        case 362:
        case 368:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.If($$[$0 - 1], $$[$0], {
            type: $$[$0 - 2]
          }));
          break;
        case 363:
        case 369:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)($$[$0 - 4].addElse(yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.If($$[$0 - 1], $$[$0], {
            type: $$[$0 - 2]
          }))));
          break;
        case 365:
        case 371:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)($$[$0 - 2].addElse($$[$0]));
          break;
        case 366:
        case 367:
        case 372:
        case 373:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.If($$[$0], yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], null, null, true)(yy.Block.wrap([$$[$0 - 2]])), {
            type: $$[$0 - 1],
            postfix: true
          }));
          break;
        case 377:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Op($$[$0 - 1].toString(), $$[$0], void 0, void 0, {
            originalOperator: $$[$0 - 1].original
          }));
          break;
        case 380:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Op('-', $$[$0]));
          break;
        case 381:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Op('+', $$[$0]));
          break;
        case 384:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Op('--', $$[$0]));
          break;
        case 385:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Op('++', $$[$0]));
          break;
        case 386:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Op('--', $$[$0 - 1], null, true));
          break;
        case 387:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Op('++', $$[$0 - 1], null, true));
          break;
        case 388:
          this.$ = yy.addDataToNode(yy, _$[$0 - 1], $$[$0 - 1], _$[$0], $$[$0], true)(new yy.Existence($$[$0 - 1]));
          break;
        case 389:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Op('+', $$[$0 - 2], $$[$0]));
          break;
        case 390:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Op('-', $$[$0 - 2], $$[$0]));
          break;
        case 391:
        case 392:
        case 393:
        case 395:
        case 396:
        case 397:
        case 400:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Op($$[$0 - 1], $$[$0 - 2], $$[$0]));
          break;
        case 394:
        case 398:
        case 399:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Op($$[$0 - 1].toString(), $$[$0 - 2], $$[$0], void 0, {
            originalOperator: $$[$0 - 1].original
          }));
          break;
        case 401:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(function () {
            var ref, ref1;
            return new yy.Op($$[$0 - 1].toString(), $$[$0 - 2], $$[$0], void 0, {
              invertOperator: (ref = (ref1 = $$[$0 - 1].invert) != null ? ref1.original : void 0) != null ? ref : $$[$0 - 1].invert
            });
          }());
          break;
        case 402:
          this.$ = yy.addDataToNode(yy, _$[$0 - 2], $$[$0 - 2], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 2], $$[$0], $$[$0 - 1].toString(), {
            originalContext: $$[$0 - 1].original
          }));
          break;
        case 403:
          this.$ = yy.addDataToNode(yy, _$[$0 - 4], $$[$0 - 4], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 4], $$[$0 - 1], $$[$0 - 3].toString(), {
            originalContext: $$[$0 - 3].original
          }));
          break;
        case 404:
          this.$ = yy.addDataToNode(yy, _$[$0 - 3], $$[$0 - 3], _$[$0], $$[$0], true)(new yy.Assign($$[$0 - 3], $$[$0], $$[$0 - 2].toString(), {
            originalContext: $$[$0 - 2].original
          }));
          break;
      }
    },
    table: [{
      1: [2, 1],
      3: 1,
      4: 2,
      5: 3,
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      11: 27,
      12: 28,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $V1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      1: [3]
    }, {
      1: [2, 2],
      6: $VM
    }, o($VN, [2, 3]), o($VO, [2, 6], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($VO, [2, 7]), o($VO, [2, 8], {
      167: 123,
      160: 125,
      163: 126,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $V51
    }), o($VO, [2, 9]), o($V61, [2, 16], {
      83: 127,
      86: 128,
      113: 134,
      46: $V71,
      47: $V71,
      136: $V71,
      105: $V81,
      106: $V91,
      110: $Va1,
      111: $Vb1,
      112: $Vc1,
      115: $Vd1,
      135: $Ve1
    }), o($V61, [2, 17], {
      113: 134,
      86: 137,
      105: $V81,
      106: $V91,
      110: $Va1,
      111: $Vb1,
      112: $Vc1,
      115: $Vd1
    }), o($V61, [2, 18]), o($V61, [2, 19]), o($V61, [2, 20]), o($V61, [2, 21]), o($V61, [2, 22]), o($V61, [2, 23]), o($V61, [2, 24]), o($V61, [2, 25]), o($V61, [2, 26]), o($V61, [2, 27]), o($VO, [2, 28]), o($VO, [2, 29]), o($VO, [2, 30]), o($Vf1, [2, 12]), o($Vf1, [2, 13]), o($Vf1, [2, 14]), o($Vf1, [2, 15]), o($VO, [2, 10]), o($VO, [2, 11]), o($Vg1, $Vh1, {
      66: [1, 138]
    }), o($Vg1, [2, 130]), o($Vg1, [2, 131]), o($Vg1, [2, 132]), o($Vg1, $Vi1), o($Vg1, [2, 134]), o($Vg1, [2, 135]), o($Vg1, [2, 136]), o($Vg1, [2, 137]), o($Vj1, $Vk1, {
      90: 139,
      97: 140,
      98: 141,
      38: 143,
      72: 144,
      99: 145,
      34: 146,
      39: $V2,
      40: $V3,
      73: $Vl1,
      75: $Vm1,
      76: $Vn1,
      117: $Vq
    }), {
      5: 150,
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      11: 27,
      12: 28,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $V1,
      33: $Vo1,
      34: 66,
      37: 149,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 152,
      8: 153,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 157,
      8: 158,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 159,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 167,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 168,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 169,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: $Vw1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: [1, 171],
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      17: 173,
      18: 174,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 175,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 172,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      139: $Vu,
      154: $Vx,
      187: $Vv1
    }, {
      17: 173,
      18: 174,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 175,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 176,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      139: $Vu,
      154: $Vx,
      187: $Vv1
    }, o($Vx1, $Vy1, {
      191: [1, 177],
      192: [1, 178],
      205: [1, 179]
    }), o($V61, [2, 364], {
      178: [1, 180]
    }), {
      33: $Vo1,
      37: 181
    }, {
      33: $Vo1,
      37: 182
    }, {
      33: $Vo1,
      37: 183
    }, o($V61, [2, 293]), {
      33: $Vo1,
      37: 184
    }, {
      33: $Vo1,
      37: 185
    }, {
      7: 186,
      8: 187,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: [1, 188],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vz1, [2, 161], {
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      45: 95,
      92: 161,
      17: 173,
      18: 174,
      65: 175,
      37: 189,
      101: 191,
      33: $Vo1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      121: [1, 190],
      139: $Vu,
      154: $Vx,
      187: $Vv1
    }), {
      7: 192,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: [1, 193],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o([1, 6, 35, 52, 74, 76, 96, 137, 144, 155, 157, 158, 159, 165, 166, 183, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204], $VA1, {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 194,
      14: $V0,
      32: $Vp1,
      33: $VB1,
      36: $VC1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: [1, 197],
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      162: $VA,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($VO, [2, 370], {
      178: [1, 198]
    }), {
      18: 200,
      29: 199,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn
    }, o([1, 6, 35, 52, 74, 76, 96, 137, 144, 155, 157, 158, 159, 165, 166, 183], $VD1, {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 201,
      14: $V0,
      32: $Vp1,
      33: $VE1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      162: $VA,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), {
      38: 207,
      39: $V2,
      40: $V3,
      45: 203,
      46: $V5,
      47: $V6,
      117: [1, 206],
      124: 204,
      125: 205,
      130: $VF1
    }, {
      26: 210,
      38: 211,
      39: $V2,
      40: $V3,
      117: [1, 209],
      120: $Vr,
      129: [1, 212],
      133: [1, 213]
    }, o($Vx1, [2, 127]), o($Vx1, [2, 128]), o($Vg1, [2, 52]), o($Vg1, [2, 53]), o($Vg1, [2, 54]), o($Vg1, [2, 55]), o($Vg1, [2, 56]), o($Vg1, [2, 57]), o($Vg1, [2, 58]), o($Vg1, [2, 59]), {
      4: 214,
      5: 3,
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      11: 27,
      12: 28,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $V1,
      33: [1, 215],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 216,
      8: 217,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: $VG1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      74: $VH1,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      140: 219,
      141: 220,
      145: 225,
      146: 222,
      147: 221,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      83: 228,
      105: $VK1,
      106: $VL1,
      135: $Ve1,
      136: $V71
    }, {
      84: 231,
      136: $VM1
    }, o($Vg1, [2, 226]), o($Vg1, $VN1, {
      41: 233,
      42: $VO1
    }), {
      105: [1, 235]
    }, {
      105: [1, 236]
    }, o($VP1, [2, 102]), o($VP1, [2, 103]), o($VQ1, [2, 122]), o($VQ1, [2, 125]), {
      7: 237,
      8: 238,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 239,
      8: 240,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 241,
      8: 242,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 244,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: $Vo1,
      34: 66,
      37: 243,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      34: 253,
      38: 250,
      39: $V2,
      40: $V3,
      72: 251,
      73: $Vf,
      75: $Vm1,
      88: $VR1,
      99: 252,
      102: 245,
      117: $Vq,
      170: 246,
      171: $VS1,
      172: 249
    }, {
      168: 254,
      169: 255,
      173: [1, 256],
      174: [1, 257],
      175: [1, 258]
    }, o([6, 33, 96, 119], $VT1, {
      45: 95,
      118: 259,
      67: 260,
      68: 261,
      69: 262,
      71: 263,
      43: 266,
      77: 268,
      38: 269,
      41: 270,
      72: 271,
      78: 272,
      34: 273,
      79: 274,
      80: 275,
      81: 276,
      39: $V2,
      40: $V3,
      42: $VO1,
      44: $V4,
      46: $V5,
      47: $V6,
      73: $VU1,
      75: $VV1,
      76: $VW1,
      82: $VX1,
      85: $VY1,
      117: $Vq,
      139: $Vu,
      154: $Vx
    }), o($VZ1, [2, 40]), o($VZ1, [2, 41]), o($Vg1, [2, 50]), {
      17: 173,
      18: 174,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 279,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 175,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 280,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      139: $Vu,
      154: $Vx,
      187: $Vv1
    }, o($V_1, [2, 37]), o($V_1, [2, 38]), o($V$1, [2, 42]), {
      45: 284,
      46: $V5,
      47: $V6,
      48: 281,
      50: 282,
      51: $V02
    }, o($VN, [2, 5], {
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      13: 23,
      15: 25,
      16: 26,
      11: 27,
      12: 28,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      92: 39,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      184: 60,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      5: 285,
      14: $V0,
      32: $V1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $Vy,
      159: $Vz,
      162: $VA,
      165: $VB,
      176: $VC,
      182: $VD,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($V61, [2, 388]), {
      7: 286,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 287,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 288,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 289,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 290,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 291,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 292,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 293,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 294,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 295,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 296,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 297,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 298,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 299,
      8: 300,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V61, [2, 292]), o($V61, [2, 297]), {
      7: 239,
      8: 301,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 241,
      8: 302,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      34: 253,
      38: 250,
      39: $V2,
      40: $V3,
      72: 251,
      73: $Vf,
      75: $Vm1,
      88: $VR1,
      99: 252,
      102: 303,
      117: $Vq,
      170: 246,
      171: $VS1,
      172: 249
    }, {
      168: 254,
      173: [1, 304],
      174: [1, 305],
      175: [1, 306]
    }, {
      7: 307,
      8: 308,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V61, [2, 291]), o($V61, [2, 296]), {
      45: 309,
      46: $V5,
      47: $V6,
      84: 310,
      136: $VM1
    }, o($VQ1, [2, 123]), o($V12, [2, 223]), {
      41: 311,
      42: $VO1
    }, {
      41: 312,
      42: $VO1
    }, o($VQ1, [2, 147], {
      41: 313,
      42: $VO1
    }), o($VQ1, [2, 148], {
      41: 314,
      42: $VO1
    }), o($VQ1, [2, 149]), {
      7: 317,
      8: 319,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: [1, 316],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $V22,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      114: 315,
      116: 318,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      143: 320,
      144: $V32,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      106: $V91,
      113: 323,
      115: $Vd1
    }, o($VQ1, [2, 124]), {
      6: [1, 325],
      7: 324,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: [1, 326],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V42, $V52, {
      95: 329,
      91: [1, 327],
      96: $V62
    }), o($V72, [2, 107]), o($V72, [2, 111], {
      66: [1, 331],
      76: [1, 330]
    }), o($V72, [2, 115], {
      38: 143,
      72: 144,
      99: 145,
      34: 146,
      98: 332,
      39: $V2,
      40: $V3,
      73: $Vl1,
      75: $Vm1,
      117: $Vq
    }), o($V82, [2, 116]), o($V82, [2, 117]), o($V82, [2, 118]), o($V82, [2, 119]), {
      41: 233,
      42: $VO1
    }, {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: $VG1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      74: $VH1,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      140: 219,
      141: 220,
      145: 225,
      146: 222,
      147: 221,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vg1, [2, 99]), o($VO, [2, 101]), {
      4: 336,
      5: 3,
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      11: 27,
      12: 28,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $V1,
      34: 66,
      35: [1, 335],
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V92, $Va2, {
      160: 118,
      163: 119,
      167: 123,
      193: $VV
    }), o($VO, [2, 374]), {
      7: 169,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: $Vw1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      157: $VP,
      159: $VQ,
      160: 125,
      163: 126,
      165: $VR,
      167: 123,
      183: $V51
    }, o([1, 6, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204], $VA1, {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 194,
      14: $V0,
      32: $Vp1,
      33: $VB1,
      36: $VC1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      162: $VA,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($V92, $Vb2, {
      160: 118,
      163: 119,
      167: 123,
      193: $VV
    }), o($VO, [2, 375]), o($Vc2, [2, 379], {
      160: 118,
      163: 119,
      167: 123,
      193: $VV,
      195: $VX
    }), o($Vj1, $Vk1, {
      97: 140,
      98: 141,
      38: 143,
      72: 144,
      99: 145,
      34: 146,
      90: 338,
      39: $V2,
      40: $V3,
      73: $Vl1,
      75: $Vm1,
      76: $Vn1,
      117: $Vq
    }), {
      33: $Vo1,
      37: 149
    }, {
      7: 339,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 340,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      157: $VP,
      159: $VQ,
      160: 125,
      163: 126,
      165: $VR,
      167: 123,
      183: [1, 341]
    }, {
      18: 200,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn
    }, {
      7: 342,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vc2, [2, 380], {
      160: 118,
      163: 119,
      167: 123,
      193: $VV,
      195: $VX
    }), o($Vc2, [2, 381], {
      160: 118,
      163: 119,
      167: 123,
      193: $VV,
      195: $VX
    }), o($V92, [2, 382], {
      160: 118,
      163: 119,
      167: 123,
      193: $VV
    }), {
      34: 343,
      117: $Vq
    }, o($VO, [2, 97], {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 344,
      14: $V0,
      32: $Vp1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $VD1,
      159: $VD1,
      165: $VD1,
      183: $VD1,
      162: $VA,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($V61, [2, 384], {
      46: $Vy1,
      47: $Vy1,
      105: $Vy1,
      106: $Vy1,
      110: $Vy1,
      111: $Vy1,
      112: $Vy1,
      115: $Vy1,
      135: $Vy1,
      136: $Vy1
    }), o($V12, $V71, {
      83: 127,
      86: 128,
      113: 134,
      105: $V81,
      106: $V91,
      110: $Va1,
      111: $Vb1,
      112: $Vc1,
      115: $Vd1,
      135: $Ve1
    }), {
      86: 137,
      105: $V81,
      106: $V91,
      110: $Va1,
      111: $Vb1,
      112: $Vc1,
      113: 134,
      115: $Vd1
    }, o($Vd2, $Vh1), o($V61, [2, 385], {
      46: $Vy1,
      47: $Vy1,
      105: $Vy1,
      106: $Vy1,
      110: $Vy1,
      111: $Vy1,
      112: $Vy1,
      115: $Vy1,
      135: $Vy1,
      136: $Vy1
    }), o($V61, [2, 386]), o($V61, [2, 387]), {
      6: [1, 347],
      7: 345,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: [1, 346],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      33: $Vo1,
      37: 348,
      182: [1, 349]
    }, o($V61, [2, 268], {
      150: 350,
      151: [1, 351],
      152: [1, 352]
    }), o($V61, [2, 289]), o($V61, [2, 290]), o($V61, [2, 298]), o($V61, [2, 299]), {
      33: [1, 353],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [1, 354]
    }, {
      177: 355,
      179: 356,
      180: $Ve2
    }, o($V61, [2, 162]), {
      7: 358,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vz1, [2, 165], {
      37: 359,
      33: $Vo1,
      46: $Vy1,
      47: $Vy1,
      105: $Vy1,
      106: $Vy1,
      110: $Vy1,
      111: $Vy1,
      112: $Vy1,
      115: $Vy1,
      135: $Vy1,
      136: $Vy1,
      121: [1, 360]
    }), o($Vf2, [2, 275], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      34: 361,
      117: $Vq
    }, o($Vf2, [2, 32], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      34: 362,
      117: $Vq
    }, {
      7: 363,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o([1, 6, 35, 52, 74, 76, 96, 137, 144, 155, 158, 166], [2, 95], {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 364,
      14: $V0,
      32: $Vp1,
      33: $VE1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $VD1,
      159: $VD1,
      165: $VD1,
      183: $VD1,
      162: $VA,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), {
      33: $Vo1,
      37: 365,
      182: [1, 366]
    }, o($VO, [2, 376]), o($Vg1, [2, 405]), o($Vf1, $Vg2, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      34: 367,
      117: $Vq
    }, o($Vf1, [2, 169], {
      123: [1, 368]
    }), {
      36: [1, 369],
      96: [1, 370]
    }, {
      36: [1, 371]
    }, {
      33: $Vh2,
      38: 376,
      39: $V2,
      40: $V3,
      119: [1, 372],
      126: 373,
      127: 374,
      129: $Vi2
    }, o([36, 96], [2, 192]), {
      128: [1, 378]
    }, {
      33: $Vj2,
      38: 383,
      39: $V2,
      40: $V3,
      119: [1, 379],
      129: $Vk2,
      132: 380,
      134: 381
    }, o($Vf1, [2, 196]), {
      66: [1, 385]
    }, {
      7: 386,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: [1, 387],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      36: [1, 388]
    }, {
      6: $VM,
      155: [1, 389]
    }, {
      4: 390,
      5: 3,
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      11: 27,
      12: 28,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $V1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vl2, $Vm2, {
      160: 118,
      163: 119,
      167: 123,
      143: 391,
      76: [1, 392],
      144: $V32,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vl2, $Vn2, {
      143: 393,
      76: $V22,
      144: $V32
    }), o($Vo2, [2, 229]), {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      74: [1, 394],
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      145: 396,
      147: 395,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o([6, 33, 74], $V52, {
      142: 397,
      95: 399,
      96: $Vp2
    }), o($Vq2, [2, 260], {
      6: $Vr2
    }), o($Vs2, [2, 251]), {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: $VG1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      140: 402,
      141: 401,
      145: 225,
      146: 222,
      147: 221,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vt2, [2, 262]), o($Vs2, [2, 256]), o($Vu2, [2, 249]), o($Vu2, [2, 250], {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 403,
      14: $V0,
      32: $Vp1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $Vy,
      159: $Vz,
      162: $VA,
      165: $VB,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), {
      84: 404,
      136: $VM1
    }, {
      41: 405,
      42: $VO1
    }, {
      7: 406,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: [1, 407],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vv2, [2, 221]), {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: $Vw2,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      137: [1, 408],
      138: 409,
      139: $Vu,
      145: 410,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vx2, [2, 228]), o($Vx2, [2, 39]), {
      41: 412,
      42: $VO1
    }, {
      41: 413,
      42: $VO1
    }, {
      33: $Vo1,
      37: 414,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: $Vo1,
      37: 415
    }, o($Vy2, [2, 283], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      158: [1, 416],
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      33: [2, 279],
      158: [1, 417]
    }, o($Vy2, [2, 286], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      158: [1, 418],
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      33: [2, 281],
      158: [1, 419]
    }, o($V61, [2, 294]), o($Vz2, [2, 295], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      33: $VA2,
      166: [1, 420]
    }, o($VB2, [2, 305]), {
      34: 253,
      38: 250,
      39: $V2,
      40: $V3,
      72: 251,
      73: $Vl1,
      75: $Vm1,
      99: 252,
      117: $Vq,
      170: 421,
      172: 249
    }, {
      34: 253,
      38: 250,
      39: $V2,
      40: $V3,
      72: 251,
      73: $Vl1,
      75: $Vm1,
      99: 252,
      117: $Vq,
      170: 422,
      172: 249
    }, o($VB2, [2, 312], {
      96: [1, 423]
    }), o($VC2, [2, 308]), o($VC2, [2, 309]), o($VC2, [2, 310]), o($VC2, [2, 311]), o($V61, [2, 302]), {
      33: [2, 304]
    }, {
      7: 424,
      8: 425,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 426,
      8: 427,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 428,
      8: 429,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VD2, $V52, {
      95: 430,
      96: $VE2
    }), o($VF2, [2, 157]), o($VF2, [2, 63], {
      70: [1, 432]
    }), o($VF2, [2, 64]), o($VG2, [2, 72], {
      113: 134,
      83: 435,
      86: 436,
      66: [1, 433],
      76: [1, 434],
      105: $V81,
      106: $V91,
      110: $Va1,
      111: $Vb1,
      112: $Vc1,
      115: $Vd1,
      135: $Ve1,
      136: $V71
    }), {
      7: 437,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o([76, 105, 106, 110, 111, 112, 115, 135, 136], $VN1, {
      41: 233,
      42: $VO1,
      73: [1, 438]
    }), o($VG2, [2, 75]), {
      34: 273,
      38: 269,
      39: $V2,
      40: $V3,
      41: 270,
      42: $VO1,
      71: 439,
      72: 271,
      75: $Vg,
      77: 440,
      78: 272,
      79: 274,
      80: 275,
      81: 276,
      82: $VX1,
      85: $VY1,
      117: $Vq,
      139: $Vu,
      154: $Vx
    }, {
      76: [1, 441],
      83: 442,
      86: 443,
      105: $V81,
      106: $V91,
      110: $Va1,
      111: $Vb1,
      112: $Vc1,
      113: 134,
      115: $Vd1,
      135: $Ve1,
      136: $V71
    }, o($VH2, [2, 69]), o($VH2, [2, 70]), o($VH2, [2, 71]), o($VI2, [2, 80]), o($VI2, [2, 81]), o($VI2, [2, 82]), o($VI2, [2, 83]), o($VI2, [2, 84]), {
      83: 444,
      105: $VK1,
      106: $VL1,
      135: $Ve1,
      136: $V71
    }, {
      84: 445,
      136: $VM1
    }, o($Vd2, $Vi1, {
      57: [1, 446]
    }), o($Vd2, $Vy1), {
      45: 284,
      46: $V5,
      47: $V6,
      49: [1, 447],
      50: 448,
      51: $V02
    }, o($VJ2, [2, 44]), {
      4: 449,
      5: 3,
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      11: 27,
      12: 28,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $V1,
      33: [1, 450],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      52: [1, 451],
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VJ2, [2, 49]), o($VN, [2, 4]), o($VK2, [2, 389], {
      160: 118,
      163: 119,
      167: 123,
      193: $VV,
      194: $VW,
      195: $VX
    }), o($VK2, [2, 390], {
      160: 118,
      163: 119,
      167: 123,
      193: $VV,
      194: $VW,
      195: $VX
    }), o($Vc2, [2, 391], {
      160: 118,
      163: 119,
      167: 123,
      193: $VV,
      195: $VX
    }), o($Vc2, [2, 392], {
      160: 118,
      163: 119,
      167: 123,
      193: $VV,
      195: $VX
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 196, 197, 198, 199, 200, 201, 202, 203, 204], [2, 393], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 197, 198, 199, 200, 201, 202, 203], [2, 394], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      204: $V41
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 198, 199, 200, 201, 202, 203], [2, 395], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      204: $V41
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 199, 200, 201, 202, 203], [2, 396], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      204: $V41
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 200, 201, 202, 203], [2, 397], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      204: $V41
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 201, 202, 203], [2, 398], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      204: $V41
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 202, 203], [2, 399], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      204: $V41
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 203], [2, 400], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      204: $V41
    }), o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 166, 183, 197, 198, 199, 200, 201, 202, 203, 204], [2, 401], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY
    }), o($Vz2, $VL2, {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($VO, [2, 373]), {
      158: [1, 452]
    }, {
      158: [1, 453]
    }, o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 158, 159, 165, 183, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204], $VA2, {
      166: [1, 454]
    }), {
      7: 455,
      8: 456,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 457,
      8: 458,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 459,
      8: 460,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vz2, $VM2, {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($VO, [2, 372]), o($Vv2, [2, 218]), o($Vv2, [2, 219]), o($VQ1, [2, 143]), o($VQ1, [2, 144]), o($VQ1, [2, 145]), o($VQ1, [2, 146]), {
      107: [1, 461]
    }, {
      7: 317,
      8: 319,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $V22,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      114: 462,
      116: 318,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      143: 320,
      144: $V32,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VN2, [2, 153], {
      160: 118,
      163: 119,
      167: 123,
      143: 463,
      76: $V22,
      144: $V32,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($VN2, [2, 154]), {
      76: $V22,
      143: 464,
      144: $V32
    }, o($VN2, [2, 241], {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 465,
      14: $V0,
      32: $Vp1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $Vy,
      159: $Vz,
      162: $VA,
      165: $VB,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($VO2, [2, 232]), o($VO2, $VP2), o($VQ1, [2, 152]), o($Vf2, [2, 60], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      7: 466,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 467,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      92: 468,
      93: $Vm,
      94: $Vn
    }, o($VQ2, $VR2, {
      98: 141,
      38: 143,
      72: 144,
      99: 145,
      34: 146,
      97: 469,
      39: $V2,
      40: $V3,
      73: $Vl1,
      75: $Vm1,
      76: $Vn1,
      117: $Vq
    }), {
      6: $VS2,
      33: $VT2
    }, o($V72, [2, 112]), {
      7: 472,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V72, [2, 113]), o($Vu2, $Vm2, {
      160: 118,
      163: 119,
      167: 123,
      76: [1, 473],
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vu2, $Vn2), o($VU2, [2, 35]), {
      6: $VM,
      35: [1, 474]
    }, {
      7: 475,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V42, $V52, {
      95: 329,
      91: [1, 476],
      96: $V62
    }), o($V92, $Va2, {
      160: 118,
      163: 119,
      167: 123,
      193: $VV
    }), o($V92, $Vb2, {
      160: 118,
      163: 119,
      167: 123,
      193: $VV
    }), {
      7: 477,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      33: $Vo1,
      37: 414,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      35: [1, 478]
    }, o($VO, [2, 96], {
      160: 118,
      163: 119,
      167: 123,
      157: $Vg2,
      159: $Vg2,
      165: $Vg2,
      183: $Vg2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, [2, 402], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      7: 479,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 480,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V61, [2, 365]), {
      7: 481,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V61, [2, 269], {
      151: [1, 482]
    }), {
      33: $Vo1,
      37: 483
    }, {
      33: $Vo1,
      34: 485,
      37: 486,
      38: 484,
      39: $V2,
      40: $V3,
      117: $Vq
    }, {
      177: 487,
      179: 356,
      180: $Ve2
    }, {
      177: 488,
      179: 356,
      180: $Ve2
    }, {
      35: [1, 489],
      178: [1, 490],
      179: 491,
      180: $Ve2
    }, o($VW2, [2, 358]), {
      7: 493,
      8: 494,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      148: 492,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VX2, [2, 163], {
      160: 118,
      163: 119,
      167: 123,
      37: 495,
      33: $Vo1,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($V61, [2, 166]), {
      7: 496,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      35: [1, 497]
    }, {
      35: [1, 498]
    }, o($Vf2, [2, 34], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($VO, [2, 94], {
      160: 118,
      163: 119,
      167: 123,
      157: $Vg2,
      159: $Vg2,
      165: $Vg2,
      183: $Vg2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($VO, [2, 371]), {
      7: 500,
      8: 499,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      35: [1, 501]
    }, {
      34: 502,
      117: $Vq
    }, {
      45: 503,
      46: $V5,
      47: $V6
    }, {
      117: [1, 505],
      125: 504,
      130: $VF1
    }, {
      45: 506,
      46: $V5,
      47: $V6
    }, {
      36: [1, 507]
    }, o($VD2, $V52, {
      95: 508,
      96: $VY2
    }), o($VF2, [2, 183]), {
      33: $Vh2,
      38: 376,
      39: $V2,
      40: $V3,
      126: 510,
      127: 374,
      129: $Vi2
    }, o($VF2, [2, 188], {
      128: [1, 511]
    }), o($VF2, [2, 190], {
      128: [1, 512]
    }), {
      38: 513,
      39: $V2,
      40: $V3
    }, o($Vf1, [2, 194], {
      36: [1, 514]
    }), o($VD2, $V52, {
      95: 515,
      96: $VZ2
    }), o($VF2, [2, 208]), {
      33: $Vj2,
      38: 383,
      39: $V2,
      40: $V3,
      129: $Vk2,
      132: 517,
      134: 381
    }, o($VF2, [2, 213], {
      128: [1, 518]
    }), o($VF2, [2, 216], {
      128: [1, 519]
    }), {
      6: [1, 521],
      7: 520,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: [1, 522],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V_2, [2, 200], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      34: 523,
      117: $Vq
    }, {
      45: 524,
      46: $V5,
      47: $V6
    }, o($Vg1, [2, 277]), {
      6: $VM,
      35: [1, 525]
    }, {
      7: 526,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o([14, 32, 39, 40, 44, 46, 47, 54, 55, 59, 60, 61, 62, 63, 64, 73, 75, 82, 85, 87, 88, 89, 93, 94, 108, 109, 117, 120, 122, 131, 139, 149, 153, 154, 157, 159, 162, 165, 176, 182, 185, 186, 187, 188, 189, 190, 191, 192], $VP2, {
      6: $V$2,
      33: $V$2,
      74: $V$2,
      96: $V$2
    }), {
      7: 527,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vo2, [2, 230]), o($Vq2, [2, 261], {
      6: $Vr2
    }), o($Vs2, [2, 257]), {
      33: $V03,
      74: [1, 528]
    }, o([6, 33, 35, 74], $VR2, {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      92: 39,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      184: 60,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      9: 155,
      147: 221,
      145: 225,
      100: 226,
      7: 333,
      8: 334,
      146: 530,
      140: 531,
      14: $V0,
      32: $Vp1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $Vy,
      159: $Vz,
      162: $VA,
      165: $VB,
      176: $VC,
      182: $VD,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($V13, [2, 258], {
      6: [1, 532]
    }), o($Vt2, [2, 263]), o($VQ2, $V52, {
      95: 399,
      142: 533,
      96: $Vp2
    }), {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      145: 396,
      147: 395,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vu2, [2, 121], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vv2, [2, 220]), o($Vg1, [2, 138]), {
      107: [1, 534],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      7: 535,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vv2, [2, 224]), o([6, 33, 137], $V52, {
      95: 536,
      96: $V23
    }), o($V33, [2, 242]), {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: $Vw2,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      138: 538,
      139: $Vu,
      145: 410,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vg1, [2, 141]), o($Vg1, [2, 142]), o($V43, [2, 362]), o($V53, [2, 368]), {
      7: 539,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 540,
      8: 541,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 542,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 543,
      8: 544,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 545,
      8: 546,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VB2, [2, 306]), o($VB2, [2, 307]), {
      34: 253,
      38: 250,
      39: $V2,
      40: $V3,
      72: 251,
      73: $Vl1,
      75: $Vm1,
      99: 252,
      117: $Vq,
      172: 547
    }, {
      33: $V63,
      157: $VP,
      158: [1, 548],
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      166: [1, 549],
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 333],
      158: [1, 550],
      166: [1, 551]
    }, {
      33: $V73,
      157: $VP,
      158: [1, 552],
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 334],
      158: [1, 553]
    }, {
      33: $V83,
      157: $VP,
      158: [1, 554],
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 349],
      158: [1, 555]
    }, {
      6: $V93,
      33: $Va3,
      119: [1, 556]
    }, o($Vb3, $VR2, {
      45: 95,
      68: 261,
      69: 262,
      71: 263,
      43: 266,
      77: 268,
      38: 269,
      41: 270,
      72: 271,
      78: 272,
      34: 273,
      79: 274,
      80: 275,
      81: 276,
      67: 559,
      39: $V2,
      40: $V3,
      42: $VO1,
      44: $V4,
      46: $V5,
      47: $V6,
      73: $VU1,
      75: $VV1,
      76: $VW1,
      82: $VX1,
      85: $VY1,
      117: $Vq,
      139: $Vu,
      154: $Vx
    }), {
      7: 560,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: [1, 561],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 562,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      33: [1, 563],
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VF2, [2, 76]), {
      84: 564,
      136: $VM1
    }, o($VI2, [2, 89]), {
      74: [1, 565],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      7: 566,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VF2, [2, 77], {
      113: 134,
      83: 435,
      86: 436,
      105: $V81,
      106: $V91,
      110: $Va1,
      111: $Vb1,
      112: $Vc1,
      115: $Vd1,
      135: $Ve1,
      136: $V71
    }), o($VF2, [2, 79], {
      113: 134,
      83: 442,
      86: 443,
      105: $V81,
      106: $V91,
      110: $Va1,
      111: $Vb1,
      112: $Vc1,
      115: $Vd1,
      135: $Ve1,
      136: $V71
    }), o($VF2, [2, 78]), {
      84: 567,
      136: $VM1
    }, o($VI2, [2, 90]), {
      84: 568,
      136: $VM1
    }, o($VI2, [2, 86]), o($Vg1, [2, 51]), o($V$1, [2, 43]), o($VJ2, [2, 45]), {
      6: $VM,
      52: [1, 569]
    }, {
      4: 570,
      5: 3,
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      11: 27,
      12: 28,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $V1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VJ2, [2, 48]), {
      7: 571,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 572,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 573,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o([1, 6, 33, 35, 52, 74, 76, 91, 96, 107, 119, 137, 144, 155, 157, 159, 165, 183], $V63, {
      160: 118,
      163: 119,
      167: 123,
      158: [1, 574],
      166: [1, 575],
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      158: [1, 576],
      166: [1, 577]
    }, o($Vc3, $V73, {
      160: 118,
      163: 119,
      167: 123,
      158: [1, 578],
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      158: [1, 579]
    }, o($Vc3, $V83, {
      160: 118,
      163: 119,
      167: 123,
      158: [1, 580],
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      158: [1, 581]
    }, o($VQ1, [2, 150]), {
      35: [1, 582]
    }, o($VN2, [2, 237], {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 583,
      14: $V0,
      32: $Vp1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $Vy,
      159: $Vz,
      162: $VA,
      165: $VB,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($VN2, [2, 239], {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      92: 161,
      9: 164,
      7: 584,
      14: $V0,
      32: $Vp1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $Vy,
      159: $Vz,
      162: $VA,
      165: $VB,
      176: $VC,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($VN2, [2, 240], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, [2, 61], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      35: [1, 585],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      5: 587,
      7: 4,
      8: 5,
      9: 6,
      10: 7,
      11: 27,
      12: 28,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $V1,
      33: $Vo1,
      34: 66,
      37: 586,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vk,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V72, [2, 108]), {
      34: 146,
      38: 143,
      39: $V2,
      40: $V3,
      72: 144,
      73: $Vl1,
      75: $Vm1,
      76: $Vn1,
      97: 588,
      98: 141,
      99: 145,
      117: $Vq
    }, o($Vd3, $Vk1, {
      97: 140,
      98: 141,
      38: 143,
      72: 144,
      99: 145,
      34: 146,
      90: 589,
      39: $V2,
      40: $V3,
      73: $Vl1,
      75: $Vm1,
      76: $Vn1,
      117: $Vq
    }), o($V72, [2, 114], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vu2, $V$2), o($VU2, [2, 36]), o($Vz2, $VL2, {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      92: 590,
      93: $Vm,
      94: $Vn
    }, o($Vz2, $VM2, {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($V61, [2, 383]), {
      35: [1, 591],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, o($Vf2, [2, 404], {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      33: $Vo1,
      37: 592,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: $Vo1,
      37: 593
    }, o($V61, [2, 270]), {
      33: $Vo1,
      37: 594
    }, {
      33: $Vo1,
      37: 595
    }, o($Ve3, [2, 274]), {
      35: [1, 596],
      178: [1, 597],
      179: 491,
      180: $Ve2
    }, {
      35: [1, 598],
      178: [1, 599],
      179: 491,
      180: $Ve2
    }, o($V61, [2, 356]), {
      33: $Vo1,
      37: 600
    }, o($VW2, [2, 359]), {
      33: $Vo1,
      37: 601,
      96: [1, 602]
    }, o($Vf3, [2, 264], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf3, [2, 265]), o($V61, [2, 164]), o($VX2, [2, 167], {
      160: 118,
      163: 119,
      167: 123,
      37: 603,
      33: $Vo1,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($V61, [2, 276]), o($V61, [2, 33]), {
      33: $Vo1,
      37: 604
    }, {
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, o($Vf1, [2, 92]), o($Vf1, [2, 170]), o($Vf1, [2, 171], {
      123: [1, 605]
    }), {
      36: [1, 606]
    }, {
      33: $Vh2,
      38: 376,
      39: $V2,
      40: $V3,
      126: 607,
      127: 374,
      129: $Vi2
    }, o($Vf1, [2, 173], {
      123: [1, 608]
    }), {
      45: 609,
      46: $V5,
      47: $V6
    }, {
      6: $Vg3,
      33: $Vh3,
      119: [1, 610]
    }, o($Vb3, $VR2, {
      38: 376,
      127: 613,
      39: $V2,
      40: $V3,
      129: $Vi2
    }), o($VQ2, $V52, {
      95: 614,
      96: $VY2
    }), {
      38: 615,
      39: $V2,
      40: $V3
    }, {
      38: 616,
      39: $V2,
      40: $V3
    }, {
      36: [2, 193]
    }, {
      45: 617,
      46: $V5,
      47: $V6
    }, {
      6: $Vi3,
      33: $Vj3,
      119: [1, 618]
    }, o($Vb3, $VR2, {
      38: 383,
      134: 621,
      39: $V2,
      40: $V3,
      129: $Vk2
    }), o($VQ2, $V52, {
      95: 622,
      96: $VZ2
    }), {
      38: 623,
      39: $V2,
      40: $V3,
      129: [1, 624]
    }, {
      38: 625,
      39: $V2,
      40: $V3
    }, o($V_2, [2, 197], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      7: 626,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 627,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      35: [1, 628]
    }, o($Vf1, [2, 202], {
      123: [1, 629]
    }), {
      155: [1, 630]
    }, {
      74: [1, 631],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      74: [1, 632],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, o($Vo2, [2, 231]), {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: $VG1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      140: 402,
      141: 633,
      145: 225,
      146: 222,
      147: 221,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vs2, [2, 252]), o($V13, [2, 259], {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      92: 39,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      184: 60,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      9: 155,
      100: 226,
      7: 333,
      8: 334,
      147: 395,
      145: 396,
      14: $V0,
      32: $Vp1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $Vy,
      159: $Vz,
      162: $VA,
      165: $VB,
      176: $VC,
      182: $VD,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      96: $VJ1,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      140: 402,
      145: 225,
      146: 634,
      147: 221,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      33: $V03,
      35: [1, 635]
    }, o($Vg1, [2, 139]), {
      35: [1, 636],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      6: $Vk3,
      33: $Vl3,
      137: [1, 637]
    }, o([6, 33, 35, 137], $VR2, {
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      13: 23,
      15: 25,
      16: 26,
      65: 29,
      58: 30,
      79: 31,
      102: 32,
      56: 33,
      103: 34,
      81: 35,
      80: 36,
      104: 37,
      92: 39,
      101: 48,
      181: 49,
      160: 51,
      156: 52,
      161: 53,
      163: 54,
      164: 55,
      184: 60,
      99: 65,
      34: 66,
      43: 67,
      53: 69,
      38: 85,
      72: 86,
      167: 92,
      45: 95,
      9: 155,
      100: 226,
      7: 333,
      8: 334,
      145: 640,
      14: $V0,
      32: $Vp1,
      39: $V2,
      40: $V3,
      44: $V4,
      46: $V5,
      47: $V6,
      54: $V7,
      55: $V8,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      93: $Vm,
      94: $Vn,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      157: $Vy,
      159: $Vz,
      162: $VA,
      165: $VB,
      176: $VC,
      182: $VD,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }), o($VQ2, $V52, {
      95: 641,
      96: $V23
    }), o($Vz2, [2, 284], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      33: $Vm3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 280]
    }, o($Vz2, [2, 287], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      33: $Vn3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 282]
    }, {
      33: $Vo3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 303]
    }, o($VB2, [2, 313]), {
      7: 642,
      8: 643,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 644,
      8: 645,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 646,
      8: 647,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 648,
      8: 649,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 650,
      8: 651,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 652,
      8: 653,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 654,
      8: 655,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 656,
      8: 657,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($Vo2, [2, 155]), {
      34: 273,
      38: 269,
      39: $V2,
      40: $V3,
      41: 270,
      42: $VO1,
      43: 266,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      67: 658,
      68: 261,
      69: 262,
      71: 263,
      72: 271,
      73: $VU1,
      75: $VV1,
      76: $VW1,
      77: 268,
      78: 272,
      79: 274,
      80: 275,
      81: 276,
      82: $VX1,
      85: $VY1,
      117: $Vq,
      139: $Vu,
      154: $Vx
    }, o($Vd3, $VT1, {
      45: 95,
      67: 260,
      68: 261,
      69: 262,
      71: 263,
      43: 266,
      77: 268,
      38: 269,
      41: 270,
      72: 271,
      78: 272,
      34: 273,
      79: 274,
      80: 275,
      81: 276,
      118: 659,
      39: $V2,
      40: $V3,
      42: $VO1,
      44: $V4,
      46: $V5,
      47: $V6,
      73: $VU1,
      75: $VV1,
      76: $VW1,
      82: $VX1,
      85: $VY1,
      117: $Vq,
      139: $Vu,
      154: $Vx
    }), o($VF2, [2, 158]), o($VF2, [2, 65], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      7: 660,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VF2, [2, 67], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      7: 661,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($VI2, [2, 87]), o($VG2, [2, 73]), {
      74: [1, 662],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, o($VI2, [2, 88]), o($VI2, [2, 85]), o($VJ2, [2, 46]), {
      6: $VM,
      35: [1, 663]
    }, o($Vz2, $Vm3, {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vz2, $Vn3, {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vz2, $Vo3, {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      7: 664,
      8: 665,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 666,
      8: 667,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 668,
      8: 669,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 670,
      8: 671,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 672,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 673,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 674,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 675,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      107: [1, 676]
    }, o($VN2, [2, 236], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($VN2, [2, 238], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($V61, [2, 62]), o($Vg1, [2, 98]), o($VO, [2, 100]), o($V72, [2, 109]), o($VQ2, $V52, {
      95: 677,
      96: $V62
    }), {
      33: $Vo1,
      37: 586
    }, o($V61, [2, 403]), o($V43, [2, 363]), o($V61, [2, 271]), o($Ve3, [2, 272]), o($Ve3, [2, 273]), o($V61, [2, 352]), {
      33: $Vo1,
      37: 678
    }, o($V61, [2, 353]), {
      33: $Vo1,
      37: 679
    }, {
      35: [1, 680]
    }, o($VW2, [2, 360], {
      6: [1, 681]
    }), {
      7: 682,
      8: 683,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V61, [2, 168]), o($V53, [2, 369]), {
      34: 684,
      117: $Vq
    }, {
      45: 685,
      46: $V5,
      47: $V6
    }, o($VD2, $V52, {
      95: 686,
      96: $VY2
    }), {
      34: 687,
      117: $Vq
    }, o($Vf1, [2, 175], {
      123: [1, 688]
    }), {
      36: [1, 689]
    }, {
      38: 376,
      39: $V2,
      40: $V3,
      127: 690,
      129: $Vi2
    }, {
      33: $Vh2,
      38: 376,
      39: $V2,
      40: $V3,
      126: 691,
      127: 374,
      129: $Vi2
    }, o($VF2, [2, 184]), {
      6: $Vg3,
      33: $Vh3,
      35: [1, 692]
    }, o($VF2, [2, 189]), o($VF2, [2, 191]), o($Vf1, [2, 204], {
      123: [1, 693]
    }), o($Vf1, [2, 195], {
      36: [1, 694]
    }), {
      38: 383,
      39: $V2,
      40: $V3,
      129: $Vk2,
      134: 695
    }, {
      33: $Vj2,
      38: 383,
      39: $V2,
      40: $V3,
      129: $Vk2,
      132: 696,
      134: 381
    }, o($VF2, [2, 209]), {
      6: $Vi3,
      33: $Vj3,
      35: [1, 697]
    }, o($VF2, [2, 214]), o($VF2, [2, 215]), o($VF2, [2, 217]), o($V_2, [2, 198], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      35: [1, 698],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, o($Vf1, [2, 201]), {
      34: 699,
      117: $Vq
    }, o($Vg1, [2, 278]), o($Vg1, [2, 234]), o($Vg1, [2, 235]), o($VQ2, $V52, {
      95: 399,
      142: 700,
      96: $Vp2
    }), o($Vs2, [2, 253]), o($Vs2, [2, 254]), {
      107: [1, 701]
    }, o($Vv2, [2, 225]), {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      145: 702,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 333,
      8: 334,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      33: $Vw2,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      76: $VI1,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      100: 226,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      138: 703,
      139: $Vu,
      145: 410,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V33, [2, 243]), {
      6: $Vk3,
      33: $Vl3,
      35: [1, 704]
    }, {
      33: $Vp3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      166: [1, 705],
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 335],
      166: [1, 706]
    }, {
      33: $Vq3,
      157: $VP,
      158: [1, 707],
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 339],
      158: [1, 708]
    }, {
      33: $Vr3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      166: [1, 709],
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 336],
      166: [1, 710]
    }, {
      33: $Vs3,
      157: $VP,
      158: [1, 711],
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 340],
      158: [1, 712]
    }, {
      33: $Vt3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 337]
    }, {
      33: $Vu3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 338]
    }, {
      33: $Vv3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 350]
    }, {
      33: $Vw3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 351]
    }, o($VF2, [2, 159]), o($VQ2, $V52, {
      95: 713,
      96: $VE2
    }), {
      35: [1, 714],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      35: [1, 715],
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VV2,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, o($VG2, [2, 74]), {
      52: [1, 716]
    }, o($Vx3, $Vp3, {
      160: 118,
      163: 119,
      167: 123,
      166: [1, 717],
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      166: [1, 718]
    }, o($Vc3, $Vq3, {
      160: 118,
      163: 119,
      167: 123,
      158: [1, 719],
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      158: [1, 720]
    }, o($Vx3, $Vr3, {
      160: 118,
      163: 119,
      167: 123,
      166: [1, 721],
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      166: [1, 722]
    }, o($Vc3, $Vs3, {
      160: 118,
      163: 119,
      167: 123,
      158: [1, 723],
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), {
      158: [1, 724]
    }, o($Vf2, $Vt3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $Vu3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $Vv3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $Vw3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($VQ1, [2, 151]), {
      6: $VS2,
      33: $VT2,
      35: [1, 725]
    }, {
      35: [1, 726]
    }, {
      35: [1, 727]
    }, o($V61, [2, 357]), o($VW2, [2, 361]), o($Vf3, [2, 266], {
      160: 118,
      163: 119,
      167: 123,
      157: $VP,
      159: $VQ,
      165: $VR,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf3, [2, 267]), o($Vf1, [2, 172]), o($Vf1, [2, 179], {
      123: [1, 728]
    }), {
      6: $Vg3,
      33: $Vh3,
      119: [1, 729]
    }, o($Vf1, [2, 174]), {
      34: 730,
      117: $Vq
    }, {
      45: 731,
      46: $V5,
      47: $V6
    }, o($VF2, [2, 185]), o($VQ2, $V52, {
      95: 732,
      96: $VY2
    }), o($VF2, [2, 186]), {
      34: 733,
      117: $Vq
    }, {
      45: 734,
      46: $V5,
      47: $V6
    }, o($VF2, [2, 210]), o($VQ2, $V52, {
      95: 735,
      96: $VZ2
    }), o($VF2, [2, 211]), o($Vf1, [2, 199]), o($Vf1, [2, 203]), {
      33: $V03,
      35: [1, 736]
    }, o($Vg1, [2, 140]), o($V33, [2, 244]), o($VQ2, $V52, {
      95: 737,
      96: $V23
    }), o($V33, [2, 245]), {
      7: 738,
      8: 739,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 740,
      8: 741,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 742,
      8: 743,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 744,
      8: 745,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 746,
      8: 747,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 748,
      8: 749,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 750,
      8: 751,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 752,
      8: 753,
      9: 155,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      29: 20,
      30: 21,
      31: 22,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vl,
      92: 39,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $VD,
      184: 60,
      185: $VE,
      186: $VF,
      187: $VG,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      6: $V93,
      33: $Va3,
      35: [1, 754]
    }, o($VF2, [2, 66]), o($VF2, [2, 68]), o($VJ2, [2, 47]), {
      7: 755,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 756,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 757,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 758,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 759,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 760,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 761,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, {
      7: 762,
      9: 164,
      13: 23,
      14: $V0,
      15: 25,
      16: 26,
      17: 8,
      18: 9,
      19: 10,
      20: 11,
      21: 12,
      22: 13,
      23: 14,
      24: 15,
      25: 16,
      26: 17,
      27: 18,
      28: 19,
      32: $Vp1,
      34: 66,
      38: 85,
      39: $V2,
      40: $V3,
      43: 67,
      44: $V4,
      45: 95,
      46: $V5,
      47: $V6,
      53: 69,
      54: $V7,
      55: $V8,
      56: 33,
      58: 30,
      59: $V9,
      60: $Va,
      61: $Vb,
      62: $Vc,
      63: $Vd,
      64: $Ve,
      65: 29,
      72: 86,
      73: $Vf,
      75: $Vg,
      79: 31,
      80: 36,
      81: 35,
      82: $Vh,
      85: $Vi,
      87: $Vj,
      88: $Vq1,
      89: $Vr1,
      92: 161,
      93: $Vm,
      94: $Vn,
      99: 65,
      101: 48,
      102: 32,
      103: 34,
      104: 37,
      108: $Vo,
      109: $Vp,
      117: $Vq,
      120: $Vr,
      122: $Vs,
      131: $Vt,
      139: $Vu,
      149: $Vv,
      153: $Vw,
      154: $Vx,
      156: 52,
      157: $Vy,
      159: $Vz,
      160: 51,
      161: 53,
      162: $VA,
      163: 54,
      164: 55,
      165: $VB,
      167: 92,
      176: $VC,
      181: 49,
      182: $Vs1,
      185: $Vt1,
      186: $Vu1,
      187: $Vv1,
      188: $VH,
      189: $VI,
      190: $VJ,
      191: $VK,
      192: $VL
    }, o($V72, [2, 110]), o($V61, [2, 354]), o($V61, [2, 355]), {
      34: 763,
      117: $Vq
    }, {
      36: [1, 764]
    }, o($Vf1, [2, 176]), o($Vf1, [2, 177], {
      123: [1, 765]
    }), {
      6: $Vg3,
      33: $Vh3,
      35: [1, 766]
    }, o($Vf1, [2, 205]), o($Vf1, [2, 206], {
      123: [1, 767]
    }), {
      6: $Vi3,
      33: $Vj3,
      35: [1, 768]
    }, o($Vs2, [2, 255]), {
      6: $Vk3,
      33: $Vl3,
      35: [1, 769]
    }, {
      33: $Vy3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 341]
    }, {
      33: $Vz3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 343]
    }, {
      33: $VA3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 345]
    }, {
      33: $VB3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 347]
    }, {
      33: $VC3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 342]
    }, {
      33: $VD3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 344]
    }, {
      33: $VE3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 346]
    }, {
      33: $VF3,
      157: $VP,
      159: $VQ,
      160: 118,
      163: 119,
      165: $VR,
      167: 123,
      183: $VS,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }, {
      33: [2, 348]
    }, o($VF2, [2, 160]), o($Vf2, $Vy3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $Vz3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $VA3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $VB3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $VC3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $VD3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $VE3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf2, $VF3, {
      160: 118,
      163: 119,
      167: 123,
      189: $VT,
      190: $VU,
      193: $VV,
      194: $VW,
      195: $VX,
      196: $VY,
      197: $VZ,
      198: $V_,
      199: $V$,
      200: $V01,
      201: $V11,
      202: $V21,
      203: $V31,
      204: $V41
    }), o($Vf1, [2, 180]), {
      45: 770,
      46: $V5,
      47: $V6
    }, {
      34: 771,
      117: $Vq
    }, o($VF2, [2, 187]), {
      34: 772,
      117: $Vq
    }, o($VF2, [2, 212]), o($V33, [2, 246]), o($Vf1, [2, 181], {
      123: [1, 773]
    }), o($Vf1, [2, 178]), o($Vf1, [2, 207]), {
      34: 774,
      117: $Vq
    }, o($Vf1, [2, 182])],
    defaultActions: {
      255: [2, 304],
      513: [2, 193],
      541: [2, 280],
      544: [2, 282],
      546: [2, 303],
      651: [2, 337],
      653: [2, 338],
      655: [2, 350],
      657: [2, 351],
      739: [2, 341],
      741: [2, 343],
      743: [2, 345],
      745: [2, 347],
      747: [2, 342],
      749: [2, 344],
      751: [2, 346],
      753: [2, 348]
    },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self = this,
        stack = [0],
        tstack = [],
        vstack = [null],
        lstack = [],
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer = Object.create(this.lexer);
      var sharedState = {
        yy: {}
      };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      _token_stack: var lex = function () {
        var token;
        token = lexer.lex() || EOF;
        if (typeof token !== 'number') {
          token = self.symbols_[token] || token;
        }
        return token;
      };
      var symbol,
        preErrorSymbol,
        state,
        action,
        a,
        r,
        yyval = {},
        p,
        len,
        newState,
        expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == 'undefined') {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
          var errStr = '';
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push('\'' + this.terminals_[p] + '\'');
            }
          }
          if (lexer.showPosition) {
            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
          } else {
            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
          }
          this.parseError(errStr, {
            text: lexer.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer.yylineno,
            loc: yyloc,
            expected: expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer.yyleng;
              yytext = lexer.yytext;
              yylineno = lexer.yylineno;
              yyloc = lexer.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
            if (typeof r !== 'undefined') {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
}();
if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = parser;
  exports.Parser = parser.Parser;
  exports.parse = function () {
    return parser.parse.apply(parser, arguments);
  };
  exports.main = function () {};
  if (typeof module !== 'undefined' && require.main === module) {
    exports.main(process.argv.slice(1));
  }
}
}),
/* --- node_modules/coffeescript/lib/coffeescript/helpers.js --- */
"node_modules/coffeescript/lib/coffeescript/helpers.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  // This file contains the common helper functions that we'd like to share among
  // the **Lexer**, **Rewriter**, and the **Nodes**. Merge objects, flatten
  // arrays, count characters, that sort of thing.

  // Peek at the beginning of a given string to see if it matches a sequence.
  var UNICODE_CODE_POINT_ESCAPE,
    attachCommentsToNode,
    buildLocationData,
    buildLocationHash,
    buildTokenDataDictionary,
    extend,
    flatten,
    isBoolean,
    isNumber,
    isString,
    ref,
    repeat,
    syntaxErrorToString,
    unicodeCodePointToUnicodeEscapes,
    indexOf = [].indexOf;
  exports.starts = function (string, literal, start) {
    return literal === string.substr(start, literal.length);
  };

  // Peek at the end of a given string to see if it matches a sequence.
  exports.ends = function (string, literal, back) {
    var len;
    len = literal.length;
    return literal === string.substr(string.length - len - (back || 0), len);
  };

  // Repeat a string `n` times.
  exports.repeat = repeat = function (str, n) {
    var res;
    // Use clever algorithm to have O(log(n)) string concatenation operations.
    res = '';
    while (n > 0) {
      if (n & 1) {
        res += str;
      }
      n >>>= 1;
      str += str;
    }
    return res;
  };

  // Trim out all falsy values from an array.
  exports.compact = function (array) {
    var i, item, len1, results;
    results = [];
    for (i = 0, len1 = array.length; i < len1; i++) {
      item = array[i];
      if (item) {
        results.push(item);
      }
    }
    return results;
  };

  // Count the number of occurrences of a string in a string.
  exports.count = function (string, substr) {
    var num, pos;
    num = pos = 0;
    if (!substr.length) {
      return 1 / 0;
    }
    while (pos = 1 + string.indexOf(substr, pos)) {
      num++;
    }
    return num;
  };

  // Merge objects, returning a fresh copy with attributes from both sides.
  // Used every time `Base#compile` is called, to allow properties in the
  // options hash to propagate down the tree without polluting other branches.
  exports.merge = function (options, overrides) {
    return extend(extend({}, options), overrides);
  };

  // Extend a source object with the properties of another object (shallow copy).
  extend = exports.extend = function (object, properties) {
    var key, val;
    for (key in properties) {
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  // Return a flattened version of an array.
  // Handy for getting a list of `children` from the nodes.
  exports.flatten = flatten = function (array) {
    var element, flattened, i, len1;
    flattened = [];
    for (i = 0, len1 = array.length; i < len1; i++) {
      element = array[i];
      if ('[object Array]' === Object.prototype.toString.call(element)) {
        flattened = flattened.concat(flatten(element));
      } else {
        flattened.push(element);
      }
    }
    return flattened;
  };

  // Delete a key from an object, returning the value. Useful when a node is
  // looking for a particular method in an options hash.
  exports.del = function (obj, key) {
    var val;
    val = obj[key];
    delete obj[key];
    return val;
  };

  // Typical Array::some
  exports.some = (ref = Array.prototype.some) != null ? ref : function (fn) {
    var e, i, len1, ref1;
    ref1 = this;
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      e = ref1[i];
      if (fn(e)) {
        return true;
      }
    }
    return false;
  };

  // Helper function for extracting code from Literate CoffeeScript by stripping
  // out all non-code blocks, producing a string of CoffeeScript code that can
  // be compiled normally.
  exports.invertLiterate = function (code) {
    var blankLine, i, indented, insideComment, len1, line, listItemStart, out, ref1;
    out = [];
    blankLine = /^\s*$/;
    indented = /^[\t ]/;
    listItemStart = /^(?:\t?| {0,3})(?:[\*\-\+]|[0-9]{1,9}\.)[ \t]/; // Up to one tab, or up to three spaces, or neither;
    // followed by `*`, `-` or `+`;
    // or by an integer up to 9 digits long, followed by a period;
    // followed by a space or a tab.
    insideComment = false;
    ref1 = code.split('\n');
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      line = ref1[i];
      if (blankLine.test(line)) {
        insideComment = false;
        out.push(line);
      } else if (insideComment || listItemStart.test(line)) {
        insideComment = true;
        out.push(`# ${line}`);
      } else if (!insideComment && indented.test(line)) {
        out.push(line);
      } else {
        insideComment = true;
        out.push(`# ${line}`);
      }
    }
    return out.join('\n');
  };

  // Merge two jison-style location data objects together.
  // If `last` is not provided, this will simply return `first`.
  buildLocationData = function (first, last) {
    if (!last) {
      return first;
    } else {
      return {
        first_line: first.first_line,
        first_column: first.first_column,
        last_line: last.last_line,
        last_column: last.last_column,
        last_line_exclusive: last.last_line_exclusive,
        last_column_exclusive: last.last_column_exclusive,
        range: [first.range[0], last.range[1]]
      };
    }
  };

  // Build a list of all comments attached to tokens.
  exports.extractAllCommentTokens = function (tokens) {
    var allCommentsObj, comment, commentKey, i, j, k, key, len1, len2, len3, ref1, results, sortedKeys, token;
    allCommentsObj = {};
    for (i = 0, len1 = tokens.length; i < len1; i++) {
      token = tokens[i];
      if (token.comments) {
        ref1 = token.comments;
        for (j = 0, len2 = ref1.length; j < len2; j++) {
          comment = ref1[j];
          commentKey = comment.locationData.range[0];
          allCommentsObj[commentKey] = comment;
        }
      }
    }
    sortedKeys = Object.keys(allCommentsObj).sort(function (a, b) {
      return a - b;
    });
    results = [];
    for (k = 0, len3 = sortedKeys.length; k < len3; k++) {
      key = sortedKeys[k];
      results.push(allCommentsObj[key]);
    }
    return results;
  };

  // Get a lookup hash for a token based on its location data.
  // Multiple tokens might have the same location hash, but using exclusive
  // location data distinguishes e.g. zero-length generated tokens from
  // actual source tokens.
  buildLocationHash = function (loc) {
    return `${loc.range[0]}-${loc.range[1]}`;
  };

  // Build a dictionary of extra token properties organized by tokens locations
  // used as lookup hashes.
  exports.buildTokenDataDictionary = buildTokenDataDictionary = function (tokens) {
    var base1, i, len1, token, tokenData, tokenHash;
    tokenData = {};
    for (i = 0, len1 = tokens.length; i < len1; i++) {
      token = tokens[i];
      if (!token.comments) {
        continue;
      }
      tokenHash = buildLocationHash(token[2]);
      // Multiple tokens might have the same location hash, such as the generated
      // `JS` tokens added at the start or end of the token stream to hold
      // comments that start or end a file.
      if (tokenData[tokenHash] == null) {
        tokenData[tokenHash] = {};
      }
      if (token.comments) {
        // `comments` is always an array.
        // For overlapping tokens, that is tokens with the same location data
        // and therefore matching `tokenHash`es, merge the comments from both/all
        // tokens together into one array, even if there are duplicate comments;
        // they will get sorted out later.
        ((base1 = tokenData[tokenHash]).comments != null ? base1.comments : base1.comments = []).push(...token.comments);
      }
    }
    return tokenData;
  };

  // This returns a function which takes an object as a parameter, and if that
  // object is an AST node, updates that object's locationData.
  // The object is returned either way.
  exports.addDataToNode = function (parserState, firstLocationData, firstValue, lastLocationData, lastValue, forceUpdateLocation = true) {
    return function (obj) {
      var locationData, objHash, ref1, ref2, ref3;
      // Add location data.
      locationData = buildLocationData((ref1 = firstValue != null ? firstValue.locationData : void 0) != null ? ref1 : firstLocationData, (ref2 = lastValue != null ? lastValue.locationData : void 0) != null ? ref2 : lastLocationData);
      if ((obj != null ? obj.updateLocationDataIfMissing : void 0) != null && firstLocationData != null) {
        obj.updateLocationDataIfMissing(locationData, forceUpdateLocation);
      } else {
        obj.locationData = locationData;
      }
      // Add comments, building the dictionary of token data if it hasnt been
      // built yet.
      if (parserState.tokenData == null) {
        parserState.tokenData = buildTokenDataDictionary(parserState.parser.tokens);
      }
      if (obj.locationData != null) {
        objHash = buildLocationHash(obj.locationData);
        if (((ref3 = parserState.tokenData[objHash]) != null ? ref3.comments : void 0) != null) {
          attachCommentsToNode(parserState.tokenData[objHash].comments, obj);
        }
      }
      return obj;
    };
  };
  exports.attachCommentsToNode = attachCommentsToNode = function (comments, node) {
    if (comments == null || comments.length === 0) {
      return;
    }
    if (node.comments == null) {
      node.comments = [];
    }
    return node.comments.push(...comments);
  };

  // Convert jison location data to a string.
  // `obj` can be a token, or a locationData.
  exports.locationDataToString = function (obj) {
    var locationData;
    if ("2" in obj && "first_line" in obj[2]) {
      locationData = obj[2];
    } else if ("first_line" in obj) {
      locationData = obj;
    }
    if (locationData) {
      return `${locationData.first_line + 1}:${locationData.first_column + 1}-` + `${locationData.last_line + 1}:${locationData.last_column + 1}`;
    } else {
      return "No location data";
    }
  };

  // Generate a unique anonymous file name so we can distinguish source map cache
  // entries for any number of anonymous scripts.
  exports.anonymousFileName = function () {
    var n;
    n = 0;
    return function () {
      return `<anonymous-${n++}>`;
    };
  }();

  // A `.coffee.md` compatible version of `basename`, that returns the file sans-extension.
  exports.baseFileName = function (file, stripExt = false, useWinPathSep = false) {
    var parts, pathSep;
    pathSep = useWinPathSep ? /\\|\// : /\//;
    parts = file.split(pathSep);
    file = parts[parts.length - 1];
    if (!(stripExt && file.indexOf('.') >= 0)) {
      return file;
    }
    parts = file.split('.');
    parts.pop();
    if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {
      parts.pop();
    }
    return parts.join('.');
  };

  // Determine if a filename represents a CoffeeScript file.
  exports.isCoffee = function (file) {
    return /\.((lit)?coffee|coffee\.md)$/.test(file);
  };

  // Determine if a filename represents a Literate CoffeeScript file.
  exports.isLiterate = function (file) {
    return /\.(litcoffee|coffee\.md)$/.test(file);
  };

  // Throws a SyntaxError from a given location.
  // The error's `toString` will return an error message following the "standard"
  // format `<filename>:<line>:<col>: <message>` plus the line with the error and a
  // marker showing where the error is.
  exports.throwSyntaxError = function (message, location) {
    var error;
    error = new SyntaxError(message);
    error.location = location;
    error.toString = syntaxErrorToString;
    // Instead of showing the compiler's stacktrace, show our custom error message
    // (this is useful when the error bubbles up in Node.js applications that
    // compile CoffeeScript for example).
    error.stack = error.toString();
    throw error;
  };

  // Update a compiler SyntaxError with source code information if it didn't have
  // it already.
  exports.updateSyntaxError = function (error, code, filename) {
    // Avoid screwing up the `stack` property of other errors (i.e. possible bugs).
    if (error.toString === syntaxErrorToString) {
      error.code || (error.code = code);
      error.filename || (error.filename = filename);
      error.stack = error.toString();
    }
    return error;
  };
  syntaxErrorToString = function () {
    var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref1, ref2, ref3, ref4, start;
    if (!(this.code && this.location)) {
      return Error.prototype.toString.call(this);
    }
    ({
      first_line,
      first_column,
      last_line,
      last_column
    } = this.location);
    if (last_line == null) {
      last_line = first_line;
    }
    if (last_column == null) {
      last_column = first_column;
    }
    if ((ref1 = this.filename) != null ? ref1.startsWith('<anonymous') : void 0) {
      filename = '[stdin]';
    } else {
      filename = this.filename || '[stdin]';
    }
    codeLine = this.code.split('\n')[first_line];
    start = first_column;
    // Show only the first line on multi-line errors.
    end = first_line === last_line ? last_column + 1 : codeLine.length;
    marker = codeLine.slice(0, start).replace(/[^\s]/g, ' ') + repeat('^', end - start);
    // Check to see if we're running on a color-enabled TTY.
    if (typeof process !== "undefined" && process !== null) {
      colorsEnabled = ((ref2 = process.stdout) != null ? ref2.isTTY : void 0) && !((ref3 = process.env) != null ? ref3.NODE_DISABLE_COLORS : void 0);
    }
    if ((ref4 = this.colorful) != null ? ref4 : colorsEnabled) {
      colorize = function (str) {
        return `\x1B[1;31m${str}\x1B[0m`;
      };
      codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
      marker = colorize(marker);
    }
    return `${filename}:${first_line + 1}:${first_column + 1}: error: ${this.message}
${codeLine}
${marker}`;
  };
  exports.nameWhitespaceCharacter = function (string) {
    switch (string) {
      case ' ':
        return 'space';
      case '\n':
        return 'newline';
      case '\r':
        return 'carriage return';
      case '\t':
        return 'tab';
      default:
        return string;
    }
  };
  exports.parseNumber = function (string) {
    var base;
    if (string == null) {
      return 0 / 0;
    }
    base = function () {
      switch (string.charAt(1)) {
        case 'b':
          return 2;
        case 'o':
          return 8;
        case 'x':
          return 16;
        default:
          return null;
      }
    }();
    if (base != null) {
      return parseInt(string.slice(2).replace(/_/g, ''), base);
    } else {
      return parseFloat(string.replace(/_/g, ''));
    }
  };
  exports.isFunction = function (obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  };
  exports.isNumber = isNumber = function (obj) {
    return Object.prototype.toString.call(obj) === '[object Number]';
  };
  exports.isString = isString = function (obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
  };
  exports.isBoolean = isBoolean = function (obj) {
    return obj === true || obj === false || Object.prototype.toString.call(obj) === '[object Boolean]';
  };
  exports.isPlainObject = function (obj) {
    return typeof obj === 'object' && !!obj && !Array.isArray(obj) && !isNumber(obj) && !isString(obj) && !isBoolean(obj);
  };
  unicodeCodePointToUnicodeEscapes = function (codePoint) {
    var high, low, toUnicodeEscape;
    toUnicodeEscape = function (val) {
      var str;
      str = val.toString(16);
      return `\\u${repeat('0', 4 - str.length)}${str}`;
    };
    if (codePoint < 0x10000) {
      return toUnicodeEscape(codePoint);
    }
    // surrogate pair
    high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;
    low = (codePoint - 0x10000) % 0x400 + 0xDC00;
    return `${toUnicodeEscape(high)}${toUnicodeEscape(low)}`;
  };

  // Replace `\u{...}` with `\uxxxx[\uxxxx]` in regexes without `u` flag
  exports.replaceUnicodeCodePointEscapes = function (str, {
    flags,
    error,
    delimiter = ''
  } = {}) {
    var shouldReplace;
    shouldReplace = flags != null && indexOf.call(flags, 'u') < 0;
    return str.replace(UNICODE_CODE_POINT_ESCAPE, function (match, escapedBackslash, codePointHex, offset) {
      var codePointDecimal;
      if (escapedBackslash) {
        return escapedBackslash;
      }
      codePointDecimal = parseInt(codePointHex, 16);
      if (codePointDecimal > 0x10ffff) {
        error("unicode code point escapes greater than \\u{10ffff} are not allowed", {
          offset: offset + delimiter.length,
          length: codePointHex.length + 4
        });
      }
      if (!shouldReplace) {
        return match;
      }
      return unicodeCodePointToUnicodeEscapes(codePointDecimal);
    });
  };
  UNICODE_CODE_POINT_ESCAPE = /(\\\\)|\\u\{([\da-fA-F]+)\}/g; // Make sure the escape isnt escaped.
}).call(void 0);
}),
/* --- node_modules/coffeescript/lib/coffeescript/sourcemap.js --- */
"node_modules/coffeescript/lib/coffeescript/sourcemap.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  // Source maps allow JavaScript runtimes to match running JavaScript back to
  // the original source code that corresponds to it. This can be minified
  // JavaScript, but in our case, we're concerned with mapping pretty-printed
  // JavaScript back to CoffeeScript.

  // In order to produce maps, we must keep track of positions (line number, column number)
  // that originated every node in the syntax tree, and be able to generate a
  // [map file](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit)
  //  which is a compact, VLQ-encoded representation of the JSON serialization
  // of this information  to write out alongside the generated JavaScript.

  // LineMap
  // -------

  // A **LineMap** object keeps track of information about original line and column
  // positions for a single line of output JavaScript code.
  // **SourceMaps** are implemented in terms of **LineMaps**.
  var LineMap, SourceMap;
  LineMap = class LineMap {
    constructor(line1) {
      this.line = line1;
      this.columns = [];
    }
    add(column, [sourceLine, sourceColumn], options = {}) {
      if (this.columns[column] && options.noReplace) {
        return;
      }
      return this.columns[column] = {
        line: this.line,
        column,
        sourceLine,
        sourceColumn
      };
    }
    sourceLocation(column) {
      var mapping;
      while (!((mapping = this.columns[column]) || column <= 0)) {
        column--;
      }
      return mapping && [mapping.sourceLine, mapping.sourceColumn];
    }
  };
  SourceMap = function () {
    var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;

    // SourceMap
    // ---------

    // Maps locations in a single generated JavaScript file back to locations in
    // the original CoffeeScript source file.

    // This is intentionally agnostic towards how a source map might be represented on
    // disk. Once the compiler is ready to produce a "v3"-style source map, we can walk
    // through the arrays of line and column buffer to produce it.
    class SourceMap {
      constructor() {
        this.lines = [];
      }

      // Adds a mapping to this SourceMap. `sourceLocation` and `generatedLocation`
      // are both `[line, column]` arrays. If `options.noReplace` is true, then if there
      // is already a mapping for the specified `line` and `column`, this will have no
      // effect.
      add(sourceLocation, generatedLocation, options = {}) {
        var base, column, line, lineMap;
        [line, column] = generatedLocation;
        lineMap = (base = this.lines)[line] || (base[line] = new LineMap(line));
        return lineMap.add(column, sourceLocation, options);
      }

      // Look up the original position of a given `line` and `column` in the generated
      // code.
      sourceLocation([line, column]) {
        var lineMap;
        while (!((lineMap = this.lines[line]) || line <= 0)) {
          line--;
        }
        return lineMap && lineMap.sourceLocation(column);
      }
      static registerCompiled(filename, source, sourcemap) {
        if (sourcemap != null) {
          return SourceMap.sourceMaps[filename] = sourcemap;
        }
      }
      static getSourceMap(filename) {
        return SourceMap.sourceMaps[filename];
      }

      // V3 SourceMap Generation
      // -----------------------

      // Builds up a V3 source map, returning the generated JSON as a string.
      // `options.sourceRoot` may be used to specify the sourceRoot written to the source
      // map.  Also, `options.sourceFiles` and `options.generatedFile` may be passed to
      // set "sources" and "file", respectively.
      generate(options = {}, code = null) {
        var buffer, i, j, lastColumn, lastSourceColumn, lastSourceLine, len, len1, lineMap, lineNumber, mapping, needComma, ref, ref1, sources, v3, writingline;
        writingline = 0;
        lastColumn = 0;
        lastSourceLine = 0;
        lastSourceColumn = 0;
        needComma = false;
        buffer = "";
        ref = this.lines;
        for (lineNumber = i = 0, len = ref.length; i < len; lineNumber = ++i) {
          lineMap = ref[lineNumber];
          if (lineMap) {
            ref1 = lineMap.columns;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              mapping = ref1[j];
              if (!mapping) {
                continue;
              }
              while (writingline < mapping.line) {
                lastColumn = 0;
                needComma = false;
                buffer += ";";
                writingline++;
              }
              // Write a comma if we've already written a segment on this line.
              if (needComma) {
                buffer += ",";
                needComma = false;
              }
              // Write the next segment. Segments can be 1, 4, or 5 values.  If just one, then it
              // is a generated column which doesn't match anything in the source code.

              // The starting column in the generated source, relative to any previous recorded
              // column for the current line:
              buffer += this.encodeVlq(mapping.column - lastColumn);
              lastColumn = mapping.column;
              // The index into the list of sources:
              buffer += this.encodeVlq(0);
              // The starting line in the original source, relative to the previous source line.
              buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
              lastSourceLine = mapping.sourceLine;
              // The starting column in the original source, relative to the previous column.
              buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
              lastSourceColumn = mapping.sourceColumn;
              needComma = true;
            }
          }
        }
        // Produce the canonical JSON object format for a "v3" source map.
        sources = options.sourceFiles ? options.sourceFiles : options.filename ? [options.filename] : ['<anonymous>'];
        v3 = {
          version: 3,
          file: options.generatedFile || '',
          sourceRoot: options.sourceRoot || '',
          sources: sources,
          names: [],
          mappings: buffer
        };
        if (options.sourceMap || options.inlineMap) {
          v3.sourcesContent = [code];
        }
        return v3;
      }
      encodeVlq(value) {
        var answer, nextChunk, signBit, valueToEncode;
        answer = '';
        // Least significant bit represents the sign.
        signBit = value < 0 ? 1 : 0;
        // The next bits are the actual value.
        valueToEncode = (Math.abs(value) << 1) + signBit;
        // Make sure we encode at least one character, even if valueToEncode is 0.
        while (valueToEncode || !answer) {
          nextChunk = valueToEncode & VLQ_VALUE_MASK;
          valueToEncode = valueToEncode >> VLQ_SHIFT;
          if (valueToEncode) {
            nextChunk |= VLQ_CONTINUATION_BIT;
          }
          answer += this.encodeBase64(nextChunk);
        }
        return answer;
      }
      encodeBase64(value) {
        return BASE64_CHARS[value] || function () {
          throw new Error(`Cannot Base64 encode value: ${value}`);
        }();
      }
    }
    ;

    // Caching
    // -------

    // A static source maps cache `filename`: `map`. These are used for transforming
    // stack traces and are currently set in `CoffeeScript.compile` for all files
    // compiled with the source maps option.
    SourceMap.sourceMaps = Object.create(null);

    // Base64 VLQ Encoding
    // -------------------

    // Note that SourceMap VLQ encoding is "backwards".  MIDI-style VLQ encoding puts
    // the most-significant-bit (MSB) from the original value into the MSB of the VLQ
    // encoded value (see [Wikipedia](https://en.wikipedia.org/wiki/File:Uintvar_coding.svg)).
    // SourceMap VLQ does things the other way around, with the least significat four
    // bits of the original value encoded into the first byte of the VLQ encoded value.
    VLQ_SHIFT = 5;
    VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT; // 0010 0000

    VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1; // 0001 1111

    // Regular Base64 Encoding
    // -----------------------
    BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    return SourceMap;
  }.call(this);

  // Our API for source maps is just the `SourceMap` class.
  module.exports = SourceMap;
}).call(void 0);
}),
/* --- node_modules/coffeescript/package.json --- */
"node_modules/coffeescript/package.json": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
module.exports = {
  "name": "coffeescript",
  "description": "Unfancy JavaScript",
  "keywords": ["javascript", "language", "coffeescript", "compiler"],
  "author": "Jeremy Ashkenas",
  "version": "2.7.0",
  "license": "MIT",
  "engines": {
    "node": ">=6"
  },
  "directories": {
    "lib": "./lib/coffeescript"
  },
  "main": "./lib/coffeescript/index",
  "module": "./lib/coffeescript-browser-compiler-modern/coffeescript.js",
  "browser": "./lib/coffeescript-browser-compiler-legacy/coffeescript.js",
  "bin": {
    "coffee": "./bin/coffee",
    "cake": "./bin/cake"
  },
  "files": ["bin", "lib", "register.js", "repl.js"],
  "scripts": {
    "test": "node ./bin/cake test",
    "test-harmony": "node --harmony ./bin/cake test"
  },
  "homepage": "https://coffeescript.org",
  "bugs": "https://github.com/jashkenas/coffeescript/issues",
  "repository": {
    "type": "git",
    "url": "git://github.com/jashkenas/coffeescript.git"
  },
  "devDependencies": {
    "@babel/core": "~7.17.8",
    "@babel/preset-env": "~7.16.11",
    "babel-preset-minify": "~0.5.1",
    "codemirror": "~5.65.2",
    "docco": "~0.9.1",
    "highlight.js": "~11.5.0",
    "jison": "~0.4.18",
    "markdown-it": "~12.3.2",
    "puppeteer": "~13.5.2",
    "underscore": "~1.13.2",
    "webpack": "~5.71.0"
  }
};
}),
/* --- node_modules/coffeescript/lib/coffeescript/nodes.js --- */
"node_modules/coffeescript/lib/coffeescript/nodes.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  // `nodes.coffee` contains all of the node classes for the syntax tree. Most
  // nodes are created as the result of actions in the [grammar](grammar.html),
  // but some are created by other nodes as a method of code generation. To convert
  // the syntax tree into a string of JavaScript code, call `compile()` on the root.
  var Access,
    Arr,
    Assign,
    AwaitReturn,
    Base,
    Block,
    BooleanLiteral,
    Call,
    Catch,
    Class,
    ClassProperty,
    ClassPrototypeProperty,
    Code,
    CodeFragment,
    ComputedPropertyName,
    DefaultLiteral,
    Directive,
    DynamicImport,
    DynamicImportCall,
    Elision,
    EmptyInterpolation,
    ExecutableClassBody,
    Existence,
    Expansion,
    ExportAllDeclaration,
    ExportDeclaration,
    ExportDefaultDeclaration,
    ExportNamedDeclaration,
    ExportSpecifier,
    ExportSpecifierList,
    Extends,
    For,
    FuncDirectiveReturn,
    FuncGlyph,
    HEREGEX_OMIT,
    HereComment,
    HoistTarget,
    IdentifierLiteral,
    If,
    ImportClause,
    ImportDeclaration,
    ImportDefaultSpecifier,
    ImportNamespaceSpecifier,
    ImportSpecifier,
    ImportSpecifierList,
    In,
    Index,
    InfinityLiteral,
    Interpolation,
    JSXAttribute,
    JSXAttributes,
    JSXElement,
    JSXEmptyExpression,
    JSXExpressionContainer,
    JSXIdentifier,
    JSXNamespacedName,
    JSXTag,
    JSXText,
    JS_FORBIDDEN,
    LEADING_BLANK_LINE,
    LEVEL_ACCESS,
    LEVEL_COND,
    LEVEL_LIST,
    LEVEL_OP,
    LEVEL_PAREN,
    LEVEL_TOP,
    LineComment,
    Literal,
    MetaProperty,
    ModuleDeclaration,
    ModuleSpecifier,
    ModuleSpecifierList,
    NEGATE,
    NO,
    NaNLiteral,
    NullLiteral,
    NumberLiteral,
    Obj,
    ObjectProperty,
    Op,
    Param,
    Parens,
    PassthroughLiteral,
    PropertyName,
    Range,
    RegexLiteral,
    RegexWithInterpolations,
    Return,
    Root,
    SIMPLENUM,
    SIMPLE_STRING_OMIT,
    STRING_OMIT,
    Scope,
    Sequence,
    Slice,
    Splat,
    StatementLiteral,
    StringLiteral,
    StringWithInterpolations,
    Super,
    SuperCall,
    Switch,
    SwitchCase,
    SwitchWhen,
    TAB,
    THIS,
    TRAILING_BLANK_LINE,
    TaggedTemplateCall,
    TemplateElement,
    ThisLiteral,
    Throw,
    Try,
    UTILITIES,
    UndefinedLiteral,
    Value,
    While,
    YES,
    YieldReturn,
    addDataToNode,
    astAsBlockIfNeeded,
    attachCommentsToNode,
    compact,
    del,
    emptyExpressionLocationData,
    ends,
    extend,
    extractSameLineLocationDataFirst,
    extractSameLineLocationDataLast,
    flatten,
    fragmentsToText,
    greater,
    hasLineComments,
    indentInitial,
    isAstLocGreater,
    isFunction,
    isLiteralArguments,
    isLiteralThis,
    isLocationDataEndGreater,
    isLocationDataStartGreater,
    isNumber,
    isPlainObject,
    isUnassignable,
    jisonLocationDataToAstLocationData,
    lesser,
    locationDataToString,
    makeDelimitedLiteral,
    merge,
    mergeAstLocationData,
    mergeLocationData,
    moveComments,
    multident,
    parseNumber,
    replaceUnicodeCodePointEscapes,
    shouldCacheOrIsAssignable,
    sniffDirectives,
    some,
    starts,
    throwSyntaxError,
    unfoldSoak,
    unshiftAfterComments,
    utility,
    zeroWidthLocationDataFromEndLocation,
    indexOf = [].indexOf,
    splice = [].splice,
    slice1 = [].slice;
  Error.stackTraceLimit = 2e308;
  ({
    Scope
  } = _kame_require_("node_modules/coffeescript/lib/coffeescript/scope.js"));
  ({
    isUnassignable,
    JS_FORBIDDEN
  } = _kame_require_("node_modules/coffeescript/lib/coffeescript/lexer.js"));

  // Import the helpers we plan to use.
  ({
    compact,
    flatten,
    extend,
    merge,
    del,
    starts,
    ends,
    some,
    addDataToNode,
    attachCommentsToNode,
    locationDataToString,
    throwSyntaxError,
    replaceUnicodeCodePointEscapes,
    isFunction,
    isPlainObject,
    isNumber,
    parseNumber
  } = _kame_require_("node_modules/coffeescript/lib/coffeescript/helpers.js"));

  // Functions required by parser.
  exports.extend = extend;
  exports.addDataToNode = addDataToNode;

  // Constant functions for nodes that dont need customization.
  YES = function () {
    return true;
  };
  NO = function () {
    return false;
  };
  THIS = function () {
    return this;
  };
  NEGATE = function () {
    this.negated = !this.negated;
    return this;
  };

  //### CodeFragment

  // The various nodes defined below all compile to a collection of **CodeFragment** objects.
  // A CodeFragments is a block of generated code, and the location in the source file where the code
  // came from. CodeFragments can be assembled together into working code just by catting together
  // all the CodeFragments' `code` snippets, in order.
  exports.CodeFragment = CodeFragment = class CodeFragment {
    constructor(parent, code) {
      var ref1;
      this.code = `${code}`;
      this.type = (parent != null ? (ref1 = parent.constructor) != null ? ref1.name : void 0 : void 0) || 'unknown';
      this.locationData = parent != null ? parent.locationData : void 0;
      this.comments = parent != null ? parent.comments : void 0;
    }
    toString() {
      // This is only intended for debugging.
      return `${this.code}${this.locationData ? ": " + locationDataToString(this.locationData) : ''}`;
    }
  };

  // Convert an array of CodeFragments into a string.
  fragmentsToText = function (fragments) {
    var fragment;
    return function () {
      var j, len1, results1;
      results1 = [];
      for (j = 0, len1 = fragments.length; j < len1; j++) {
        fragment = fragments[j];
        results1.push(fragment.code);
      }
      return results1;
    }().join('');
  };

  //### Base

  // The **Base** is the abstract base class for all nodes in the syntax tree.
  // Each subclass implements the `compileNode` method, which performs the
  // code generation for that node. To compile a node to JavaScript,
  // call `compile` on it, which wraps `compileNode` in some generic extra smarts,
  // to know when the generated code needs to be wrapped up in a closure.
  // An options hash is passed and cloned throughout, containing information about
  // the environment from higher in the tree (such as if a returned value is
  // being requested by the surrounding function), information about the current
  // scope, and indentation level.
  exports.Base = Base = function () {
    class Base {
      compile(o, lvl) {
        return fragmentsToText(this.compileToFragments(o, lvl));
      }

      // Occasionally a node is compiled multiple times, for example to get the name
      // of a variable to add to scope tracking. When we know that a premature
      // compilation wont result in comments being output, set those comments aside
      // so that theyre preserved for a later `compile` call that will result in
      // the comments being included in the output.
      compileWithoutComments(o, lvl, method = 'compile') {
        var fragments, unwrapped;
        if (this.comments) {
          this.ignoreTheseCommentsTemporarily = this.comments;
          delete this.comments;
        }
        unwrapped = this.unwrapAll();
        if (unwrapped.comments) {
          unwrapped.ignoreTheseCommentsTemporarily = unwrapped.comments;
          delete unwrapped.comments;
        }
        fragments = this[method](o, lvl);
        if (this.ignoreTheseCommentsTemporarily) {
          this.comments = this.ignoreTheseCommentsTemporarily;
          delete this.ignoreTheseCommentsTemporarily;
        }
        if (unwrapped.ignoreTheseCommentsTemporarily) {
          unwrapped.comments = unwrapped.ignoreTheseCommentsTemporarily;
          delete unwrapped.ignoreTheseCommentsTemporarily;
        }
        return fragments;
      }
      compileNodeWithoutComments(o, lvl) {
        return this.compileWithoutComments(o, lvl, 'compileNode');
      }

      // Common logic for determining whether to wrap this node in a closure before
      // compiling it, or to compile directly. We need to wrap if this node is a
      // *statement*, and it's not a *pureStatement*, and we're not at
      // the top level of a block (which would be unnecessary), and we haven't
      // already been asked to return the result (because statements know how to
      // return results).
      compileToFragments(o, lvl) {
        var fragments, node;
        o = extend({}, o);
        if (lvl) {
          o.level = lvl;
        }
        node = this.unfoldSoak(o) || this;
        node.tab = o.indent;
        fragments = o.level === LEVEL_TOP || !node.isStatement(o) ? node.compileNode(o) : node.compileClosure(o);
        this.compileCommentFragments(o, node, fragments);
        return fragments;
      }
      compileToFragmentsWithoutComments(o, lvl) {
        return this.compileWithoutComments(o, lvl, 'compileToFragments');
      }

      // Statements converted into expressions via closure-wrapping share a scope
      // object with their parent closure, to preserve the expected lexical scope.
      compileClosure(o) {
        var args, argumentsNode, func, meth, parts, ref1, ref2;
        this.checkForPureStatementInExpression();
        o.sharedScope = true;
        func = new Code([], Block.wrap([this]));
        args = [];
        if (this.contains(function (node) {
          return node instanceof SuperCall;
        })) {
          func.bound = true;
        } else if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) {
          args = [new ThisLiteral()];
          if (argumentsNode) {
            meth = 'apply';
            args.push(new IdentifierLiteral('arguments'));
          } else {
            meth = 'call';
          }
          func = new Value(func, [new Access(new PropertyName(meth))]);
        }
        parts = new Call(func, args).compileNode(o);
        switch (false) {
          case !(func.isGenerator || ((ref1 = func.base) != null ? ref1.isGenerator : void 0)):
            parts.unshift(this.makeCode("(yield* "));
            parts.push(this.makeCode(")"));
            break;
          case !(func.isAsync || ((ref2 = func.base) != null ? ref2.isAsync : void 0)):
            parts.unshift(this.makeCode("(await "));
            parts.push(this.makeCode(")"));
        }
        return parts;
      }
      compileCommentFragments(o, node, fragments) {
        var base1, base2, comment, commentFragment, j, len1, ref1, unshiftCommentFragment;
        if (!node.comments) {
          return fragments;
        }
        // This is where comments, that are attached to nodes as a `comments`
        // property, become `CodeFragment`s. Inline block comments, e.g.
        // `/* */`-delimited comments that are interspersed within code on a line,
        // are added to the current `fragments` stream. All other fragments are
        // attached as properties to the nearest preceding or following fragment,
        // to remain stowaways until they get properly output in `compileComments`
        // later on.
        unshiftCommentFragment = function (commentFragment) {
          var precedingFragment;
          if (commentFragment.unshift) {
            // Find the first non-comment fragment and insert `commentFragment`
            // before it.
            return unshiftAfterComments(fragments, commentFragment);
          } else {
            if (fragments.length !== 0) {
              precedingFragment = fragments[fragments.length - 1];
              if (commentFragment.newLine && precedingFragment.code !== '' && !/\n\s*$/.test(precedingFragment.code)) {
                commentFragment.code = `\n${commentFragment.code}`;
              }
            }
            return fragments.push(commentFragment);
          }
        };
        ref1 = node.comments;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          comment = ref1[j];
          if (!(indexOf.call(this.compiledComments, comment) < 0)) {
            continue;
          }
          this.compiledComments.push(comment); // Dont output this comment twice.
          // For block/here comments, denoted by `###`, that are inline comments
          // like `1 + ### comment ### 2`, create fragments and insert them into
          // the fragments array.
          // Otherwise attach comment fragments to their closest fragment for now,
          // so they can be inserted into the output later after all the newlines
          // have been added.
          if (comment.here) {
            // Block comment, delimited by `###`.
            commentFragment = new HereComment(comment).compileNode(o); // Line comment, delimited by `#`.
          } else {
            commentFragment = new LineComment(comment).compileNode(o);
          }
          if (commentFragment.isHereComment && !commentFragment.newLine || node.includeCommentFragments()) {
            // Inline block comments, like `1 + /* comment */ 2`, or a node whose
            // `compileToFragments` method has logic for outputting comments.
            unshiftCommentFragment(commentFragment);
          } else {
            if (fragments.length === 0) {
              fragments.push(this.makeCode(''));
            }
            if (commentFragment.unshift) {
              if ((base1 = fragments[0]).precedingComments == null) {
                base1.precedingComments = [];
              }
              fragments[0].precedingComments.push(commentFragment);
            } else {
              if ((base2 = fragments[fragments.length - 1]).followingComments == null) {
                base2.followingComments = [];
              }
              fragments[fragments.length - 1].followingComments.push(commentFragment);
            }
          }
        }
        return fragments;
      }

      // If the code generation wishes to use the result of a complex expression
      // in multiple places, ensure that the expression is only ever evaluated once,
      // by assigning it to a temporary variable. Pass a level to precompile.

      // If `level` is passed, then returns `[val, ref]`, where `val` is the compiled value, and `ref`
      // is the compiled reference. If `level` is not passed, this returns `[val, ref]` where
      // the two values are raw nodes which have not been compiled.
      cache(o, level, shouldCache) {
        var complex, ref, sub;
        complex = shouldCache != null ? shouldCache(this) : this.shouldCache();
        if (complex) {
          ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
          sub = new Assign(ref, this);
          if (level) {
            return [sub.compileToFragments(o, level), [this.makeCode(ref.value)]];
          } else {
            return [sub, ref];
          }
        } else {
          ref = level ? this.compileToFragments(o, level) : this;
          return [ref, ref];
        }
      }

      // Occasionally it may be useful to make an expression behave as if it was 'hoisted', whereby the
      // result of the expression is available before its location in the source, but the expression's
      // variable scope corresponds to the source position. This is used extensively to deal with executable
      // class bodies in classes.

      // Calling this method mutates the node, proxying the `compileNode` and `compileToFragments`
      // methods to store their result for later replacing the `target` node, which is returned by the
      // call.
      hoist() {
        var compileNode, compileToFragments, target;
        this.hoisted = true;
        target = new HoistTarget(this);
        compileNode = this.compileNode;
        compileToFragments = this.compileToFragments;
        this.compileNode = function (o) {
          return target.update(compileNode, o);
        };
        this.compileToFragments = function (o) {
          return target.update(compileToFragments, o);
        };
        return target;
      }
      cacheToCodeFragments(cacheValues) {
        return [fragmentsToText(cacheValues[0]), fragmentsToText(cacheValues[1])];
      }

      // Construct a node that returns the current nodes result.
      // Note that this is overridden for smarter behavior for
      // many statement nodes (e.g. `If`, `For`).
      makeReturn(results, mark) {
        var node;
        if (mark) {
          // Mark this node as implicitly returned, so that it can be part of the
          // node metadata returned in the AST.
          this.canBeReturned = true;
          return;
        }
        node = this.unwrapAll();
        if (results) {
          return new Call(new Literal(`${results}.push`), [node]);
        } else {
          return new Return(node);
        }
      }

      // Does this node, or any of its children, contain a node of a certain kind?
      // Recursively traverses down the *children* nodes and returns the first one
      // that verifies `pred`. Otherwise return undefined. `contains` does not cross
      // scope boundaries.
      contains(pred) {
        var node;
        node = void 0;
        this.traverseChildren(false, function (n) {
          if (pred(n)) {
            node = n;
            return false;
          }
        });
        return node;
      }

      // Pull out the last node of a node list.
      lastNode(list) {
        if (list.length === 0) {
          return null;
        } else {
          return list[list.length - 1];
        }
      }

      // Debugging representation of the node, for inspecting the parse tree.
      // This is what `coffee --nodes` prints out.
      toString(idt = '', name = this.constructor.name) {
        var tree;
        tree = '\n' + idt + name;
        if (this.soak) {
          tree += '?';
        }
        this.eachChild(function (node) {
          return tree += node.toString(idt + TAB);
        });
        return tree;
      }
      checkForPureStatementInExpression() {
        var jumpNode;
        if (jumpNode = this.jumps()) {
          return jumpNode.error('cannot use a pure statement in an expression');
        }
      }

      // Plain JavaScript object representation of the node, that can be serialized
      // as JSON. This is what the `ast` option in the Node API returns.
      // We try to follow the [Babel AST spec](https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md)
      // as closely as possible, for improved interoperability with other tools.
      // **WARNING: DO NOT OVERRIDE THIS METHOD IN CHILD CLASSES.**
      // Only override the component `ast*` methods as needed.
      ast(o, level) {
        var astNode;
        // Merge `level` into `o` and perform other universal checks.
        o = this.astInitialize(o, level);
        // Create serializable representation of this node.
        astNode = this.astNode(o);
        // Mark AST nodes that correspond to expressions that (implicitly) return.
        // We cant do this as part of `astNode` because we need to assemble child
        // nodes first before marking the parent being returned.
        if (this.astNode != null && this.canBeReturned) {
          Object.assign(astNode, {
            returns: true
          });
        }
        return astNode;
      }
      astInitialize(o, level) {
        o = Object.assign({}, o);
        if (level != null) {
          o.level = level;
        }
        if (o.level > LEVEL_TOP) {
          this.checkForPureStatementInExpression();
        }
        if (this.isStatement(o) && o.level !== LEVEL_TOP && o.scope != null) {
          // `@makeReturn` must be called before `astProperties`, because the latter may call
          // `.ast()` for child nodes and those nodes would need the return logic from `makeReturn`
          // already executed by then.
          this.makeReturn(null, true);
        }
        return o;
      }
      astNode(o) {
        // Every abstract syntax tree node object has four categories of properties:
        // - type, stored in the `type` field and a string like `NumberLiteral`.
        // - location data, stored in the `loc`, `start`, `end` and `range` fields.
        // - properties specific to this node, like `parsedValue`.
        // - properties that are themselves child nodes, like `body`.
        // These fields are all intermixed in the Babel spec; `type` and `start` and
        // `parsedValue` are all top level fields in the AST node object. We have
        // separate methods for returning each category, that we merge together here.
        return Object.assign({}, {
          type: this.astType(o)
        }, this.astProperties(o), this.astLocationData());
      }

      // By default, a node class has no specific properties.
      astProperties() {
        return {};
      }

      // By default, a node classs AST `type` is its class name.
      astType() {
        return this.constructor.name;
      }

      // The AST location data is a rearranged version of our Jison location data,
      // mutated into the structure that the Babel spec uses.
      astLocationData() {
        return jisonLocationDataToAstLocationData(this.locationData);
      }

      // Determines whether an AST node needs an `ExpressionStatement` wrapper.
      // Typically matches our `isStatement()` logic but this allows overriding.
      isStatementAst(o) {
        return this.isStatement(o);
      }

      // Passes each child to a function, breaking when the function returns `false`.
      eachChild(func) {
        var attr, child, j, k, len1, len2, ref1, ref2;
        if (!this.children) {
          return this;
        }
        ref1 = this.children;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          attr = ref1[j];
          if (this[attr]) {
            ref2 = flatten([this[attr]]);
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              child = ref2[k];
              if (func(child) === false) {
                return this;
              }
            }
          }
        }
        return this;
      }
      traverseChildren(crossScope, func) {
        return this.eachChild(function (child) {
          var recur;
          recur = func(child);
          if (recur !== false) {
            return child.traverseChildren(crossScope, func);
          }
        });
      }

      // `replaceInContext` will traverse children looking for a node for which `match` returns
      // true. Once found, the matching node will be replaced by the result of calling `replacement`.
      replaceInContext(match, replacement) {
        var attr, child, children, i, j, k, len1, len2, ref1, ref2;
        if (!this.children) {
          return false;
        }
        ref1 = this.children;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          attr = ref1[j];
          if (children = this[attr]) {
            if (Array.isArray(children)) {
              for (i = k = 0, len2 = children.length; k < len2; i = ++k) {
                child = children[i];
                if (match(child)) {
                  splice.apply(children, [i, i - i + 1].concat(ref2 = replacement(child, this))), ref2;
                  return true;
                } else {
                  if (child.replaceInContext(match, replacement)) {
                    return true;
                  }
                }
              }
            } else if (match(children)) {
              this[attr] = replacement(children, this);
              return true;
            } else {
              if (children.replaceInContext(match, replacement)) {
                return true;
              }
            }
          }
        }
      }
      invert() {
        return new Op('!', this);
      }
      unwrapAll() {
        var node;
        node = this;
        while (node !== (node = node.unwrap())) {
          continue;
        }
        return node;
      }

      // For this node and all descendents, set the location data to `locationData`
      // if the location data is not already set.
      updateLocationDataIfMissing(locationData, force) {
        if (force) {
          this.forceUpdateLocation = true;
        }
        if (this.locationData && !this.forceUpdateLocation) {
          return this;
        }
        delete this.forceUpdateLocation;
        this.locationData = locationData;
        return this.eachChild(function (child) {
          return child.updateLocationDataIfMissing(locationData);
        });
      }

      // Add location data from another node
      withLocationDataFrom({
        locationData
      }) {
        return this.updateLocationDataIfMissing(locationData);
      }

      // Add location data and comments from another node
      withLocationDataAndCommentsFrom(node) {
        var comments;
        this.withLocationDataFrom(node);
        ({
          comments
        } = node);
        if (comments != null ? comments.length : void 0) {
          this.comments = comments;
        }
        return this;
      }

      // Throw a SyntaxError associated with this nodes location.
      error(message) {
        return throwSyntaxError(message, this.locationData);
      }
      makeCode(code) {
        return new CodeFragment(this, code);
      }
      wrapInParentheses(fragments) {
        return [this.makeCode('('), ...fragments, this.makeCode(')')];
      }
      wrapInBraces(fragments) {
        return [this.makeCode('{'), ...fragments, this.makeCode('}')];
      }

      // `fragmentsList` is an array of arrays of fragments. Each array in fragmentsList will be
      // concatenated together, with `joinStr` added in between each, to produce a final flat array
      // of fragments.
      joinFragmentArrays(fragmentsList, joinStr) {
        var answer, fragments, i, j, len1;
        answer = [];
        for (i = j = 0, len1 = fragmentsList.length; j < len1; i = ++j) {
          fragments = fragmentsList[i];
          if (i) {
            answer.push(this.makeCode(joinStr));
          }
          answer = answer.concat(fragments);
        }
        return answer;
      }
    }
    ;

    // Default implementations of the common node properties and methods. Nodes
    // will override these with custom logic, if needed.

    // `children` are the properties to recurse into when tree walking. The
    // `children` list *is* the structure of the AST. The `parent` pointer, and
    // the pointer to the `children` are how you can traverse the tree.
    Base.prototype.children = [];

    // `isStatement` has to do with everything is an expression. A few things
    // cant be expressions, such as `break`. Things that `isStatement` returns
    // `true` for are things that cant be used as expressions. There are some
    // error messages that come from `nodes.coffee` due to statements ending up
    // in expression position.
    Base.prototype.isStatement = NO;

    // Track comments that have been compiled into fragments, to avoid outputting
    // them twice.
    Base.prototype.compiledComments = [];

    // `includeCommentFragments` lets `compileCommentFragments` know whether this node
    // has special awareness of how to handle comments within its output.
    Base.prototype.includeCommentFragments = NO;

    // `jumps` tells you if an expression, or an internal part of an expression,
    // has a flow control construct (like `break`, `continue`, or `return`)
    // that jumps out of the normal flow of control and cant be used as a value.
    // (Note that `throw` is not considered a flow control construct.)
    // This is important because flow control in the middle of an expression
    // makes no sense; we have to disallow it.
    Base.prototype.jumps = NO;

    // If `node.shouldCache() is false`, it is safe to use `node` more than once.
    // Otherwise you need to store the value of `node` in a variable and output
    // that variable several times instead. Kind of like this: `5` need not be
    // cached. `returnFive()`, however, could have side effects as a result of
    // evaluating it more than once, and therefore we need to cache it. The
    // parameter is named `shouldCache` rather than `mustCache` because there are
    // also cases where we might not need to cache but where we want to, for
    // example a long expression that may well be idempotent but we want to cache
    // for brevity.
    Base.prototype.shouldCache = YES;
    Base.prototype.isChainable = NO;
    Base.prototype.isAssignable = NO;
    Base.prototype.isNumber = NO;
    Base.prototype.unwrap = THIS;
    Base.prototype.unfoldSoak = NO;

    // Is this node used to assign a certain variable?
    Base.prototype.assigns = NO;
    return Base;
  }.call(this);

  //### HoistTarget

  // A **HoistTargetNode** represents the output location in the node tree for a hoisted node.
  // See Base#hoist.
  exports.HoistTarget = HoistTarget = class HoistTarget extends Base {
    // Expands hoisted fragments in the given array
    static expand(fragments) {
      var fragment, i, j, ref1;
      for (i = j = fragments.length - 1; j >= 0; i = j += -1) {
        fragment = fragments[i];
        if (fragment.fragments) {
          splice.apply(fragments, [i, i - i + 1].concat(ref1 = this.expand(fragment.fragments))), ref1;
        }
      }
      return fragments;
    }
    constructor(source1) {
      super();
      this.source = source1;
      // Holds presentational options to apply when the source node is compiled.
      this.options = {};
      // Placeholder fragments to be replaced by the source nodes compilation.
      this.targetFragments = {
        fragments: []
      };
    }
    isStatement(o) {
      return this.source.isStatement(o);
    }

    // Update the target fragments with the result of compiling the source.
    // Calls the given compile function with the node and options (overriden with the target
    // presentational options).
    update(compile, o) {
      return this.targetFragments.fragments = compile.call(this.source, merge(o, this.options));
    }

    // Copies the target indent and level, and returns the placeholder fragments
    compileToFragments(o, level) {
      this.options.indent = o.indent;
      this.options.level = level != null ? level : o.level;
      return [this.targetFragments];
    }
    compileNode(o) {
      return this.compileToFragments(o);
    }
    compileClosure(o) {
      return this.compileToFragments(o);
    }
  };

  //### Root

  // The root node of the node tree
  exports.Root = Root = function () {
    class Root extends Base {
      constructor(body1) {
        super();
        this.body = body1;
        this.isAsync = new Code([], this.body).isAsync;
      }

      // Wrap everything in a safety closure, unless requested not to. It would be
      // better not to generate them in the first place, but for now, clean up
      // obvious double-parentheses.
      compileNode(o) {
        var fragments, functionKeyword;
        o.indent = o.bare ? '' : TAB;
        o.level = LEVEL_TOP;
        o.compiling = true;
        this.initializeScope(o);
        fragments = this.body.compileRoot(o);
        if (o.bare) {
          return fragments;
        }
        functionKeyword = `${this.isAsync ? 'async ' : ''}function`;
        return [].concat(this.makeCode(`(${functionKeyword}() {\n`), fragments, this.makeCode("\n}).call(this);\n"));
      }
      initializeScope(o) {
        var j, len1, name, ref1, ref2, results1;
        o.scope = new Scope(null, this.body, null, (ref1 = o.referencedVars) != null ? ref1 : []);
        ref2 = o.locals || [];
        results1 = [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          name = ref2[j];
          // Mark given local variables in the root scope as parameters so they dont
          // end up being declared on the root block.
          results1.push(o.scope.parameter(name));
        }
        return results1;
      }
      commentsAst() {
        var comment, commentToken, j, len1, ref1, results1;
        if (this.allComments == null) {
          this.allComments = function () {
            var j, len1, ref1, ref2, results1;
            ref2 = (ref1 = this.allCommentTokens) != null ? ref1 : [];
            results1 = [];
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              commentToken = ref2[j];
              if (!commentToken.heregex) {
                if (commentToken.here) {
                  results1.push(new HereComment(commentToken));
                } else {
                  results1.push(new LineComment(commentToken));
                }
              }
            }
            return results1;
          }.call(this);
        }
        ref1 = this.allComments;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          comment = ref1[j];
          results1.push(comment.ast());
        }
        return results1;
      }
      astNode(o) {
        o.level = LEVEL_TOP;
        this.initializeScope(o);
        return super.astNode(o);
      }
      astType() {
        return 'File';
      }
      astProperties(o) {
        this.body.isRootBlock = true;
        return {
          program: Object.assign(this.body.ast(o), this.astLocationData()),
          comments: this.commentsAst()
        };
      }
    }
    ;
    Root.prototype.children = ['body'];
    return Root;
  }.call(this);

  //### Block

  // The block is the list of expressions that forms the body of an
  // indented block of code -- the implementation of a function, a clause in an
  // `if`, `switch`, or `try`, and so on...
  exports.Block = Block = function () {
    class Block extends Base {
      constructor(nodes) {
        super();
        this.expressions = compact(flatten(nodes || []));
      }

      // Tack an expression on to the end of this expression list.
      push(node) {
        this.expressions.push(node);
        return this;
      }

      // Remove and return the last expression of this expression list.
      pop() {
        return this.expressions.pop();
      }

      // Add an expression at the beginning of this expression list.
      unshift(node) {
        this.expressions.unshift(node);
        return this;
      }

      // If this Block consists of just a single node, unwrap it by pulling
      // it back out.
      unwrap() {
        if (this.expressions.length === 1) {
          return this.expressions[0];
        } else {
          return this;
        }
      }

      // Is this an empty block of code?
      isEmpty() {
        return !this.expressions.length;
      }
      isStatement(o) {
        var exp, j, len1, ref1;
        ref1 = this.expressions;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          exp = ref1[j];
          if (exp.isStatement(o)) {
            return true;
          }
        }
        return false;
      }
      jumps(o) {
        var exp, j, jumpNode, len1, ref1;
        ref1 = this.expressions;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          exp = ref1[j];
          if (jumpNode = exp.jumps(o)) {
            return jumpNode;
          }
        }
      }

      // A Block node does not return its entire body, rather it
      // ensures that the final expression is returned.
      makeReturn(results, mark) {
        var expr, expressions, last, lastExp, len, penult, ref1, ref2;
        len = this.expressions.length;
        ref1 = this.expressions, [lastExp] = slice1.call(ref1, -1);
        lastExp = (lastExp != null ? lastExp.unwrap() : void 0) || false;
        // We also need to check that were not returning a JSX tag if theres an
        // adjacent one at the same level; JSX doesnt allow that.
        if (lastExp && lastExp instanceof Parens && lastExp.body.expressions.length > 1) {
          ({
            body: {
              expressions
            }
          } = lastExp);
          [penult, last] = slice1.call(expressions, -2);
          penult = penult.unwrap();
          last = last.unwrap();
          if (penult instanceof JSXElement && last instanceof JSXElement) {
            expressions[expressions.length - 1].error('Adjacent JSX elements must be wrapped in an enclosing tag');
          }
        }
        if (mark) {
          if ((ref2 = this.expressions[len - 1]) != null) {
            ref2.makeReturn(results, mark);
          }
          return;
        }
        while (len--) {
          expr = this.expressions[len];
          this.expressions[len] = expr.makeReturn(results);
          if (expr instanceof Return && !expr.expression) {
            this.expressions.splice(len, 1);
          }
          break;
        }
        return this;
      }
      compile(o, lvl) {
        if (!o.scope) {
          return new Root(this).withLocationDataFrom(this).compile(o, lvl);
        }
        return super.compile(o, lvl);
      }

      // Compile all expressions within the **Block** body. If we need to return
      // the result, and its an expression, simply return it. If its a statement,
      // ask the statement to do so.
      compileNode(o) {
        var answer, compiledNodes, fragments, index, j, lastFragment, len1, node, ref1, top;
        this.tab = o.indent;
        top = o.level === LEVEL_TOP;
        compiledNodes = [];
        ref1 = this.expressions;
        for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
          node = ref1[index];
          if (node.hoisted) {
            // This is a hoisted expression.
            // We want to compile this and ignore the result.
            node.compileToFragments(o);
            continue;
          }
          node = node.unfoldSoak(o) || node;
          if (node instanceof Block) {
            // This is a nested block. We dont do anything special here like
            // enclose it in a new scope; we just compile the statements in this
            // block along with our own.
            compiledNodes.push(node.compileNode(o));
          } else if (top) {
            node.front = true;
            fragments = node.compileToFragments(o);
            if (!node.isStatement(o)) {
              fragments = indentInitial(fragments, this);
              [lastFragment] = slice1.call(fragments, -1);
              if (!(lastFragment.code === '' || lastFragment.isComment)) {
                fragments.push(this.makeCode(';'));
              }
            }
            compiledNodes.push(fragments);
          } else {
            compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));
          }
        }
        if (top) {
          if (this.spaced) {
            return [].concat(this.joinFragmentArrays(compiledNodes, '\n\n'), this.makeCode('\n'));
          } else {
            return this.joinFragmentArrays(compiledNodes, '\n');
          }
        }
        if (compiledNodes.length) {
          answer = this.joinFragmentArrays(compiledNodes, ', ');
        } else {
          answer = [this.makeCode('void 0')];
        }
        if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }
      compileRoot(o) {
        var fragments;
        this.spaced = true;
        fragments = this.compileWithDeclarations(o);
        HoistTarget.expand(fragments);
        return this.compileComments(fragments);
      }

      // Compile the expressions body for the contents of a function, with
      // declarations of all inner variables pushed up to the top.
      compileWithDeclarations(o) {
        var assigns, declaredVariable, declaredVariables, declaredVariablesIndex, declars, exp, fragments, i, j, k, len1, len2, post, ref1, rest, scope, spaced;
        fragments = [];
        post = [];
        ref1 = this.expressions;
        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
          exp = ref1[i];
          exp = exp.unwrap();
          if (!(exp instanceof Literal)) {
            break;
          }
        }
        o = merge(o, {
          level: LEVEL_TOP
        });
        if (i) {
          rest = this.expressions.splice(i, 9e9);
          [spaced, this.spaced] = [this.spaced, false];
          [fragments, this.spaced] = [this.compileNode(o), spaced];
          this.expressions = rest;
        }
        post = this.compileNode(o);
        ({
          scope
        } = o);
        if (scope.expressions === this) {
          declars = o.scope.hasDeclarations();
          assigns = scope.hasAssignments;
          if (declars || assigns) {
            if (i) {
              fragments.push(this.makeCode('\n'));
            }
            fragments.push(this.makeCode(`${this.tab}var `));
            if (declars) {
              declaredVariables = scope.declaredVariables();
              for (declaredVariablesIndex = k = 0, len2 = declaredVariables.length; k < len2; declaredVariablesIndex = ++k) {
                declaredVariable = declaredVariables[declaredVariablesIndex];
                fragments.push(this.makeCode(declaredVariable));
                if (Object.prototype.hasOwnProperty.call(o.scope.comments, declaredVariable)) {
                  fragments.push(...o.scope.comments[declaredVariable]);
                }
                if (declaredVariablesIndex !== declaredVariables.length - 1) {
                  fragments.push(this.makeCode(', '));
                }
              }
            }
            if (assigns) {
              if (declars) {
                fragments.push(this.makeCode(`,\n${this.tab + TAB}`));
              }
              fragments.push(this.makeCode(scope.assignedVariables().join(`,\n${this.tab + TAB}`)));
            }
            fragments.push(this.makeCode(`;\n${this.spaced ? '\n' : ''}`));
          } else if (fragments.length && post.length) {
            fragments.push(this.makeCode("\n"));
          }
        }
        return fragments.concat(post);
      }
      compileComments(fragments) {
        var code, commentFragment, fragment, fragmentIndent, fragmentIndex, indent, j, k, l, len1, len2, len3, newLineIndex, onNextLine, p, pastFragment, pastFragmentIndex, q, ref1, ref2, ref3, ref4, trail, upcomingFragment, upcomingFragmentIndex;
        for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {
          fragment = fragments[fragmentIndex];
          // Insert comments into the output at the next or previous newline.
          // If there are no newlines at which to place comments, create them.
          if (fragment.precedingComments) {
            // Determine the indentation level of the fragment that we are about
            // to insert comments before, and use that indentation level for our
            // inserted comments. At this point, the fragments `code` property
            // is the generated output JavaScript, and CoffeeScript always
            // generates output indented by two spaces; so all we need to do is
            // search for a `code` property that begins with at least two spaces.
            fragmentIndent = '';
            ref1 = fragments.slice(0, fragmentIndex + 1);
            for (k = ref1.length - 1; k >= 0; k += -1) {
              pastFragment = ref1[k];
              indent = /^ {2,}/m.exec(pastFragment.code);
              if (indent) {
                fragmentIndent = indent[0];
                break;
              } else if (indexOf.call(pastFragment.code, '\n') >= 0) {
                break;
              }
            }
            code = `\n${fragmentIndent}` + function () {
              var l, len2, ref2, results1;
              ref2 = fragment.precedingComments;
              results1 = [];
              for (l = 0, len2 = ref2.length; l < len2; l++) {
                commentFragment = ref2[l];
                if (commentFragment.isHereComment && commentFragment.multiline) {
                  results1.push(multident(commentFragment.code, fragmentIndent, false));
                } else {
                  results1.push(commentFragment.code);
                }
              }
              return results1;
            }().join(`\n${fragmentIndent}`).replace(/^(\s*)$/gm, '');
            ref2 = fragments.slice(0, fragmentIndex + 1);
            for (pastFragmentIndex = l = ref2.length - 1; l >= 0; pastFragmentIndex = l += -1) {
              pastFragment = ref2[pastFragmentIndex];
              newLineIndex = pastFragment.code.lastIndexOf('\n');
              if (newLineIndex === -1) {
                // Keep searching previous fragments until we cant go back any
                // further, either because there are no fragments left or weve
                // discovered that were in a code block that is interpolated
                // inside a string.
                if (pastFragmentIndex === 0) {
                  pastFragment.code = '\n' + pastFragment.code;
                  newLineIndex = 0;
                } else if (pastFragment.isStringWithInterpolations && pastFragment.code === '{') {
                  code = code.slice(1) + '\n'; // Move newline to end.
                  newLineIndex = 1;
                } else {
                  continue;
                }
              }
              delete fragment.precedingComments;
              pastFragment.code = pastFragment.code.slice(0, newLineIndex) + code + pastFragment.code.slice(newLineIndex);
              break;
            }
          }
          // Yes, this is awfully similar to the previous `if` block, but if you
          // look closely youll find lots of tiny differences that make this
          // confusing if it were abstracted into a function that both blocks share.
          if (fragment.followingComments) {
            // Does the first trailing comment follow at the end of a line of code,
            // like `; // Comment`, or does it start a new line after a line of code?
            trail = fragment.followingComments[0].trail;
            fragmentIndent = '';
            // Find the indent of the next line of code, if we have any non-trailing
            // comments to output. We need to first find the next newline, as these
            // comments will be output after that; and then the indent of the line
            // that follows the next newline.
            if (!(trail && fragment.followingComments.length === 1)) {
              onNextLine = false;
              ref3 = fragments.slice(fragmentIndex);
              for (p = 0, len2 = ref3.length; p < len2; p++) {
                upcomingFragment = ref3[p];
                if (!onNextLine) {
                  if (indexOf.call(upcomingFragment.code, '\n') >= 0) {
                    onNextLine = true;
                  } else {
                    continue;
                  }
                } else {
                  indent = /^ {2,}/m.exec(upcomingFragment.code);
                  if (indent) {
                    fragmentIndent = indent[0];
                    break;
                  } else if (indexOf.call(upcomingFragment.code, '\n') >= 0) {
                    break;
                  }
                }
              }
            }
            // Is this comment following the indent inserted by bare mode?
            // If so, theres no need to indent this further.
            code = fragmentIndex === 1 && /^\s+$/.test(fragments[0].code) ? '' : trail ? ' ' : `\n${fragmentIndent}`;
            // Assemble properly indented comments.
            code += function () {
              var len3, q, ref4, results1;
              ref4 = fragment.followingComments;
              results1 = [];
              for (q = 0, len3 = ref4.length; q < len3; q++) {
                commentFragment = ref4[q];
                if (commentFragment.isHereComment && commentFragment.multiline) {
                  results1.push(multident(commentFragment.code, fragmentIndent, false));
                } else {
                  results1.push(commentFragment.code);
                }
              }
              return results1;
            }().join(`\n${fragmentIndent}`).replace(/^(\s*)$/gm, '');
            ref4 = fragments.slice(fragmentIndex);
            for (upcomingFragmentIndex = q = 0, len3 = ref4.length; q < len3; upcomingFragmentIndex = ++q) {
              upcomingFragment = ref4[upcomingFragmentIndex];
              newLineIndex = upcomingFragment.code.indexOf('\n');
              if (newLineIndex === -1) {
                // Keep searching upcoming fragments until we cant go any
                // further, either because there are no fragments left or weve
                // discovered that were in a code block that is interpolated
                // inside a string.
                if (upcomingFragmentIndex === fragments.length - 1) {
                  upcomingFragment.code = upcomingFragment.code + '\n';
                  newLineIndex = upcomingFragment.code.length;
                } else if (upcomingFragment.isStringWithInterpolations && upcomingFragment.code === '}') {
                  code = `${code}\n`;
                  newLineIndex = 0;
                } else {
                  continue;
                }
              }
              delete fragment.followingComments;
              if (upcomingFragment.code === '\n') {
                // Avoid inserting extra blank lines.
                code = code.replace(/^\n/, '');
              }
              upcomingFragment.code = upcomingFragment.code.slice(0, newLineIndex) + code + upcomingFragment.code.slice(newLineIndex);
              break;
            }
          }
        }
        return fragments;
      }

      // Wrap up the given nodes as a **Block**, unless it already happens
      // to be one.
      static wrap(nodes) {
        if (nodes.length === 1 && nodes[0] instanceof Block) {
          return nodes[0];
        }
        return new Block(nodes);
      }
      astNode(o) {
        if (o.level != null && o.level !== LEVEL_TOP && this.expressions.length) {
          return new Sequence(this.expressions).withLocationDataFrom(this).ast(o);
        }
        return super.astNode(o);
      }
      astType() {
        if (this.isRootBlock) {
          return 'Program';
        } else if (this.isClassBody) {
          return 'ClassBody';
        } else {
          return 'BlockStatement';
        }
      }
      astProperties(o) {
        var body, checkForDirectives, directives, expression, expressionAst, j, len1, ref1;
        checkForDirectives = del(o, 'checkForDirectives');
        if (this.isRootBlock || checkForDirectives) {
          sniffDirectives(this.expressions, {
            notFinalExpression: checkForDirectives
          });
        }
        directives = [];
        body = [];
        ref1 = this.expressions;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          expression = ref1[j];
          expressionAst = expression.ast(o);
          // Ignore generated PassthroughLiteral
          if (expressionAst == null) {
            continue;
          } else if (expression instanceof Directive) {
            directives.push(expressionAst);
            // If an expression is a statement, it can be added to the body as is.
          } else if (expression.isStatementAst(o)) {
            body.push(expressionAst);
          } else {
            // Otherwise, we need to wrap it in an `ExpressionStatement` AST node.
            body.push(Object.assign({
              type: 'ExpressionStatement',
              expression: expressionAst
            }, expression.astLocationData()));
          }
        }
        // For now, were not including `sourceType` on the `Program` AST node.
        // Its value could be either `'script'` or `'module'`, and theres no way
        // for CoffeeScript to always know which it should be. The presence of an
        // `import` or `export` statement in source code would imply that it should
        // be a `module`, but a project may consist of mostly such files and also
        // an outlier file that lacks `import` or `export` but is still imported
        // into the project and therefore expects to be treated as a `module`.
        // Determining the value of `sourceType` is essentially the same challenge
        // posed by determining the parse goal of a JavaScript file, also `module`
        // or `script`, and so if Node figures out a way to do so for `.js` files
        // then CoffeeScript can copy Nodes algorithm.

        // sourceType: 'module'
        return {
          body,
          directives
        };
      }
      astLocationData() {
        if (this.isRootBlock && this.locationData == null) {
          return;
        }
        return super.astLocationData();
      }
    }
    ;
    Block.prototype.children = ['expressions'];
    return Block;
  }.call(this);

  // A directive e.g. 'use strict'.
  // Currently only used during AST generation.
  exports.Directive = Directive = class Directive extends Base {
    constructor(value1) {
      super();
      this.value = value1;
    }
    astProperties(o) {
      return {
        value: Object.assign({}, this.value.ast(o), {
          type: 'DirectiveLiteral'
        })
      };
    }
  };

  //### Literal

  // `Literal` is a base class for static values that can be passed through
  // directly into JavaScript without translation, such as: strings, numbers,
  // `true`, `false`, `null`...
  exports.Literal = Literal = function () {
    class Literal extends Base {
      constructor(value1) {
        super();
        this.value = value1;
      }
      assigns(name) {
        return name === this.value;
      }
      compileNode(o) {
        return [this.makeCode(this.value)];
      }
      astProperties() {
        return {
          value: this.value
        };
      }
      toString() {
        // This is only intended for debugging.
        return ` ${this.isStatement() ? super.toString() : this.constructor.name}: ${this.value}`;
      }
    }
    ;
    Literal.prototype.shouldCache = NO;
    return Literal;
  }.call(this);
  exports.NumberLiteral = NumberLiteral = class NumberLiteral extends Literal {
    constructor(value1, {
      parsedValue
    } = {}) {
      super();
      this.value = value1;
      this.parsedValue = parsedValue;
      if (this.parsedValue == null) {
        if (isNumber(this.value)) {
          this.parsedValue = this.value;
          this.value = `${this.value}`;
        } else {
          this.parsedValue = parseNumber(this.value);
        }
      }
    }
    isBigInt() {
      return /n$/.test(this.value);
    }
    astType() {
      if (this.isBigInt()) {
        return 'BigIntLiteral';
      } else {
        return 'NumericLiteral';
      }
    }
    astProperties() {
      return {
        value: this.isBigInt() ? this.parsedValue.toString() : this.parsedValue,
        extra: {
          rawValue: this.isBigInt() ? this.parsedValue.toString() : this.parsedValue,
          raw: this.value
        }
      };
    }
  };
  exports.InfinityLiteral = InfinityLiteral = class InfinityLiteral extends NumberLiteral {
    constructor(value1, {
      originalValue = 'Infinity'
    } = {}) {
      super();
      this.value = value1;
      this.originalValue = originalValue;
    }
    compileNode() {
      return [this.makeCode('2e308')];
    }
    astNode(o) {
      if (this.originalValue !== 'Infinity') {
        return new NumberLiteral(this.value).withLocationDataFrom(this).ast(o);
      }
      return super.astNode(o);
    }
    astType() {
      return 'Identifier';
    }
    astProperties() {
      return {
        name: 'Infinity',
        declaration: false
      };
    }
  };
  exports.NaNLiteral = NaNLiteral = class NaNLiteral extends NumberLiteral {
    constructor() {
      super('NaN');
    }
    compileNode(o) {
      var code;
      code = [this.makeCode('0/0')];
      if (o.level >= LEVEL_OP) {
        return this.wrapInParentheses(code);
      } else {
        return code;
      }
    }
    astType() {
      return 'Identifier';
    }
    astProperties() {
      return {
        name: 'NaN',
        declaration: false
      };
    }
  };
  exports.StringLiteral = StringLiteral = class StringLiteral extends Literal {
    constructor(originalValue, {
      quote,
      initialChunk,
      finalChunk,
      indent: indent1,
      double: double1,
      heregex: heregex1
    } = {}) {
      var heredoc, indentRegex, val;
      super('');
      this.originalValue = originalValue;
      this.quote = quote;
      this.initialChunk = initialChunk;
      this.finalChunk = finalChunk;
      this.indent = indent1;
      this.double = double1;
      this.heregex = heregex1;
      if (this.quote === '///') {
        this.quote = null;
      }
      this.fromSourceString = this.quote != null;
      if (this.quote == null) {
        this.quote = '"';
      }
      heredoc = this.isFromHeredoc();
      val = this.originalValue;
      if (this.heregex) {
        val = val.replace(HEREGEX_OMIT, '$1$2');
        val = replaceUnicodeCodePointEscapes(val, {
          flags: this.heregex.flags
        });
      } else {
        val = val.replace(STRING_OMIT, '$1');
        val = !this.fromSourceString ? val : heredoc ? (this.indent ? indentRegex = RegExp(`\\n${this.indent}`, "g") : void 0, indentRegex ? val = val.replace(indentRegex, '\n') : void 0, this.initialChunk ? val = val.replace(LEADING_BLANK_LINE, '') : void 0, this.finalChunk ? val = val.replace(TRAILING_BLANK_LINE, '') : void 0, val) : val.replace(SIMPLE_STRING_OMIT, (match, offset) => {
          if (this.initialChunk && offset === 0 || this.finalChunk && offset + match.length === val.length) {
            return '';
          } else {
            return ' ';
          }
        });
      }
      this.delimiter = this.quote.charAt(0);
      this.value = makeDelimitedLiteral(val, {
        delimiter: this.delimiter,
        double: this.double
      });
      this.unquotedValueForTemplateLiteral = makeDelimitedLiteral(val, {
        delimiter: '`',
        double: this.double,
        escapeNewlines: false,
        includeDelimiters: false,
        convertTrailingNullEscapes: true
      });
      this.unquotedValueForJSX = makeDelimitedLiteral(val, {
        double: this.double,
        escapeNewlines: false,
        includeDelimiters: false,
        escapeDelimiter: false
      });
    }
    compileNode(o) {
      if (this.shouldGenerateTemplateLiteral()) {
        return StringWithInterpolations.fromStringLiteral(this).compileNode(o);
      }
      if (this.jsx) {
        return [this.makeCode(this.unquotedValueForJSX)];
      }
      return super.compileNode(o);
    }

    // `StringLiteral`s can represent either entire literal strings
    // or pieces of text inside of e.g. an interpolated string.
    // When parsed as the former but needing to be treated as the latter
    // (e.g. the string part of a tagged template literal), this will return
    // a copy of the `StringLiteral` with the quotes trimmed from its location
    // data (like it would have if parsed as part of an interpolated string).
    withoutQuotesInLocationData() {
      var copy, endsWithNewline, locationData;
      endsWithNewline = this.originalValue.slice(-1) === '\n';
      locationData = Object.assign({}, this.locationData);
      locationData.first_column += this.quote.length;
      if (endsWithNewline) {
        locationData.last_line -= 1;
        locationData.last_column = locationData.last_line === locationData.first_line ? locationData.first_column + this.originalValue.length - '\n'.length : this.originalValue.slice(0, -1).length - '\n'.length - this.originalValue.slice(0, -1).lastIndexOf('\n');
      } else {
        locationData.last_column -= this.quote.length;
      }
      locationData.last_column_exclusive -= this.quote.length;
      locationData.range = [locationData.range[0] + this.quote.length, locationData.range[1] - this.quote.length];
      copy = new StringLiteral(this.originalValue, {
        quote: this.quote,
        initialChunk: this.initialChunk,
        finalChunk: this.finalChunk,
        indent: this.indent,
        double: this.double,
        heregex: this.heregex
      });
      copy.locationData = locationData;
      return copy;
    }
    isFromHeredoc() {
      return this.quote.length === 3;
    }
    shouldGenerateTemplateLiteral() {
      return this.isFromHeredoc();
    }
    astNode(o) {
      if (this.shouldGenerateTemplateLiteral()) {
        return StringWithInterpolations.fromStringLiteral(this).ast(o);
      }
      return super.astNode(o);
    }
    astProperties() {
      return {
        value: this.originalValue,
        extra: {
          raw: `${this.delimiter}${this.originalValue}${this.delimiter}`
        }
      };
    }
  };
  exports.RegexLiteral = RegexLiteral = function () {
    class RegexLiteral extends Literal {
      constructor(value, {
        delimiter: delimiter1 = '/',
        heregexCommentTokens = []
      } = {}) {
        var endDelimiterIndex, heregex, val;
        super('');
        this.delimiter = delimiter1;
        this.heregexCommentTokens = heregexCommentTokens;
        heregex = this.delimiter === '///';
        endDelimiterIndex = value.lastIndexOf('/');
        this.flags = value.slice(endDelimiterIndex + 1);
        val = this.originalValue = value.slice(1, endDelimiterIndex);
        if (heregex) {
          val = val.replace(HEREGEX_OMIT, '$1$2');
        }
        val = replaceUnicodeCodePointEscapes(val, {
          flags: this.flags
        });
        this.value = `${makeDelimitedLiteral(val, {
          delimiter: '/'
        })}${this.flags}`;
      }
      astType() {
        return 'RegExpLiteral';
      }
      astProperties(o) {
        var heregexCommentToken, pattern;
        [, pattern] = this.REGEX_REGEX.exec(this.value);
        return {
          value: void 0,
          pattern,
          flags: this.flags,
          delimiter: this.delimiter,
          originalPattern: this.originalValue,
          extra: {
            raw: this.value,
            originalRaw: `${this.delimiter}${this.originalValue}${this.delimiter}${this.flags}`,
            rawValue: void 0
          },
          comments: function () {
            var j, len1, ref1, results1;
            ref1 = this.heregexCommentTokens;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              heregexCommentToken = ref1[j];
              if (heregexCommentToken.here) {
                results1.push(new HereComment(heregexCommentToken).ast(o));
              } else {
                results1.push(new LineComment(heregexCommentToken).ast(o));
              }
            }
            return results1;
          }.call(this)
        };
      }
    }
    ;
    RegexLiteral.prototype.REGEX_REGEX = /^\/(.*)\/\w*$/;
    return RegexLiteral;
  }.call(this);
  exports.PassthroughLiteral = PassthroughLiteral = class PassthroughLiteral extends Literal {
    constructor(originalValue, {
      here,
      generated
    } = {}) {
      super('');
      this.originalValue = originalValue;
      this.here = here;
      this.generated = generated;
      this.value = this.originalValue.replace(/\\+(`|$)/g, function (string) {
        // `string` is always a value like '\`', '\\\`', '\\\\\`', etc.
        // By reducing it to its latter half, we turn '\`' to '`', '\\\`' to '\`', etc.
        return string.slice(-Math.ceil(string.length / 2));
      });
    }
    astNode(o) {
      if (this.generated) {
        return null;
      }
      return super.astNode(o);
    }
    astProperties() {
      return {
        value: this.originalValue,
        here: !!this.here
      };
    }
  };
  exports.IdentifierLiteral = IdentifierLiteral = function () {
    class IdentifierLiteral extends Literal {
      eachName(iterator) {
        return iterator(this);
      }
      astType() {
        if (this.jsx) {
          return 'JSXIdentifier';
        } else {
          return 'Identifier';
        }
      }
      astProperties() {
        return {
          name: this.value,
          declaration: !!this.isDeclaration
        };
      }
    }
    ;
    IdentifierLiteral.prototype.isAssignable = YES;
    return IdentifierLiteral;
  }.call(this);
  exports.PropertyName = PropertyName = function () {
    class PropertyName extends Literal {
      astType() {
        if (this.jsx) {
          return 'JSXIdentifier';
        } else {
          return 'Identifier';
        }
      }
      astProperties() {
        return {
          name: this.value,
          declaration: false
        };
      }
    }
    ;
    PropertyName.prototype.isAssignable = YES;
    return PropertyName;
  }.call(this);
  exports.ComputedPropertyName = ComputedPropertyName = class ComputedPropertyName extends PropertyName {
    compileNode(o) {
      return [this.makeCode('['), ...this.value.compileToFragments(o, LEVEL_LIST), this.makeCode(']')];
    }
    astNode(o) {
      return this.value.ast(o);
    }
  };
  exports.StatementLiteral = StatementLiteral = function () {
    class StatementLiteral extends Literal {
      jumps(o) {
        if (this.value === 'break' && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {
          return this;
        }
        if (this.value === 'continue' && !(o != null ? o.loop : void 0)) {
          return this;
        }
      }
      compileNode(o) {
        return [this.makeCode(`${this.tab}${this.value};`)];
      }
      astType() {
        switch (this.value) {
          case 'continue':
            return 'ContinueStatement';
          case 'break':
            return 'BreakStatement';
          case 'debugger':
            return 'DebuggerStatement';
        }
      }
    }
    ;
    StatementLiteral.prototype.isStatement = YES;
    StatementLiteral.prototype.makeReturn = THIS;
    return StatementLiteral;
  }.call(this);
  exports.ThisLiteral = ThisLiteral = class ThisLiteral extends Literal {
    constructor(value) {
      super('this');
      this.shorthand = value === '@';
    }
    compileNode(o) {
      var code, ref1;
      code = ((ref1 = o.scope.method) != null ? ref1.bound : void 0) ? o.scope.method.context : this.value;
      return [this.makeCode(code)];
    }
    astType() {
      return 'ThisExpression';
    }
    astProperties() {
      return {
        shorthand: this.shorthand
      };
    }
  };
  exports.UndefinedLiteral = UndefinedLiteral = class UndefinedLiteral extends Literal {
    constructor() {
      super('undefined');
    }
    compileNode(o) {
      return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];
    }
    astType() {
      return 'Identifier';
    }
    astProperties() {
      return {
        name: this.value,
        declaration: false
      };
    }
  };
  exports.NullLiteral = NullLiteral = class NullLiteral extends Literal {
    constructor() {
      super('null');
    }
  };
  exports.BooleanLiteral = BooleanLiteral = class BooleanLiteral extends Literal {
    constructor(value, {
      originalValue
    } = {}) {
      super(value);
      this.originalValue = originalValue;
      if (this.originalValue == null) {
        this.originalValue = this.value;
      }
    }
    astProperties() {
      return {
        value: this.value === 'true' ? true : false,
        name: this.originalValue
      };
    }
  };
  exports.DefaultLiteral = DefaultLiteral = class DefaultLiteral extends Literal {
    astType() {
      return 'Identifier';
    }
    astProperties() {
      return {
        name: 'default',
        declaration: false
      };
    }
  };

  //### Return

  // A `return` is a *pureStatement*wrapping it in a closure wouldnt make sense.
  exports.Return = Return = function () {
    class Return extends Base {
      constructor(expression1, {
        belongsToFuncDirectiveReturn
      } = {}) {
        super();
        this.expression = expression1;
        this.belongsToFuncDirectiveReturn = belongsToFuncDirectiveReturn;
      }
      compileToFragments(o, level) {
        var expr, ref1;
        expr = (ref1 = this.expression) != null ? ref1.makeReturn() : void 0;
        if (expr && !(expr instanceof Return)) {
          return expr.compileToFragments(o, level);
        } else {
          return super.compileToFragments(o, level);
        }
      }
      compileNode(o) {
        var answer, fragment, j, len1;
        answer = [];
        // TODO: If we call `expression.compile()` here twice, well sometimes
        // get back different results!
        if (this.expression) {
          answer = this.expression.compileToFragments(o, LEVEL_PAREN);
          unshiftAfterComments(answer, this.makeCode(`${this.tab}return `));
          // Since the `return` got indented by `@tab`, preceding comments that are
          // multiline need to be indented.
          for (j = 0, len1 = answer.length; j < len1; j++) {
            fragment = answer[j];
            if (fragment.isHereComment && indexOf.call(fragment.code, '\n') >= 0) {
              fragment.code = multident(fragment.code, this.tab);
            } else if (fragment.isLineComment) {
              fragment.code = `${this.tab}${fragment.code}`;
            } else {
              break;
            }
          }
        } else {
          answer.push(this.makeCode(`${this.tab}return`));
        }
        answer.push(this.makeCode(';'));
        return answer;
      }
      checkForPureStatementInExpression() {
        // dont flag `return` from `await return`/`yield return` as invalid.
        if (this.belongsToFuncDirectiveReturn) {
          return;
        }
        return super.checkForPureStatementInExpression();
      }
      astType() {
        return 'ReturnStatement';
      }
      astProperties(o) {
        var ref1, ref2;
        return {
          argument: (ref1 = (ref2 = this.expression) != null ? ref2.ast(o, LEVEL_PAREN) : void 0) != null ? ref1 : null
        };
      }
    }
    ;
    Return.prototype.children = ['expression'];
    Return.prototype.isStatement = YES;
    Return.prototype.makeReturn = THIS;
    Return.prototype.jumps = THIS;
    return Return;
  }.call(this);

  // Parent class for `YieldReturn`/`AwaitReturn`.
  exports.FuncDirectiveReturn = FuncDirectiveReturn = function () {
    class FuncDirectiveReturn extends Return {
      constructor(expression, {
        returnKeyword
      }) {
        super(expression);
        this.returnKeyword = returnKeyword;
      }
      compileNode(o) {
        this.checkScope(o);
        return super.compileNode(o);
      }
      checkScope(o) {
        if (o.scope.parent == null) {
          return this.error(`${this.keyword} can only occur inside functions`);
        }
      }
      astNode(o) {
        this.checkScope(o);
        return new Op(this.keyword, new Return(this.expression, {
          belongsToFuncDirectiveReturn: true
        }).withLocationDataFrom(this.expression != null ? {
          locationData: mergeLocationData(this.returnKeyword.locationData, this.expression.locationData)
        } : this.returnKeyword)).withLocationDataFrom(this).ast(o);
      }
    }
    ;
    FuncDirectiveReturn.prototype.isStatementAst = NO;
    return FuncDirectiveReturn;
  }.call(this);

  // `yield return` works exactly like `return`, except that it turns the function
  // into a generator.
  exports.YieldReturn = YieldReturn = function () {
    class YieldReturn extends FuncDirectiveReturn {}
    ;
    YieldReturn.prototype.keyword = 'yield';
    return YieldReturn;
  }.call(this);
  exports.AwaitReturn = AwaitReturn = function () {
    class AwaitReturn extends FuncDirectiveReturn {}
    ;
    AwaitReturn.prototype.keyword = 'await';
    return AwaitReturn;
  }.call(this);

  //### Value

  // A value, variable or literal or parenthesized, indexed or dotted into,
  // or vanilla.
  exports.Value = Value = function () {
    class Value extends Base {
      constructor(base, props, tag, isDefaultValue = false) {
        var ref1, ref2;
        super();
        if (!props && base instanceof Value) {
          return base;
        }
        this.base = base;
        this.properties = props || [];
        this.tag = tag;
        if (tag) {
          this[tag] = true;
        }
        this.isDefaultValue = isDefaultValue;
        // If this is a `@foo =` assignment, if there are comments on `@` move them
        // to be on `foo`.
        if (((ref1 = this.base) != null ? ref1.comments : void 0) && this.base instanceof ThisLiteral && ((ref2 = this.properties[0]) != null ? ref2.name : void 0) != null) {
          moveComments(this.base, this.properties[0].name);
        }
      }

      // Add a property (or *properties* ) `Access` to the list.
      add(props) {
        this.properties = this.properties.concat(props);
        this.forceUpdateLocation = true;
        return this;
      }
      hasProperties() {
        return this.properties.length !== 0;
      }
      bareLiteral(type) {
        return !this.properties.length && this.base instanceof type;
      }

      // Some boolean checks for the benefit of other nodes.
      isArray() {
        return this.bareLiteral(Arr);
      }
      isRange() {
        return this.bareLiteral(Range);
      }
      shouldCache() {
        return this.hasProperties() || this.base.shouldCache();
      }
      isAssignable(opts) {
        return this.hasProperties() || this.base.isAssignable(opts);
      }
      isNumber() {
        return this.bareLiteral(NumberLiteral);
      }
      isString() {
        return this.bareLiteral(StringLiteral);
      }
      isRegex() {
        return this.bareLiteral(RegexLiteral);
      }
      isUndefined() {
        return this.bareLiteral(UndefinedLiteral);
      }
      isNull() {
        return this.bareLiteral(NullLiteral);
      }
      isBoolean() {
        return this.bareLiteral(BooleanLiteral);
      }
      isAtomic() {
        var j, len1, node, ref1;
        ref1 = this.properties.concat(this.base);
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          node = ref1[j];
          if (node.soak || node instanceof Call || node instanceof Op && node.operator === 'do') {
            return false;
          }
        }
        return true;
      }
      isNotCallable() {
        return this.isNumber() || this.isString() || this.isRegex() || this.isArray() || this.isRange() || this.isSplice() || this.isObject() || this.isUndefined() || this.isNull() || this.isBoolean();
      }
      isStatement(o) {
        return !this.properties.length && this.base.isStatement(o);
      }
      isJSXTag() {
        return this.base instanceof JSXTag;
      }
      assigns(name) {
        return !this.properties.length && this.base.assigns(name);
      }
      jumps(o) {
        return !this.properties.length && this.base.jumps(o);
      }
      isObject(onlyGenerated) {
        if (this.properties.length) {
          return false;
        }
        return this.base instanceof Obj && (!onlyGenerated || this.base.generated);
      }
      isElision() {
        if (!(this.base instanceof Arr)) {
          return false;
        }
        return this.base.hasElision();
      }
      isSplice() {
        var lastProperty, ref1;
        ref1 = this.properties, [lastProperty] = slice1.call(ref1, -1);
        return lastProperty instanceof Slice;
      }
      looksStatic(className) {
        var name, ref1, thisLiteral;
        if (!(((thisLiteral = this.base) instanceof ThisLiteral || (name = this.base).value === className) && this.properties.length === 1 && ((ref1 = this.properties[0].name) != null ? ref1.value : void 0) !== 'prototype')) {
          return false;
        }
        return {
          staticClassName: thisLiteral != null ? thisLiteral : name
        };
      }

      // The value can be unwrapped as its inner node, if there are no attached
      // properties.
      unwrap() {
        if (this.properties.length) {
          return this;
        } else {
          return this.base;
        }
      }

      // A reference has base part (`this` value) and name part.
      // We cache them separately for compiling complex expressions.
      // `a()[b()] ?= c` -> `(_base = a())[_name = b()] ? _base[_name] = c`
      cacheReference(o) {
        var base, bref, name, nref, ref1;
        ref1 = this.properties, [name] = slice1.call(ref1, -1);
        if (this.properties.length < 2 && !this.base.shouldCache() && !(name != null ? name.shouldCache() : void 0)) {
          return [this, this]; // `a` `a.b`
        }

        base = new Value(this.base, this.properties.slice(0, -1));
        if (base.shouldCache()) {
          // `a().b`
          bref = new IdentifierLiteral(o.scope.freeVariable('base'));
          base = new Value(new Parens(new Assign(bref, base)));
        }
        if (!name) {
          // `a()`
          return [base, bref];
        }
        if (name.shouldCache()) {
          // `a[b()]`
          nref = new IdentifierLiteral(o.scope.freeVariable('name'));
          name = new Index(new Assign(nref, name.index));
          nref = new Index(nref);
        }
        return [base.add(name), new Value(bref || base.base, [nref || name])];
      }

      // We compile a value to JavaScript by compiling and joining each property.
      // Things get much more interesting if the chain of properties has *soak*
      // operators `?.` interspersed. Then we have to take care not to accidentally
      // evaluate anything twice when building the soak chain.
      compileNode(o) {
        var fragments, j, len1, prop, props;
        this.base.front = this.front;
        props = this.properties;
        if (props.length && this.base.cached != null) {
          // Cached fragments enable correct order of the compilation,
          // and reuse of variables in the scope.
          // Example:
          // `a(x = 5).b(-> x = 6)` should compile in the same order as
          // `a(x = 5); b(-> x = 6)`
          // (see issue #4437, https://github.com/jashkenas/coffeescript/issues/4437)
          fragments = this.base.cached;
        } else {
          fragments = this.base.compileToFragments(o, props.length ? LEVEL_ACCESS : null);
        }
        if (props.length && SIMPLENUM.test(fragmentsToText(fragments))) {
          fragments.push(this.makeCode('.'));
        }
        for (j = 0, len1 = props.length; j < len1; j++) {
          prop = props[j];
          fragments.push(...prop.compileToFragments(o));
        }
        return fragments;
      }

      // Unfold a soak into an `If`: `a?.b` -> `a.b if a?`
      unfoldSoak(o) {
        return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (() => {
          var fst, i, ifn, j, len1, prop, ref, ref1, snd;
          ifn = this.base.unfoldSoak(o);
          if (ifn) {
            ifn.body.properties.push(...this.properties);
            return ifn;
          }
          ref1 = this.properties;
          for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
            prop = ref1[i];
            if (!prop.soak) {
              continue;
            }
            prop.soak = false;
            fst = new Value(this.base, this.properties.slice(0, i));
            snd = new Value(this.base, this.properties.slice(i));
            if (fst.shouldCache()) {
              ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
              fst = new Parens(new Assign(ref, fst));
              snd.base = ref;
            }
            return new If(new Existence(fst), snd, {
              soak: true
            });
          }
          return false;
        })();
      }
      eachName(iterator, {
        checkAssignability = true
      } = {}) {
        if (this.hasProperties()) {
          return iterator(this);
        } else if (!checkAssignability || this.base.isAssignable()) {
          return this.base.eachName(iterator);
        } else {
          return this.error('tried to assign to unassignable value');
        }
      }

      // For AST generation, we need an `object` thats this `Value` minus its last
      // property, if it has properties.
      object() {
        var initialProperties, object;
        if (!this.hasProperties()) {
          return this;
        }
        // Get all properties except the last one; for a `Value` with only one
        // property, `initialProperties` is an empty array.
        initialProperties = this.properties.slice(0, this.properties.length - 1);
        // Create the `object` that becomes the new base for the split-off final
        // property.
        object = new Value(this.base, initialProperties, this.tag, this.isDefaultValue);
        // Add location data to our new node, so that it has correct location data
        // for source maps or later conversion into AST location data.
        // This new `Value` has only one property, so the location data is just
        // that of the parent `Value`s base.
        // This new `Value` has multiple properties, so the location data spans
        // from the parent `Value`s base to the last property thats included
        // in this new node (a.k.a. the second-to-last property of the parent).
        object.locationData = initialProperties.length === 0 ? this.base.locationData : mergeLocationData(this.base.locationData, initialProperties[initialProperties.length - 1].locationData);
        return object;
      }
      containsSoak() {
        var j, len1, property, ref1;
        if (!this.hasProperties()) {
          return false;
        }
        ref1 = this.properties;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          property = ref1[j];
          if (property.soak) {
            return true;
          }
        }
        if (this.base instanceof Call && this.base.soak) {
          return true;
        }
        return false;
      }
      astNode(o) {
        if (!this.hasProperties()) {
          // If the `Value` has no properties, the AST node is just whatever this
          // nodes `base` is.
          return this.base.ast(o);
        }
        // Otherwise, call `Base::ast` which in turn calls the `astType` and
        // `astProperties` methods below.
        return super.astNode(o);
      }
      astType() {
        if (this.isJSXTag()) {
          return 'JSXMemberExpression';
        } else if (this.containsSoak()) {
          return 'OptionalMemberExpression';
        } else {
          return 'MemberExpression';
        }
      }

      // If this `Value` has properties, the *last* property (e.g. `c` in `a.b.c`)
      // becomes the `property`, and the preceding properties (e.g. `a.b`) become
      // a child `Value` node assigned to the `object` property.
      astProperties(o) {
        var computed, property, ref1, ref2;
        ref1 = this.properties, [property] = slice1.call(ref1, -1);
        if (this.isJSXTag()) {
          property.name.jsx = true;
        }
        computed = property instanceof Index || !(((ref2 = property.name) != null ? ref2.unwrap() : void 0) instanceof PropertyName);
        return {
          object: this.object().ast(o, LEVEL_ACCESS),
          property: property.ast(o, computed ? LEVEL_PAREN : void 0),
          computed,
          optional: !!property.soak,
          shorthand: !!property.shorthand
        };
      }
      astLocationData() {
        if (!this.isJSXTag()) {
          return super.astLocationData();
        }
        // don't include leading < of JSX tag in location data
        return mergeAstLocationData(jisonLocationDataToAstLocationData(this.base.tagNameLocationData), jisonLocationDataToAstLocationData(this.properties[this.properties.length - 1].locationData));
      }
    }
    ;
    Value.prototype.children = ['base', 'properties'];
    return Value;
  }.call(this);
  exports.MetaProperty = MetaProperty = function () {
    class MetaProperty extends Base {
      constructor(meta, property1) {
        super();
        this.meta = meta;
        this.property = property1;
      }
      checkValid(o) {
        if (this.meta.value === 'new') {
          if (this.property instanceof Access && this.property.name.value === 'target') {
            if (o.scope.parent == null) {
              return this.error("new.target can only occur inside functions");
            }
          } else {
            return this.error("the only valid meta property for new is new.target");
          }
        } else if (this.meta.value === 'import') {
          if (!(this.property instanceof Access && this.property.name.value === 'meta')) {
            return this.error("the only valid meta property for import is import.meta");
          }
        }
      }
      compileNode(o) {
        var fragments;
        this.checkValid(o);
        fragments = [];
        fragments.push(...this.meta.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(...this.property.compileToFragments(o));
        return fragments;
      }
      astProperties(o) {
        this.checkValid(o);
        return {
          meta: this.meta.ast(o, LEVEL_ACCESS),
          property: this.property.ast(o)
        };
      }
    }
    ;
    MetaProperty.prototype.children = ['meta', 'property'];
    return MetaProperty;
  }.call(this);

  //### HereComment

  // Comment delimited by `###` (becoming `/* */`).
  exports.HereComment = HereComment = class HereComment extends Base {
    constructor({
      content: content1,
      newLine,
      unshift,
      locationData: locationData1
    }) {
      super();
      this.content = content1;
      this.newLine = newLine;
      this.unshift = unshift;
      this.locationData = locationData1;
    }
    compileNode(o) {
      var fragment, hasLeadingMarks, indent, j, leadingWhitespace, len1, line, multiline, ref1;
      multiline = indexOf.call(this.content, '\n') >= 0;
      // Unindent multiline comments. They will be reindented later.
      if (multiline) {
        indent = null;
        ref1 = this.content.split('\n');
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          line = ref1[j];
          leadingWhitespace = /^\s*/.exec(line)[0];
          if (!indent || leadingWhitespace.length < indent.length) {
            indent = leadingWhitespace;
          }
        }
        if (indent) {
          this.content = this.content.replace(RegExp(`\\n${indent}`, "g"), '\n');
        }
      }
      hasLeadingMarks = /\n\s*[#|\*]/.test(this.content);
      if (hasLeadingMarks) {
        this.content = this.content.replace(/^([ \t]*)#(?=\s)/gm, ' *');
      }
      this.content = `/*${this.content}${hasLeadingMarks ? ' ' : ''}*/`;
      fragment = this.makeCode(this.content);
      fragment.newLine = this.newLine;
      fragment.unshift = this.unshift;
      fragment.multiline = multiline;
      // Dont rely on `fragment.type`, which can break when the compiler is minified.
      fragment.isComment = fragment.isHereComment = true;
      return fragment;
    }
    astType() {
      return 'CommentBlock';
    }
    astProperties() {
      return {
        value: this.content
      };
    }
  };

  //### LineComment

  // Comment running from `#` to the end of a line (becoming `//`).
  exports.LineComment = LineComment = class LineComment extends Base {
    constructor({
      content: content1,
      newLine,
      unshift,
      locationData: locationData1,
      precededByBlankLine
    }) {
      super();
      this.content = content1;
      this.newLine = newLine;
      this.unshift = unshift;
      this.locationData = locationData1;
      this.precededByBlankLine = precededByBlankLine;
    }
    compileNode(o) {
      var fragment;
      fragment = this.makeCode(/^\s*$/.test(this.content) ? '' : `${this.precededByBlankLine ? `\n${o.indent}` : ''}//${this.content}`);
      fragment.newLine = this.newLine;
      fragment.unshift = this.unshift;
      fragment.trail = !this.newLine && !this.unshift;
      // Dont rely on `fragment.type`, which can break when the compiler is minified.
      fragment.isComment = fragment.isLineComment = true;
      return fragment;
    }
    astType() {
      return 'CommentLine';
    }
    astProperties() {
      return {
        value: this.content
      };
    }
  };

  //### JSX
  exports.JSXIdentifier = JSXIdentifier = class JSXIdentifier extends IdentifierLiteral {
    astType() {
      return 'JSXIdentifier';
    }
  };
  exports.JSXTag = JSXTag = class JSXTag extends JSXIdentifier {
    constructor(value, {
      tagNameLocationData,
      closingTagOpeningBracketLocationData,
      closingTagSlashLocationData,
      closingTagNameLocationData,
      closingTagClosingBracketLocationData
    }) {
      super(value);
      this.tagNameLocationData = tagNameLocationData;
      this.closingTagOpeningBracketLocationData = closingTagOpeningBracketLocationData;
      this.closingTagSlashLocationData = closingTagSlashLocationData;
      this.closingTagNameLocationData = closingTagNameLocationData;
      this.closingTagClosingBracketLocationData = closingTagClosingBracketLocationData;
    }
    astProperties() {
      return {
        name: this.value
      };
    }
  };
  exports.JSXExpressionContainer = JSXExpressionContainer = function () {
    class JSXExpressionContainer extends Base {
      constructor(expression1, {
        locationData
      } = {}) {
        super();
        this.expression = expression1;
        this.expression.jsxAttribute = true;
        this.locationData = locationData != null ? locationData : this.expression.locationData;
      }
      compileNode(o) {
        return this.expression.compileNode(o);
      }
      astProperties(o) {
        return {
          expression: astAsBlockIfNeeded(this.expression, o)
        };
      }
    }
    ;
    JSXExpressionContainer.prototype.children = ['expression'];
    return JSXExpressionContainer;
  }.call(this);
  exports.JSXEmptyExpression = JSXEmptyExpression = class JSXEmptyExpression extends Base {};
  exports.JSXText = JSXText = class JSXText extends Base {
    constructor(stringLiteral) {
      super();
      this.value = stringLiteral.unquotedValueForJSX;
      this.locationData = stringLiteral.locationData;
    }
    astProperties() {
      return {
        value: this.value,
        extra: {
          raw: this.value
        }
      };
    }
  };
  exports.JSXAttribute = JSXAttribute = function () {
    class JSXAttribute extends Base {
      constructor({
        name: name1,
        value
      }) {
        var ref1;
        super();
        this.name = name1;
        this.value = value != null ? (value = value.base, value instanceof StringLiteral && !value.shouldGenerateTemplateLiteral() ? value : new JSXExpressionContainer(value)) : null;
        if ((ref1 = this.value) != null) {
          ref1.comments = value.comments;
        }
      }
      compileNode(o) {
        var compiledName, val;
        compiledName = this.name.compileToFragments(o, LEVEL_LIST);
        if (this.value == null) {
          return compiledName;
        }
        val = this.value.compileToFragments(o, LEVEL_LIST);
        return compiledName.concat(this.makeCode('='), val);
      }
      astProperties(o) {
        var name, ref1, ref2;
        name = this.name;
        if (indexOf.call(name.value, ':') >= 0) {
          name = new JSXNamespacedName(name);
        }
        return {
          name: name.ast(o),
          value: (ref1 = (ref2 = this.value) != null ? ref2.ast(o) : void 0) != null ? ref1 : null
        };
      }
    }
    ;
    JSXAttribute.prototype.children = ['name', 'value'];
    return JSXAttribute;
  }.call(this);
  exports.JSXAttributes = JSXAttributes = function () {
    class JSXAttributes extends Base {
      constructor(arr) {
        var attribute, base, j, k, len1, len2, object, property, ref1, ref2, value, variable;
        super();
        this.attributes = [];
        ref1 = arr.objects;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          object = ref1[j];
          this.checkValidAttribute(object);
          ({
            base
          } = object);
          if (base instanceof IdentifierLiteral) {
            // attribute with no value eg disabled
            attribute = new JSXAttribute({
              name: new JSXIdentifier(base.value).withLocationDataAndCommentsFrom(base)
            });
            attribute.locationData = base.locationData;
            this.attributes.push(attribute);
          } else if (!base.generated) {
            // object spread attribute eg {...props}
            attribute = base.properties[0];
            attribute.jsx = true;
            attribute.locationData = base.locationData;
            this.attributes.push(attribute);
          } else {
            ref2 = base.properties;
            // Obj containing attributes with values eg a="b" c={d}
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              property = ref2[k];
              ({
                variable,
                value
              } = property);
              attribute = new JSXAttribute({
                name: new JSXIdentifier(variable.base.value).withLocationDataAndCommentsFrom(variable.base),
                value
              });
              attribute.locationData = property.locationData;
              this.attributes.push(attribute);
            }
          }
        }
        this.locationData = arr.locationData;
      }

      // Catch invalid attributes: <div {a:"b", props} {props} "value" />
      checkValidAttribute(object) {
        var attribute, properties;
        ({
          base: attribute
        } = object);
        properties = (attribute != null ? attribute.properties : void 0) || [];
        if (!(attribute instanceof Obj || attribute instanceof IdentifierLiteral) || attribute instanceof Obj && !attribute.generated && (properties.length > 1 || !(properties[0] instanceof Splat))) {
          return object.error(`Unexpected token. Allowed JSX attributes are: id="val", src={source}, {props...} or attribute.`);
        }
      }
      compileNode(o) {
        var attribute, fragments, j, len1, ref1;
        fragments = [];
        ref1 = this.attributes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          attribute = ref1[j];
          fragments.push(this.makeCode(' '));
          fragments.push(...attribute.compileToFragments(o, LEVEL_TOP));
        }
        return fragments;
      }
      astNode(o) {
        var attribute, j, len1, ref1, results1;
        ref1 = this.attributes;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          attribute = ref1[j];
          results1.push(attribute.ast(o));
        }
        return results1;
      }
    }
    ;
    JSXAttributes.prototype.children = ['attributes'];
    return JSXAttributes;
  }.call(this);
  exports.JSXNamespacedName = JSXNamespacedName = function () {
    class JSXNamespacedName extends Base {
      constructor(tag) {
        var name, namespace;
        super();
        [namespace, name] = tag.value.split(':');
        this.namespace = new JSXIdentifier(namespace).withLocationDataFrom({
          locationData: extractSameLineLocationDataFirst(namespace.length)(tag.locationData)
        });
        this.name = new JSXIdentifier(name).withLocationDataFrom({
          locationData: extractSameLineLocationDataLast(name.length)(tag.locationData)
        });
        this.locationData = tag.locationData;
      }
      astProperties(o) {
        return {
          namespace: this.namespace.ast(o),
          name: this.name.ast(o)
        };
      }
    }
    ;
    JSXNamespacedName.prototype.children = ['namespace', 'name'];
    return JSXNamespacedName;
  }.call(this);

  // Node for a JSX element
  exports.JSXElement = JSXElement = function () {
    class JSXElement extends Base {
      constructor({
        tagName: tagName1,
        attributes,
        content: content1
      }) {
        super();
        this.tagName = tagName1;
        this.attributes = attributes;
        this.content = content1;
      }
      compileNode(o) {
        var fragments, ref1, tag;
        if ((ref1 = this.content) != null) {
          ref1.base.jsx = true;
        }
        fragments = [this.makeCode('<')];
        fragments.push(...(tag = this.tagName.compileToFragments(o, LEVEL_ACCESS)));
        fragments.push(...this.attributes.compileToFragments(o));
        if (this.content) {
          fragments.push(this.makeCode('>'));
          fragments.push(...this.content.compileNode(o, LEVEL_LIST));
          fragments.push(...[this.makeCode('</'), ...tag, this.makeCode('>')]);
        } else {
          fragments.push(this.makeCode(' />'));
        }
        return fragments;
      }
      isFragment() {
        return !this.tagName.base.value.length;
      }
      astNode(o) {
        var tagName;
        // The location data spanning the opening element < ... > is captured by
        // the generated Arr which contains the element's attributes
        this.openingElementLocationData = jisonLocationDataToAstLocationData(this.attributes.locationData);
        tagName = this.tagName.base;
        tagName.locationData = tagName.tagNameLocationData;
        if (this.content != null) {
          this.closingElementLocationData = mergeAstLocationData(jisonLocationDataToAstLocationData(tagName.closingTagOpeningBracketLocationData), jisonLocationDataToAstLocationData(tagName.closingTagClosingBracketLocationData));
        }
        return super.astNode(o);
      }
      astType() {
        if (this.isFragment()) {
          return 'JSXFragment';
        } else {
          return 'JSXElement';
        }
      }
      elementAstProperties(o) {
        var closingElement, columnDiff, currentExpr, openingElement, rangeDiff, ref1, shiftAstLocationData, tagNameAst;
        tagNameAst = () => {
          var tag;
          tag = this.tagName.unwrap();
          if ((tag != null ? tag.value : void 0) && indexOf.call(tag.value, ':') >= 0) {
            tag = new JSXNamespacedName(tag);
          }
          return tag.ast(o);
        };
        openingElement = Object.assign({
          type: 'JSXOpeningElement',
          name: tagNameAst(),
          selfClosing: this.closingElementLocationData == null,
          attributes: this.attributes.ast(o)
        }, this.openingElementLocationData);
        closingElement = null;
        if (this.closingElementLocationData != null) {
          closingElement = Object.assign({
            type: 'JSXClosingElement',
            name: Object.assign(tagNameAst(), jisonLocationDataToAstLocationData(this.tagName.base.closingTagNameLocationData))
          }, this.closingElementLocationData);
          if ((ref1 = closingElement.name.type) === 'JSXMemberExpression' || ref1 === 'JSXNamespacedName') {
            rangeDiff = closingElement.range[0] - openingElement.range[0] + '/'.length;
            columnDiff = closingElement.loc.start.column - openingElement.loc.start.column + '/'.length;
            shiftAstLocationData = node => {
              node.range = [node.range[0] + rangeDiff, node.range[1] + rangeDiff];
              node.start += rangeDiff;
              node.end += rangeDiff;
              node.loc.start = {
                line: this.closingElementLocationData.loc.start.line,
                column: node.loc.start.column + columnDiff
              };
              return node.loc.end = {
                line: this.closingElementLocationData.loc.start.line,
                column: node.loc.end.column + columnDiff
              };
            };
            if (closingElement.name.type === 'JSXMemberExpression') {
              currentExpr = closingElement.name;
              while (currentExpr.type === 'JSXMemberExpression') {
                if (currentExpr !== closingElement.name) {
                  shiftAstLocationData(currentExpr);
                }
                shiftAstLocationData(currentExpr.property);
                currentExpr = currentExpr.object;
              }
              shiftAstLocationData(currentExpr); // JSXNamespacedName
            } else {
              shiftAstLocationData(closingElement.name.namespace);
              shiftAstLocationData(closingElement.name.name);
            }
          }
        }
        return {
          openingElement,
          closingElement
        };
      }
      fragmentAstProperties(o) {
        var closingFragment, openingFragment;
        openingFragment = Object.assign({
          type: 'JSXOpeningFragment'
        }, this.openingElementLocationData);
        closingFragment = Object.assign({
          type: 'JSXClosingFragment'
        }, this.closingElementLocationData);
        return {
          openingFragment,
          closingFragment
        };
      }
      contentAst(o) {
        var base1, child, children, content, element, emptyExpression, expression, j, len1, results1, unwrapped;
        if (!(this.content && !(typeof (base1 = this.content.base).isEmpty === "function" ? base1.isEmpty() : void 0))) {
          return [];
        }
        content = this.content.unwrapAll();
        children = function () {
          var j, len1, ref1, results1;
          if (content instanceof StringLiteral) {
            return [new JSXText(content)]; // StringWithInterpolations
          } else {
            ref1 = this.content.unwrapAll().extractElements(o, {
              includeInterpolationWrappers: true,
              isJsx: true
            });
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              element = ref1[j];
              if (element instanceof StringLiteral) {
                results1.push(new JSXText(element)); // Interpolation
              } else {
                ({
                  expression
                } = element);
                if (expression == null) {
                  emptyExpression = new JSXEmptyExpression();
                  emptyExpression.locationData = emptyExpressionLocationData({
                    interpolationNode: element,
                    openingBrace: '{',
                    closingBrace: '}'
                  });
                  results1.push(new JSXExpressionContainer(emptyExpression, {
                    locationData: element.locationData
                  }));
                } else {
                  unwrapped = expression.unwrapAll();
                  // distinguish `<a><b /></a>` from `<a>{<b />}</a>`
                  if (unwrapped instanceof JSXElement && unwrapped.locationData.range[0] === element.locationData.range[0]) {
                    results1.push(unwrapped);
                  } else {
                    results1.push(new JSXExpressionContainer(unwrapped, {
                      locationData: element.locationData
                    }));
                  }
                }
              }
            }
            return results1;
          }
        }.call(this);
        results1 = [];
        for (j = 0, len1 = children.length; j < len1; j++) {
          child = children[j];
          if (!(child instanceof JSXText && child.value.length === 0)) {
            results1.push(child.ast(o));
          }
        }
        return results1;
      }
      astProperties(o) {
        return Object.assign(this.isFragment() ? this.fragmentAstProperties(o) : this.elementAstProperties(o), {
          children: this.contentAst(o)
        });
      }
      astLocationData() {
        if (this.closingElementLocationData != null) {
          return mergeAstLocationData(this.openingElementLocationData, this.closingElementLocationData);
        } else {
          return this.openingElementLocationData;
        }
      }
    }
    ;
    JSXElement.prototype.children = ['tagName', 'attributes', 'content'];
    return JSXElement;
  }.call(this);

  //### Call

  // Node for a function invocation.
  exports.Call = Call = function () {
    class Call extends Base {
      constructor(variable1, args1 = [], soak1, token1) {
        var ref1;
        super();
        this.variable = variable1;
        this.args = args1;
        this.soak = soak1;
        this.token = token1;
        this.implicit = this.args.implicit;
        this.isNew = false;
        if (this.variable instanceof Value && this.variable.isNotCallable()) {
          this.variable.error("literal is not a function");
        }
        if (this.variable.base instanceof JSXTag) {
          return new JSXElement({
            tagName: this.variable,
            attributes: new JSXAttributes(this.args[0].base),
            content: this.args[1]
          });
        }
        // `@variable` never gets output as a result of this node getting created as
        // part of `RegexWithInterpolations`, so for that case move any comments to
        // the `args` property that gets passed into `RegexWithInterpolations` via
        // the grammar.
        if (((ref1 = this.variable.base) != null ? ref1.value : void 0) === 'RegExp' && this.args.length !== 0) {
          moveComments(this.variable, this.args[0]);
        }
      }

      // When setting the location, we sometimes need to update the start location to
      // account for a newly-discovered `new` operator to the left of us. This
      // expands the range on the left, but not the right.
      updateLocationDataIfMissing(locationData) {
        var base, ref1;
        if (this.locationData && this.needsUpdatedStartLocation) {
          this.locationData = Object.assign({}, this.locationData, {
            first_line: locationData.first_line,
            first_column: locationData.first_column,
            range: [locationData.range[0], this.locationData.range[1]]
          });
          base = ((ref1 = this.variable) != null ? ref1.base : void 0) || this.variable;
          if (base.needsUpdatedStartLocation) {
            this.variable.locationData = Object.assign({}, this.variable.locationData, {
              first_line: locationData.first_line,
              first_column: locationData.first_column,
              range: [locationData.range[0], this.variable.locationData.range[1]]
            });
            base.updateLocationDataIfMissing(locationData);
          }
          delete this.needsUpdatedStartLocation;
        }
        return super.updateLocationDataIfMissing(locationData);
      }

      // Tag this invocation as creating a new instance.
      newInstance() {
        var base, ref1;
        base = ((ref1 = this.variable) != null ? ref1.base : void 0) || this.variable;
        if (base instanceof Call && !base.isNew) {
          base.newInstance();
        } else {
          this.isNew = true;
        }
        this.needsUpdatedStartLocation = true;
        return this;
      }

      // Soaked chained invocations unfold into if/else ternary structures.
      unfoldSoak(o) {
        var call, ifn, j, left, len1, list, ref1, rite;
        if (this.soak) {
          if (this.variable instanceof Super) {
            left = new Literal(this.variable.compile(o));
            rite = new Value(left);
            if (this.variable.accessor == null) {
              this.variable.error("Unsupported reference to 'super'");
            }
          } else {
            if (ifn = unfoldSoak(o, this, 'variable')) {
              return ifn;
            }
            [left, rite] = new Value(this.variable).cacheReference(o);
          }
          rite = new Call(rite, this.args);
          rite.isNew = this.isNew;
          left = new Literal(`typeof ${left.compile(o)} === \"function\"`);
          return new If(left, new Value(rite), {
            soak: true
          });
        }
        call = this;
        list = [];
        while (true) {
          if (call.variable instanceof Call) {
            list.push(call);
            call = call.variable;
            continue;
          }
          if (!(call.variable instanceof Value)) {
            break;
          }
          list.push(call);
          if (!((call = call.variable.base) instanceof Call)) {
            break;
          }
        }
        ref1 = list.reverse();
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          call = ref1[j];
          if (ifn) {
            if (call.variable instanceof Call) {
              call.variable = ifn;
            } else {
              call.variable.base = ifn;
            }
          }
          ifn = unfoldSoak(o, call, 'variable');
        }
        return ifn;
      }

      // Compile a vanilla function call.
      compileNode(o) {
        var arg, argCode, argIndex, cache, compiledArgs, fragments, j, len1, ref1, ref2, ref3, ref4, varAccess;
        this.checkForNewSuper();
        if ((ref1 = this.variable) != null) {
          ref1.front = this.front;
        }
        compiledArgs = [];
        // If variable is `Accessor` fragments are cached and used later
        // in `Value::compileNode` to ensure correct order of the compilation,
        // and reuse of variables in the scope.
        // Example:
        // `a(x = 5).b(-> x = 6)` should compile in the same order as
        // `a(x = 5); b(-> x = 6)`
        // (see issue #4437, https://github.com/jashkenas/coffeescript/issues/4437)
        varAccess = ((ref2 = this.variable) != null ? (ref3 = ref2.properties) != null ? ref3[0] : void 0 : void 0) instanceof Access;
        argCode = function () {
          var j, len1, ref4, results1;
          ref4 = this.args || [];
          results1 = [];
          for (j = 0, len1 = ref4.length; j < len1; j++) {
            arg = ref4[j];
            if (arg instanceof Code) {
              results1.push(arg);
            }
          }
          return results1;
        }.call(this);
        if (argCode.length > 0 && varAccess && !this.variable.base.cached) {
          [cache] = this.variable.base.cache(o, LEVEL_ACCESS, function () {
            return false;
          });
          this.variable.base.cached = cache;
        }
        ref4 = this.args;
        for (argIndex = j = 0, len1 = ref4.length; j < len1; argIndex = ++j) {
          arg = ref4[argIndex];
          if (argIndex) {
            compiledArgs.push(this.makeCode(", "));
          }
          compiledArgs.push(...arg.compileToFragments(o, LEVEL_LIST));
        }
        fragments = [];
        if (this.isNew) {
          fragments.push(this.makeCode('new '));
        }
        fragments.push(...this.variable.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(this.makeCode('('), ...compiledArgs, this.makeCode(')'));
        return fragments;
      }
      checkForNewSuper() {
        if (this.isNew) {
          if (this.variable instanceof Super) {
            return this.variable.error("Unsupported reference to 'super'");
          }
        }
      }
      containsSoak() {
        var ref1;
        if (this.soak) {
          return true;
        }
        if ((ref1 = this.variable) != null ? typeof ref1.containsSoak === "function" ? ref1.containsSoak() : void 0 : void 0) {
          return true;
        }
        return false;
      }
      astNode(o) {
        var ref1;
        if (this.soak && this.variable instanceof Super && ((ref1 = o.scope.namedMethod()) != null ? ref1.ctor : void 0)) {
          this.variable.error("Unsupported reference to 'super'");
        }
        this.checkForNewSuper();
        return super.astNode(o);
      }
      astType() {
        if (this.isNew) {
          return 'NewExpression';
        } else if (this.containsSoak()) {
          return 'OptionalCallExpression';
        } else {
          return 'CallExpression';
        }
      }
      astProperties(o) {
        var arg;
        return {
          callee: this.variable.ast(o, LEVEL_ACCESS),
          arguments: function () {
            var j, len1, ref1, results1;
            ref1 = this.args;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              arg = ref1[j];
              results1.push(arg.ast(o, LEVEL_LIST));
            }
            return results1;
          }.call(this),
          optional: !!this.soak,
          implicit: !!this.implicit
        };
      }
    }
    ;
    Call.prototype.children = ['variable', 'args'];
    return Call;
  }.call(this);

  //### Super

  // Takes care of converting `super()` calls into calls against the prototype's
  // function of the same name.
  // When `expressions` are set the call will be compiled in such a way that the
  // expressions are evaluated without altering the return value of the `SuperCall`
  // expression.
  exports.SuperCall = SuperCall = function () {
    class SuperCall extends Call {
      isStatement(o) {
        var ref1;
        return ((ref1 = this.expressions) != null ? ref1.length : void 0) && o.level === LEVEL_TOP;
      }
      compileNode(o) {
        var ref, ref1, replacement, superCall;
        if (!((ref1 = this.expressions) != null ? ref1.length : void 0)) {
          return super.compileNode(o);
        }
        superCall = new Literal(fragmentsToText(super.compileNode(o)));
        replacement = new Block(this.expressions.slice());
        if (o.level > LEVEL_TOP) {
          // If we might be in an expression we need to cache and return the result
          [superCall, ref] = superCall.cache(o, null, YES);
          replacement.push(ref);
        }
        replacement.unshift(superCall);
        return replacement.compileToFragments(o, o.level === LEVEL_TOP ? o.level : LEVEL_LIST);
      }
    }
    ;
    SuperCall.prototype.children = Call.prototype.children.concat(['expressions']);
    return SuperCall;
  }.call(this);
  exports.Super = Super = function () {
    class Super extends Base {
      constructor(accessor, superLiteral) {
        super();
        this.accessor = accessor;
        this.superLiteral = superLiteral;
      }
      compileNode(o) {
        var fragments, method, name, nref, ref1, ref2, salvagedComments, variable;
        this.checkInInstanceMethod(o);
        method = o.scope.namedMethod();
        if (!(method.ctor != null || this.accessor != null)) {
          ({
            name,
            variable
          } = method);
          if (name.shouldCache() || name instanceof Index && name.index.isAssignable()) {
            nref = new IdentifierLiteral(o.scope.parent.freeVariable('name'));
            name.index = new Assign(nref, name.index);
          }
          this.accessor = nref != null ? new Index(nref) : name;
        }
        if ((ref1 = this.accessor) != null ? (ref2 = ref1.name) != null ? ref2.comments : void 0 : void 0) {
          // A `super()` call gets compiled to e.g. `super.method()`, which means
          // the `method` property name gets compiled for the first time here, and
          // again when the `method:` property of the class gets compiled. Since
          // this compilation happens first, comments attached to `method:` would
          // get incorrectly output near `super.method()`, when we want them to
          // get output on the second pass when `method:` is output. So set them
          // aside during this compilation pass, and put them back on the object so
          // that theyre there for the later compilation.
          salvagedComments = this.accessor.name.comments;
          delete this.accessor.name.comments;
        }
        fragments = new Value(new Literal('super'), this.accessor ? [this.accessor] : []).compileToFragments(o);
        if (salvagedComments) {
          attachCommentsToNode(salvagedComments, this.accessor.name);
        }
        return fragments;
      }
      checkInInstanceMethod(o) {
        var method;
        method = o.scope.namedMethod();
        if (!(method != null ? method.isMethod : void 0)) {
          return this.error('cannot use super outside of an instance method');
        }
      }
      astNode(o) {
        var ref1;
        this.checkInInstanceMethod(o);
        if (this.accessor != null) {
          return new Value(new Super().withLocationDataFrom((ref1 = this.superLiteral) != null ? ref1 : this), [this.accessor]).withLocationDataFrom(this).ast(o);
        }
        return super.astNode(o);
      }
    }
    ;
    Super.prototype.children = ['accessor'];
    return Super;
  }.call(this);

  //### RegexWithInterpolations

  // Regexes with interpolations are in fact just a variation of a `Call` (a
  // `RegExp()` call to be precise) with a `StringWithInterpolations` inside.
  exports.RegexWithInterpolations = RegexWithInterpolations = function () {
    class RegexWithInterpolations extends Base {
      constructor(call1, {
        heregexCommentTokens = []
      } = {}) {
        super();
        this.call = call1;
        this.heregexCommentTokens = heregexCommentTokens;
      }
      compileNode(o) {
        return this.call.compileNode(o);
      }
      astType() {
        return 'InterpolatedRegExpLiteral';
      }
      astProperties(o) {
        var heregexCommentToken, ref1, ref2;
        return {
          interpolatedPattern: this.call.args[0].ast(o),
          flags: (ref1 = (ref2 = this.call.args[1]) != null ? ref2.unwrap().originalValue : void 0) != null ? ref1 : '',
          comments: function () {
            var j, len1, ref3, results1;
            ref3 = this.heregexCommentTokens;
            results1 = [];
            for (j = 0, len1 = ref3.length; j < len1; j++) {
              heregexCommentToken = ref3[j];
              if (heregexCommentToken.here) {
                results1.push(new HereComment(heregexCommentToken).ast(o));
              } else {
                results1.push(new LineComment(heregexCommentToken).ast(o));
              }
            }
            return results1;
          }.call(this)
        };
      }
    }
    ;
    RegexWithInterpolations.prototype.children = ['call'];
    return RegexWithInterpolations;
  }.call(this);

  //### TaggedTemplateCall
  exports.TaggedTemplateCall = TaggedTemplateCall = class TaggedTemplateCall extends Call {
    constructor(variable, arg, soak) {
      if (arg instanceof StringLiteral) {
        arg = StringWithInterpolations.fromStringLiteral(arg);
      }
      super(variable, [arg], soak);
    }
    compileNode(o) {
      return this.variable.compileToFragments(o, LEVEL_ACCESS).concat(this.args[0].compileToFragments(o, LEVEL_LIST));
    }
    astType() {
      return 'TaggedTemplateExpression';
    }
    astProperties(o) {
      return {
        tag: this.variable.ast(o, LEVEL_ACCESS),
        quasi: this.args[0].ast(o, LEVEL_LIST)
      };
    }
  };

  //### Extends

  // Node to extend an object's prototype with an ancestor object.
  // After `goog.inherits` from the
  // [Closure Library](https://github.com/google/closure-library/blob/master/closure/goog/base.js).
  exports.Extends = Extends = function () {
    class Extends extends Base {
      constructor(child1, parent1) {
        super();
        this.child = child1;
        this.parent = parent1;
      }

      // Hooks one constructor into another's prototype chain.
      compileToFragments(o) {
        return new Call(new Value(new Literal(utility('extend', o))), [this.child, this.parent]).compileToFragments(o);
      }
    }
    ;
    Extends.prototype.children = ['child', 'parent'];
    return Extends;
  }.call(this);

  //### Access

  // A `.` access into a property of a value, or the `::` shorthand for
  // an access into the object's prototype.
  exports.Access = Access = function () {
    class Access extends Base {
      constructor(name1, {
        soak: soak1,
        shorthand
      } = {}) {
        super();
        this.name = name1;
        this.soak = soak1;
        this.shorthand = shorthand;
      }
      compileToFragments(o) {
        var name, node;
        name = this.name.compileToFragments(o);
        node = this.name.unwrap();
        if (node instanceof PropertyName) {
          return [this.makeCode('.'), ...name];
        } else {
          return [this.makeCode('['), ...name, this.makeCode(']')];
        }
      }
      astNode(o) {
        // Babel doesnt have an AST node for `Access`, but rather just includes
        // this Access nodes child `name` Identifier node as the `property` of
        // the `MemberExpression` node.
        return this.name.ast(o);
      }
    }
    ;
    Access.prototype.children = ['name'];
    Access.prototype.shouldCache = NO;
    return Access;
  }.call(this);

  //### Index

  // A `[ ... ]` indexed access into an array or object.
  exports.Index = Index = function () {
    class Index extends Base {
      constructor(index1) {
        super();
        this.index = index1;
      }
      compileToFragments(o) {
        return [].concat(this.makeCode("["), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode("]"));
      }
      shouldCache() {
        return this.index.shouldCache();
      }
      astNode(o) {
        // Babel doesnt have an AST node for `Index`, but rather just includes
        // this Index nodes child `index` Identifier node as the `property` of
        // the `MemberExpression` node. The fact that the `MemberExpression`s
        // `property` is an Index means that `computed` is `true` for the
        // `MemberExpression`.
        return this.index.ast(o);
      }
    }
    ;
    Index.prototype.children = ['index'];
    return Index;
  }.call(this);

  //### Range

  // A range literal. Ranges can be used to extract portions (slices) of arrays,
  // to specify a range for comprehensions, or as a value, to be expanded into the
  // corresponding array of integers at runtime.
  exports.Range = Range = function () {
    class Range extends Base {
      constructor(from1, to1, tag) {
        super();
        this.from = from1;
        this.to = to1;
        this.exclusive = tag === 'exclusive';
        this.equals = this.exclusive ? '' : '=';
      }

      // Compiles the range's source variables -- where it starts and where it ends.
      // But only if they need to be cached to avoid double evaluation.
      compileVariables(o) {
        var shouldCache, step;
        o = merge(o, {
          top: true
        });
        shouldCache = del(o, 'shouldCache');
        [this.fromC, this.fromVar] = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST, shouldCache));
        [this.toC, this.toVar] = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST, shouldCache));
        if (step = del(o, 'step')) {
          [this.step, this.stepVar] = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST, shouldCache));
        }
        this.fromNum = this.from.isNumber() ? parseNumber(this.fromVar) : null;
        this.toNum = this.to.isNumber() ? parseNumber(this.toVar) : null;
        return this.stepNum = (step != null ? step.isNumber() : void 0) ? parseNumber(this.stepVar) : null;
      }

      // When compiled normally, the range returns the contents of the *for loop*
      // needed to iterate over the values in the range. Used by comprehensions.
      compileNode(o) {
        var cond, condPart, from, gt, idx, idxName, known, lowerBound, lt, namedIndex, ref1, ref2, stepCond, stepNotZero, stepPart, to, upperBound, varPart;
        if (!this.fromVar) {
          this.compileVariables(o);
        }
        if (!o.index) {
          return this.compileArray(o);
        }
        // Set up endpoints.
        known = this.fromNum != null && this.toNum != null;
        idx = del(o, 'index');
        idxName = del(o, 'name');
        namedIndex = idxName && idxName !== idx;
        varPart = known && !namedIndex ? `var ${idx} = ${this.fromC}` : `${idx} = ${this.fromC}`;
        if (this.toC !== this.toVar) {
          varPart += `, ${this.toC}`;
        }
        if (this.step !== this.stepVar) {
          varPart += `, ${this.step}`;
        }
        [lt, gt] = [`${idx} <${this.equals}`, `${idx} >${this.equals}`];
        // Generate the condition.
        [from, to] = [this.fromNum, this.toNum];
        // Always check if the `step` isn't zero to avoid the infinite loop.
        stepNotZero = `${(ref1 = this.stepNum) != null ? ref1 : this.stepVar} !== 0`;
        stepCond = `${(ref2 = this.stepNum) != null ? ref2 : this.stepVar} > 0`;
        lowerBound = `${lt} ${known ? to : this.toVar}`;
        upperBound = `${gt} ${known ? to : this.toVar}`;
        condPart = this.step != null ? this.stepNum != null && this.stepNum !== 0 ? this.stepNum > 0 ? `${lowerBound}` : `${upperBound}` : `${stepNotZero} && (${stepCond} ? ${lowerBound} : ${upperBound})` : known ? `${from <= to ? lt : gt} ${to}` : `(${this.fromVar} <= ${this.toVar} ? ${lowerBound} : ${upperBound})`;
        cond = this.stepVar ? `${this.stepVar} > 0` : `${this.fromVar} <= ${this.toVar}`;
        // Generate the step.
        stepPart = this.stepVar ? `${idx} += ${this.stepVar}` : known ? namedIndex ? from <= to ? `++${idx}` : `--${idx}` : from <= to ? `${idx}++` : `${idx}--` : namedIndex ? `${cond} ? ++${idx} : --${idx}` : `${cond} ? ${idx}++ : ${idx}--`;
        if (namedIndex) {
          varPart = `${idxName} = ${varPart}`;
        }
        if (namedIndex) {
          stepPart = `${idxName} = ${stepPart}`;
        }
        // The final loop body.
        return [this.makeCode(`${varPart}; ${condPart}; ${stepPart}`)];
      }

      // When used as a value, expand the range into the equivalent array.
      compileArray(o) {
        var args, body, cond, hasArgs, i, idt, known, post, pre, range, ref1, ref2, result, vars;
        known = this.fromNum != null && this.toNum != null;
        if (known && Math.abs(this.fromNum - this.toNum) <= 20) {
          range = function () {
            var results1 = [];
            for (var j = ref1 = this.fromNum, ref2 = this.toNum; ref1 <= ref2 ? j <= ref2 : j >= ref2; ref1 <= ref2 ? j++ : j--) {
              results1.push(j);
            }
            return results1;
          }.apply(this);
          if (this.exclusive) {
            range.pop();
          }
          return [this.makeCode(`[${range.join(', ')}]`)];
        }
        idt = this.tab + TAB;
        i = o.scope.freeVariable('i', {
          single: true,
          reserve: false
        });
        result = o.scope.freeVariable('results', {
          reserve: false
        });
        pre = `\n${idt}var ${result} = [];`;
        if (known) {
          o.index = i;
          body = fragmentsToText(this.compileNode(o));
        } else {
          vars = `${i} = ${this.fromC}` + (this.toC !== this.toVar ? `, ${this.toC}` : '');
          cond = `${this.fromVar} <= ${this.toVar}`;
          body = `var ${vars}; ${cond} ? ${i} <${this.equals} ${this.toVar} : ${i} >${this.equals} ${this.toVar}; ${cond} ? ${i}++ : ${i}--`;
        }
        post = `{ ${result}.push(${i}); }\n${idt}return ${result};\n${o.indent}`;
        hasArgs = function (node) {
          return node != null ? node.contains(isLiteralArguments) : void 0;
        };
        if (hasArgs(this.from) || hasArgs(this.to)) {
          args = ', arguments';
        }
        return [this.makeCode(`(function() {${pre}\n${idt}for (${body})${post}}).apply(this${args != null ? args : ''})`)];
      }
      astProperties(o) {
        var ref1, ref2, ref3, ref4;
        return {
          from: (ref1 = (ref2 = this.from) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          to: (ref3 = (ref4 = this.to) != null ? ref4.ast(o) : void 0) != null ? ref3 : null,
          exclusive: this.exclusive
        };
      }
    }
    ;
    Range.prototype.children = ['from', 'to'];
    return Range;
  }.call(this);

  //### Slice

  // An array slice literal. Unlike JavaScripts `Array#slice`, the second parameter
  // specifies the index of the end of the slice, just as the first parameter
  // is the index of the beginning.
  exports.Slice = Slice = function () {
    class Slice extends Base {
      constructor(range1) {
        super();
        this.range = range1;
      }

      // We have to be careful when trying to slice through the end of the array,
      // `9e9` is used because not all implementations respect `undefined` or `1/0`.
      // `9e9` should be safe because `9e9` > `2**32`, the max array length.
      compileNode(o) {
        var compiled, compiledText, from, fromCompiled, to, toStr;
        ({
          to,
          from
        } = this.range);
        // Handle an expression in the property access, e.g. `a[!b in c..]`.
        if (from != null ? from.shouldCache() : void 0) {
          from = new Value(new Parens(from));
        }
        if (to != null ? to.shouldCache() : void 0) {
          to = new Value(new Parens(to));
        }
        fromCompiled = (from != null ? from.compileToFragments(o, LEVEL_PAREN) : void 0) || [this.makeCode('0')];
        if (to) {
          compiled = to.compileToFragments(o, LEVEL_PAREN);
          compiledText = fragmentsToText(compiled);
          if (!(!this.range.exclusive && +compiledText === -1)) {
            toStr = ', ' + (this.range.exclusive ? compiledText : to.isNumber() ? `${+compiledText + 1}` : (compiled = to.compileToFragments(o, LEVEL_ACCESS), `+${fragmentsToText(compiled)} + 1 || 9e9`));
          }
        }
        return [this.makeCode(`.slice(${fragmentsToText(fromCompiled)}${toStr || ''})`)];
      }
      astNode(o) {
        return this.range.ast(o);
      }
    }
    ;
    Slice.prototype.children = ['range'];
    return Slice;
  }.call(this);

  //### Obj

  // An object literal, nothing fancy.
  exports.Obj = Obj = function () {
    class Obj extends Base {
      constructor(props, generated = false) {
        super();
        this.generated = generated;
        this.objects = this.properties = props || [];
      }
      isAssignable(opts) {
        var j, len1, message, prop, ref1, ref2;
        ref1 = this.properties;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prop = ref1[j];
          // Check for reserved words.
          message = isUnassignable(prop.unwrapAll().value);
          if (message) {
            prop.error(message);
          }
          if (prop instanceof Assign && prop.context === 'object' && !(((ref2 = prop.value) != null ? ref2.base : void 0) instanceof Arr)) {
            prop = prop.value;
          }
          if (!prop.isAssignable(opts)) {
            return false;
          }
        }
        return true;
      }
      shouldCache() {
        return !this.isAssignable();
      }

      // Check if object contains splat.
      hasSplat() {
        var j, len1, prop, ref1;
        ref1 = this.properties;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prop = ref1[j];
          if (prop instanceof Splat) {
            return true;
          }
        }
        return false;
      }

      // Move rest property to the end of the list.
      // `{a, rest..., b} = obj` -> `{a, b, rest...} = obj`
      // `foo = ({a, rest..., b}) ->` -> `foo = {a, b, rest...}) ->`
      reorderProperties() {
        var props, splatProp, splatProps;
        props = this.properties;
        splatProps = this.getAndCheckSplatProps();
        splatProp = props.splice(splatProps[0], 1);
        return this.objects = this.properties = [].concat(props, splatProp);
      }
      compileNode(o) {
        var answer, i, idt, indent, isCompact, j, join, k, key, l, lastNode, len1, len2, len3, node, prop, props, ref1, value;
        if (this.hasSplat() && this.lhs) {
          this.reorderProperties();
        }
        props = this.properties;
        if (this.generated) {
          for (j = 0, len1 = props.length; j < len1; j++) {
            node = props[j];
            if (node instanceof Value) {
              node.error('cannot have an implicit value in an implicit object');
            }
          }
        }
        idt = o.indent += TAB;
        lastNode = this.lastNode(this.properties);
        // If this object is the left-hand side of an assignment, all its children
        // are too.
        this.propagateLhs();
        isCompact = true;
        ref1 = this.properties;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          prop = ref1[k];
          if (prop instanceof Assign && prop.context === 'object') {
            isCompact = false;
          }
        }
        answer = [];
        answer.push(this.makeCode(isCompact ? '' : '\n'));
        for (i = l = 0, len3 = props.length; l < len3; i = ++l) {
          prop = props[i];
          join = i === props.length - 1 ? '' : isCompact ? ', ' : prop === lastNode ? '\n' : ',\n';
          indent = isCompact ? '' : idt;
          key = prop instanceof Assign && prop.context === 'object' ? prop.variable : prop instanceof Assign ? (!this.lhs ? prop.operatorToken.error(`unexpected ${prop.operatorToken.value}`) : void 0, prop.variable) : prop;
          if (key instanceof Value && key.hasProperties()) {
            if (prop.context === 'object' || !key.this) {
              key.error('invalid object key');
            }
            key = key.properties[0].name;
            prop = new Assign(key, prop, 'object');
          }
          if (key === prop) {
            if (prop.shouldCache()) {
              [key, value] = prop.base.cache(o);
              if (key instanceof IdentifierLiteral) {
                key = new PropertyName(key.value);
              }
              prop = new Assign(key, value, 'object');
            } else if (key instanceof Value && key.base instanceof ComputedPropertyName) {
              // `{ [foo()] }` output as `{ [ref = foo()]: ref }`.
              if (prop.base.value.shouldCache()) {
                [key, value] = prop.base.value.cache(o);
                if (key instanceof IdentifierLiteral) {
                  key = new ComputedPropertyName(key.value);
                }
                prop = new Assign(key, value, 'object');
              } else {
                // `{ [expression] }` output as `{ [expression]: expression }`.
                prop = new Assign(key, prop.base.value, 'object');
              }
            } else if (!(typeof prop.bareLiteral === "function" ? prop.bareLiteral(IdentifierLiteral) : void 0) && !(prop instanceof Splat)) {
              prop = new Assign(prop, prop, 'object');
            }
          }
          if (indent) {
            answer.push(this.makeCode(indent));
          }
          answer.push(...prop.compileToFragments(o, LEVEL_TOP));
          if (join) {
            answer.push(this.makeCode(join));
          }
        }
        answer.push(this.makeCode(isCompact ? '' : `\n${this.tab}`));
        answer = this.wrapInBraces(answer);
        if (this.front) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }
      getAndCheckSplatProps() {
        var i, prop, props, splatProps;
        if (!(this.hasSplat() && this.lhs)) {
          return;
        }
        props = this.properties;
        splatProps = function () {
          var j, len1, results1;
          results1 = [];
          for (i = j = 0, len1 = props.length; j < len1; i = ++j) {
            prop = props[i];
            if (prop instanceof Splat) {
              results1.push(i);
            }
          }
          return results1;
        }();
        if ((splatProps != null ? splatProps.length : void 0) > 1) {
          props[splatProps[1]].error("multiple spread elements are disallowed");
        }
        return splatProps;
      }
      assigns(name) {
        var j, len1, prop, ref1;
        ref1 = this.properties;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prop = ref1[j];
          if (prop.assigns(name)) {
            return true;
          }
        }
        return false;
      }
      eachName(iterator) {
        var j, len1, prop, ref1, results1;
        ref1 = this.properties;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prop = ref1[j];
          if (prop instanceof Assign && prop.context === 'object') {
            prop = prop.value;
          }
          prop = prop.unwrapAll();
          if (prop.eachName != null) {
            results1.push(prop.eachName(iterator));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      // Convert bare properties to `ObjectProperty`s (or `Splat`s).
      expandProperty(property) {
        var context, key, operatorToken, variable;
        ({
          variable,
          context,
          operatorToken
        } = property);
        key = property instanceof Assign && context === 'object' ? variable : property instanceof Assign ? (!this.lhs ? operatorToken.error(`unexpected ${operatorToken.value}`) : void 0, variable) : property;
        if (key instanceof Value && key.hasProperties()) {
          if (!(context !== 'object' && key.this)) {
            key.error('invalid object key');
          }
          if (property instanceof Assign) {
            return new ObjectProperty({
              fromAssign: property
            });
          } else {
            return new ObjectProperty({
              key: property
            });
          }
        }
        if (key !== property) {
          return new ObjectProperty({
            fromAssign: property
          });
        }
        if (property instanceof Splat) {
          return property;
        }
        return new ObjectProperty({
          key: property
        });
      }
      expandProperties() {
        var j, len1, property, ref1, results1;
        ref1 = this.properties;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          property = ref1[j];
          results1.push(this.expandProperty(property));
        }
        return results1;
      }
      propagateLhs(setLhs) {
        var j, len1, property, ref1, results1, unwrappedValue, value;
        if (setLhs) {
          this.lhs = true;
        }
        if (!this.lhs) {
          return;
        }
        ref1 = this.properties;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          property = ref1[j];
          if (property instanceof Assign && property.context === 'object') {
            ({
              value
            } = property);
            unwrappedValue = value.unwrapAll();
            if (unwrappedValue instanceof Arr || unwrappedValue instanceof Obj) {
              results1.push(unwrappedValue.propagateLhs(true));
            } else if (unwrappedValue instanceof Assign) {
              results1.push(unwrappedValue.nestedLhs = true);
            } else {
              results1.push(void 0);
            }
          } else if (property instanceof Assign) {
            // Shorthand property with default, e.g. `{a = 1} = b`.
            results1.push(property.nestedLhs = true);
          } else if (property instanceof Splat) {
            results1.push(property.propagateLhs(true));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }
      astNode(o) {
        this.getAndCheckSplatProps();
        return super.astNode(o);
      }
      astType() {
        if (this.lhs) {
          return 'ObjectPattern';
        } else {
          return 'ObjectExpression';
        }
      }
      astProperties(o) {
        var property;
        return {
          implicit: !!this.generated,
          properties: function () {
            var j, len1, ref1, results1;
            ref1 = this.expandProperties();
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              property = ref1[j];
              results1.push(property.ast(o));
            }
            return results1;
          }.call(this)
        };
      }
    }
    ;
    Obj.prototype.children = ['properties'];
    return Obj;
  }.call(this);
  exports.ObjectProperty = ObjectProperty = class ObjectProperty extends Base {
    constructor({
      key,
      fromAssign
    }) {
      var context, value;
      super();
      if (fromAssign) {
        ({
          variable: this.key,
          value,
          context
        } = fromAssign);
        if (context === 'object') {
          // All non-shorthand properties (i.e. includes `:`).
          this.value = value;
        } else {
          // Left-hand-side shorthand with default e.g. `{a = 1} = b`.
          this.value = fromAssign;
          this.shorthand = true;
        }
        this.locationData = fromAssign.locationData;
      } else {
        // Shorthand without default e.g. `{a}` or `{@a}` or `{[a]}`.
        this.key = key;
        this.shorthand = true;
        this.locationData = key.locationData;
      }
    }
    astProperties(o) {
      var isComputedPropertyName, keyAst, ref1, ref2;
      isComputedPropertyName = this.key instanceof Value && this.key.base instanceof ComputedPropertyName || this.key.unwrap() instanceof StringWithInterpolations;
      keyAst = this.key.ast(o, LEVEL_LIST);
      return {
        key: (keyAst != null ? keyAst.declaration : void 0) ? Object.assign({}, keyAst, {
          declaration: false
        }) : keyAst,
        value: (ref1 = (ref2 = this.value) != null ? ref2.ast(o, LEVEL_LIST) : void 0) != null ? ref1 : keyAst,
        shorthand: !!this.shorthand,
        computed: !!isComputedPropertyName,
        method: false
      };
    }
  };

  //### Arr

  // An array literal.
  exports.Arr = Arr = function () {
    class Arr extends Base {
      constructor(objs, lhs1 = false) {
        super();
        this.lhs = lhs1;
        this.objects = objs || [];
        this.propagateLhs();
      }
      hasElision() {
        var j, len1, obj, ref1;
        ref1 = this.objects;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          obj = ref1[j];
          if (obj instanceof Elision) {
            return true;
          }
        }
        return false;
      }
      isAssignable(opts) {
        var allowEmptyArray, allowExpansion, allowNontrailingSplat, i, j, len1, obj, ref1;
        ({
          allowExpansion,
          allowNontrailingSplat,
          allowEmptyArray = false
        } = opts != null ? opts : {});
        if (!this.objects.length) {
          return allowEmptyArray;
        }
        ref1 = this.objects;
        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
          obj = ref1[i];
          if (!allowNontrailingSplat && obj instanceof Splat && i + 1 !== this.objects.length) {
            return false;
          }
          if (!(allowExpansion && obj instanceof Expansion || obj.isAssignable(opts) && (!obj.isAtomic || obj.isAtomic()))) {
            return false;
          }
        }
        return true;
      }
      shouldCache() {
        return !this.isAssignable();
      }
      compileNode(o) {
        var answer, compiledObjs, fragment, fragmentIndex, fragmentIsElision, fragments, includesLineCommentsOnNonFirstElement, index, j, k, l, len1, len2, len3, len4, len5, obj, objIndex, olen, p, passedElision, q, ref1, ref2, unwrappedObj;
        if (!this.objects.length) {
          return [this.makeCode('[]')];
        }
        o.indent += TAB;
        fragmentIsElision = function ([fragment]) {
          return fragment.type === 'Elision' && fragment.code.trim() === ',';
        };
        // Detect if `Elision`s at the beginning of the array are processed (e.g. [, , , a]).
        passedElision = false;
        answer = [];
        ref1 = this.objects;
        for (objIndex = j = 0, len1 = ref1.length; j < len1; objIndex = ++j) {
          obj = ref1[objIndex];
          unwrappedObj = obj.unwrapAll();
          // Let `compileCommentFragments` know to intersperse block comments
          // into the fragments created when compiling this array.
          if (unwrappedObj.comments && unwrappedObj.comments.filter(function (comment) {
            return !comment.here;
          }).length === 0) {
            unwrappedObj.includeCommentFragments = YES;
          }
        }
        compiledObjs = function () {
          var k, len2, ref2, results1;
          ref2 = this.objects;
          results1 = [];
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            obj = ref2[k];
            results1.push(obj.compileToFragments(o, LEVEL_LIST));
          }
          return results1;
        }.call(this);
        olen = compiledObjs.length;
        // If `compiledObjs` includes newlines, we will output this as a multiline
        // array (i.e. with a newline and indentation after the `[`). If an element
        // contains line comments, that should also trigger multiline output since
        // by definition line comments will introduce newlines into our output.
        // The exception is if only the first element has line comments; in that
        // case, output as the compact form if we otherwise would have, so that the
        // first elements line comments get output before or after the array.
        includesLineCommentsOnNonFirstElement = false;
        for (index = k = 0, len2 = compiledObjs.length; k < len2; index = ++k) {
          fragments = compiledObjs[index];
          for (l = 0, len3 = fragments.length; l < len3; l++) {
            fragment = fragments[l];
            if (fragment.isHereComment) {
              fragment.code = fragment.code.trim();
            } else if (index !== 0 && includesLineCommentsOnNonFirstElement === false && hasLineComments(fragment)) {
              includesLineCommentsOnNonFirstElement = true;
            }
          }
          // Add ', ' if all `Elisions` from the beginning of the array are processed (e.g. [, , , a]) and
          // element isn't `Elision` or last element is `Elision` (e.g. [a,,b,,])
          if (index !== 0 && passedElision && (!fragmentIsElision(fragments) || index === olen - 1)) {
            answer.push(this.makeCode(', '));
          }
          passedElision = passedElision || !fragmentIsElision(fragments);
          answer.push(...fragments);
        }
        if (includesLineCommentsOnNonFirstElement || indexOf.call(fragmentsToText(answer), '\n') >= 0) {
          for (fragmentIndex = p = 0, len4 = answer.length; p < len4; fragmentIndex = ++p) {
            fragment = answer[fragmentIndex];
            if (fragment.isHereComment) {
              fragment.code = `${multident(fragment.code, o.indent, false)}\n${o.indent}`;
            } else if (fragment.code === ', ' && !(fragment != null ? fragment.isElision : void 0) && (ref2 = fragment.type) !== 'StringLiteral' && ref2 !== 'StringWithInterpolations') {
              fragment.code = `,\n${o.indent}`;
            }
          }
          answer.unshift(this.makeCode(`[\n${o.indent}`));
          answer.push(this.makeCode(`\n${this.tab}]`));
        } else {
          for (q = 0, len5 = answer.length; q < len5; q++) {
            fragment = answer[q];
            if (fragment.isHereComment) {
              fragment.code = `${fragment.code} `;
            }
          }
          answer.unshift(this.makeCode('['));
          answer.push(this.makeCode(']'));
        }
        return answer;
      }
      assigns(name) {
        var j, len1, obj, ref1;
        ref1 = this.objects;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          obj = ref1[j];
          if (obj.assigns(name)) {
            return true;
          }
        }
        return false;
      }
      eachName(iterator) {
        var j, len1, obj, ref1, results1;
        ref1 = this.objects;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          obj = ref1[j];
          obj = obj.unwrapAll();
          results1.push(obj.eachName(iterator));
        }
        return results1;
      }

      // If this array is the left-hand side of an assignment, all its children
      // are too.
      propagateLhs(setLhs) {
        var j, len1, object, ref1, results1, unwrappedObject;
        if (setLhs) {
          this.lhs = true;
        }
        if (!this.lhs) {
          return;
        }
        ref1 = this.objects;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          object = ref1[j];
          if (object instanceof Splat || object instanceof Expansion) {
            object.lhs = true;
          }
          unwrappedObject = object.unwrapAll();
          if (unwrappedObject instanceof Arr || unwrappedObject instanceof Obj) {
            results1.push(unwrappedObject.propagateLhs(true));
          } else if (unwrappedObject instanceof Assign) {
            results1.push(unwrappedObject.nestedLhs = true);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }
      astType() {
        if (this.lhs) {
          return 'ArrayPattern';
        } else {
          return 'ArrayExpression';
        }
      }
      astProperties(o) {
        var object;
        return {
          elements: function () {
            var j, len1, ref1, results1;
            ref1 = this.objects;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              object = ref1[j];
              results1.push(object.ast(o, LEVEL_LIST));
            }
            return results1;
          }.call(this)
        };
      }
    }
    ;
    Arr.prototype.children = ['objects'];
    return Arr;
  }.call(this);

  //### Class

  // The CoffeeScript class definition.
  // Initialize a **Class** with its name, an optional superclass, and a body.
  exports.Class = Class = function () {
    class Class extends Base {
      constructor(variable1, parent1, body1) {
        super();
        this.variable = variable1;
        this.parent = parent1;
        this.body = body1;
        if (this.body == null) {
          this.body = new Block();
          this.hasGeneratedBody = true;
        }
      }
      compileNode(o) {
        var executableBody, node, parentName;
        this.name = this.determineName();
        executableBody = this.walkBody(o);
        if (this.parent instanceof Value && !this.parent.hasProperties()) {
          // Special handling to allow `class expr.A extends A` declarations
          parentName = this.parent.base.value;
        }
        this.hasNameClash = this.name != null && this.name === parentName;
        node = this;
        if (executableBody || this.hasNameClash) {
          node = new ExecutableClassBody(node, executableBody);
        } else if (this.name == null && o.level === LEVEL_TOP) {
          // Anonymous classes are only valid in expressions
          node = new Parens(node);
        }
        if (this.boundMethods.length && this.parent) {
          if (this.variable == null) {
            this.variable = new IdentifierLiteral(o.scope.freeVariable('_class'));
          }
          if (this.variableRef == null) {
            [this.variable, this.variableRef] = this.variable.cache(o);
          }
        }
        if (this.variable) {
          node = new Assign(this.variable, node, null, {
            moduleDeclaration: this.moduleDeclaration
          });
        }
        this.compileNode = this.compileClassDeclaration;
        try {
          return node.compileToFragments(o);
        } finally {
          delete this.compileNode;
        }
      }
      compileClassDeclaration(o) {
        var ref1, ref2, result;
        if (this.externalCtor || this.boundMethods.length) {
          if (this.ctor == null) {
            this.ctor = this.makeDefaultConstructor();
          }
        }
        if ((ref1 = this.ctor) != null) {
          ref1.noReturn = true;
        }
        if (this.boundMethods.length) {
          this.proxyBoundMethods();
        }
        o.indent += TAB;
        result = [];
        result.push(this.makeCode("class "));
        if (this.name) {
          result.push(this.makeCode(this.name));
        }
        if (((ref2 = this.variable) != null ? ref2.comments : void 0) != null) {
          this.compileCommentFragments(o, this.variable, result);
        }
        if (this.name) {
          result.push(this.makeCode(' '));
        }
        if (this.parent) {
          result.push(this.makeCode('extends '), ...this.parent.compileToFragments(o), this.makeCode(' '));
        }
        result.push(this.makeCode('{'));
        if (!this.body.isEmpty()) {
          this.body.spaced = true;
          result.push(this.makeCode('\n'));
          result.push(...this.body.compileToFragments(o, LEVEL_TOP));
          result.push(this.makeCode(`\n${this.tab}`));
        }
        result.push(this.makeCode('}'));
        return result;
      }

      // Figure out the appropriate name for this class
      determineName() {
        var message, name, node, ref1, tail;
        if (!this.variable) {
          return null;
        }
        ref1 = this.variable.properties, [tail] = slice1.call(ref1, -1);
        node = tail ? tail instanceof Access && tail.name : this.variable.base;
        if (!(node instanceof IdentifierLiteral || node instanceof PropertyName)) {
          return null;
        }
        name = node.value;
        if (!tail) {
          message = isUnassignable(name);
          if (message) {
            this.variable.error(message);
          }
        }
        if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
          return `_${name}`;
        } else {
          return name;
        }
      }
      walkBody(o) {
        var assign, end, executableBody, expression, expressions, exprs, i, initializer, initializerExpression, j, k, len1, len2, method, properties, pushSlice, ref1, start;
        this.ctor = null;
        this.boundMethods = [];
        executableBody = null;
        initializer = [];
        ({
          expressions
        } = this.body);
        i = 0;
        ref1 = expressions.slice();
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          expression = ref1[j];
          if (expression instanceof Value && expression.isObject(true)) {
            ({
              properties
            } = expression.base);
            exprs = [];
            end = 0;
            start = 0;
            pushSlice = function () {
              if (end > start) {
                return exprs.push(new Value(new Obj(properties.slice(start, end), true)));
              }
            };
            while (assign = properties[end]) {
              if (initializerExpression = this.addInitializerExpression(assign, o)) {
                pushSlice();
                exprs.push(initializerExpression);
                initializer.push(initializerExpression);
                start = end + 1;
              }
              end++;
            }
            pushSlice();
            splice.apply(expressions, [i, i - i + 1].concat(exprs)), exprs;
            i += exprs.length;
          } else {
            if (initializerExpression = this.addInitializerExpression(expression, o)) {
              initializer.push(initializerExpression);
              expressions[i] = initializerExpression;
            }
            i += 1;
          }
        }
        for (k = 0, len2 = initializer.length; k < len2; k++) {
          method = initializer[k];
          if (method instanceof Code) {
            if (method.ctor) {
              if (this.ctor) {
                method.error('Cannot define more than one constructor in a class');
              }
              this.ctor = method;
            } else if (method.isStatic && method.bound) {
              method.context = this.name;
            } else if (method.bound) {
              this.boundMethods.push(method);
            }
          }
        }
        if (!o.compiling) {
          return;
        }
        if (initializer.length !== expressions.length) {
          this.body.expressions = function () {
            var l, len3, results1;
            results1 = [];
            for (l = 0, len3 = initializer.length; l < len3; l++) {
              expression = initializer[l];
              results1.push(expression.hoist());
            }
            return results1;
          }();
          return new Block(expressions);
        }
      }

      // Add an expression to the class initializer

      // This is the key method for determining whether an expression in a class
      // body should appear in the initializer or the executable body. If the given
      // `node` is valid in a class body the method will return a (new, modified,
      // or identical) node for inclusion in the class initializer, otherwise
      // nothing will be returned and the node will appear in the executable body.

      // At time of writing, only methods (instance and static) are valid in ES
      // class initializers. As new ES class features (such as class fields) reach
      // Stage 4, this method will need to be updated to support them. We
      // additionally allow `PassthroughLiteral`s (backticked expressions) in the
      // initializer as an escape hatch for ES features that are not implemented
      // (e.g. getters and setters defined via the `get` and `set` keywords as
      // opposed to the `Object.defineProperty` method).
      addInitializerExpression(node, o) {
        if (node.unwrapAll() instanceof PassthroughLiteral) {
          return node;
        } else if (this.validInitializerMethod(node)) {
          return this.addInitializerMethod(node);
        } else if (!o.compiling && this.validClassProperty(node)) {
          return this.addClassProperty(node);
        } else if (!o.compiling && this.validClassPrototypeProperty(node)) {
          return this.addClassPrototypeProperty(node);
        } else {
          return null;
        }
      }

      // Checks if the given node is a valid ES class initializer method.
      validInitializerMethod(node) {
        if (!(node instanceof Assign && node.value instanceof Code)) {
          return false;
        }
        if (node.context === 'object' && !node.variable.hasProperties()) {
          return true;
        }
        return node.variable.looksStatic(this.name) && (this.name || !node.value.bound);
      }

      // Returns a configured class initializer method
      addInitializerMethod(assign) {
        var isConstructor, method, methodName, operatorToken, variable;
        ({
          variable,
          value: method,
          operatorToken
        } = assign);
        method.isMethod = true;
        method.isStatic = variable.looksStatic(this.name);
        if (method.isStatic) {
          method.name = variable.properties[0];
        } else {
          methodName = variable.base;
          method.name = new (methodName.shouldCache() ? Index : Access)(methodName);
          method.name.updateLocationDataIfMissing(methodName.locationData);
          isConstructor = methodName instanceof StringLiteral ? methodName.originalValue === 'constructor' : methodName.value === 'constructor';
          if (isConstructor) {
            method.ctor = this.parent ? 'derived' : 'base';
          }
          if (method.bound && method.ctor) {
            method.error('Cannot define a constructor as a bound (fat arrow) function');
          }
        }
        method.operatorToken = operatorToken;
        return method;
      }
      validClassProperty(node) {
        if (!(node instanceof Assign)) {
          return false;
        }
        return node.variable.looksStatic(this.name);
      }
      addClassProperty(assign) {
        var operatorToken, staticClassName, value, variable;
        ({
          variable,
          value,
          operatorToken
        } = assign);
        ({
          staticClassName
        } = variable.looksStatic(this.name));
        return new ClassProperty({
          name: variable.properties[0],
          isStatic: true,
          staticClassName,
          value,
          operatorToken
        }).withLocationDataFrom(assign);
      }
      validClassPrototypeProperty(node) {
        if (!(node instanceof Assign)) {
          return false;
        }
        return node.context === 'object' && !node.variable.hasProperties();
      }
      addClassPrototypeProperty(assign) {
        var value, variable;
        ({
          variable,
          value
        } = assign);
        return new ClassPrototypeProperty({
          name: variable.base,
          value
        }).withLocationDataFrom(assign);
      }
      makeDefaultConstructor() {
        var applyArgs, applyCtor, ctor;
        ctor = this.addInitializerMethod(new Assign(new Value(new PropertyName('constructor')), new Code()));
        this.body.unshift(ctor);
        if (this.parent) {
          ctor.body.push(new SuperCall(new Super(), [new Splat(new IdentifierLiteral('arguments'))]));
        }
        if (this.externalCtor) {
          applyCtor = new Value(this.externalCtor, [new Access(new PropertyName('apply'))]);
          applyArgs = [new ThisLiteral(), new IdentifierLiteral('arguments')];
          ctor.body.push(new Call(applyCtor, applyArgs));
          ctor.body.makeReturn();
        }
        return ctor;
      }
      proxyBoundMethods() {
        var method, name;
        this.ctor.thisAssignments = function () {
          var j, len1, ref1, results1;
          ref1 = this.boundMethods;
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            method = ref1[j];
            if (this.parent) {
              method.classVariable = this.variableRef;
            }
            name = new Value(new ThisLiteral(), [method.name]);
            results1.push(new Assign(name, new Call(new Value(name, [new Access(new PropertyName('bind'))]), [new ThisLiteral()])));
          }
          return results1;
        }.call(this);
        return null;
      }
      declareName(o) {
        var alreadyDeclared, name, ref1;
        if (!((name = (ref1 = this.variable) != null ? ref1.unwrap() : void 0) instanceof IdentifierLiteral)) {
          return;
        }
        alreadyDeclared = o.scope.find(name.value);
        return name.isDeclaration = !alreadyDeclared;
      }
      isStatementAst() {
        return true;
      }
      astNode(o) {
        var argumentsNode, jumpNode, ref1;
        if (jumpNode = this.body.jumps()) {
          jumpNode.error('Class bodies cannot contain pure statements');
        }
        if (argumentsNode = this.body.contains(isLiteralArguments)) {
          argumentsNode.error("Class bodies shouldn't reference arguments");
        }
        this.declareName(o);
        this.name = this.determineName();
        this.body.isClassBody = true;
        if (this.hasGeneratedBody) {
          this.body.locationData = zeroWidthLocationDataFromEndLocation(this.locationData);
        }
        this.walkBody(o);
        sniffDirectives(this.body.expressions);
        if ((ref1 = this.ctor) != null) {
          ref1.noReturn = true;
        }
        return super.astNode(o);
      }
      astType(o) {
        if (o.level === LEVEL_TOP) {
          return 'ClassDeclaration';
        } else {
          return 'ClassExpression';
        }
      }
      astProperties(o) {
        var ref1, ref2, ref3, ref4;
        return {
          id: (ref1 = (ref2 = this.variable) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          superClass: (ref3 = (ref4 = this.parent) != null ? ref4.ast(o, LEVEL_PAREN) : void 0) != null ? ref3 : null,
          body: this.body.ast(o, LEVEL_TOP)
        };
      }
    }
    ;
    Class.prototype.children = ['variable', 'parent', 'body'];
    return Class;
  }.call(this);
  exports.ExecutableClassBody = ExecutableClassBody = function () {
    class ExecutableClassBody extends Base {
      constructor(_class, body1 = new Block()) {
        super();
        this.class = _class;
        this.body = body1;
      }
      compileNode(o) {
        var args, argumentsNode, directives, externalCtor, ident, jumpNode, klass, params, parent, ref1, wrapper;
        if (jumpNode = this.body.jumps()) {
          jumpNode.error('Class bodies cannot contain pure statements');
        }
        if (argumentsNode = this.body.contains(isLiteralArguments)) {
          argumentsNode.error("Class bodies shouldn't reference arguments");
        }
        params = [];
        args = [new ThisLiteral()];
        wrapper = new Code(params, this.body);
        klass = new Parens(new Call(new Value(wrapper, [new Access(new PropertyName('call'))]), args));
        this.body.spaced = true;
        o.classScope = wrapper.makeScope(o.scope);
        this.name = (ref1 = this.class.name) != null ? ref1 : o.classScope.freeVariable(this.defaultClassVariableName);
        ident = new IdentifierLiteral(this.name);
        directives = this.walkBody();
        this.setContext();
        if (this.class.hasNameClash) {
          parent = new IdentifierLiteral(o.classScope.freeVariable('superClass'));
          wrapper.params.push(new Param(parent));
          args.push(this.class.parent);
          this.class.parent = parent;
        }
        if (this.externalCtor) {
          externalCtor = new IdentifierLiteral(o.classScope.freeVariable('ctor', {
            reserve: false
          }));
          this.class.externalCtor = externalCtor;
          this.externalCtor.variable.base = externalCtor;
        }
        if (this.name !== this.class.name) {
          this.body.expressions.unshift(new Assign(new IdentifierLiteral(this.name), this.class));
        } else {
          this.body.expressions.unshift(this.class);
        }
        this.body.expressions.unshift(...directives);
        this.body.push(ident);
        return klass.compileToFragments(o);
      }

      // Traverse the class's children and:
      // - Hoist valid ES properties into `@properties`
      // - Hoist static assignments into `@properties`
      // - Convert invalid ES properties into class or prototype assignments
      walkBody() {
        var directives, expr, index;
        directives = [];
        index = 0;
        while (expr = this.body.expressions[index]) {
          if (!(expr instanceof Value && expr.isString())) {
            break;
          }
          if (expr.hoisted) {
            index++;
          } else {
            directives.push(...this.body.expressions.splice(index, 1));
          }
        }
        this.traverseChildren(false, child => {
          var cont, i, j, len1, node, ref1;
          if (child instanceof Class || child instanceof HoistTarget) {
            return false;
          }
          cont = true;
          if (child instanceof Block) {
            ref1 = child.expressions;
            for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
              node = ref1[i];
              if (node instanceof Value && node.isObject(true)) {
                cont = false;
                child.expressions[i] = this.addProperties(node.base.properties);
              } else if (node instanceof Assign && node.variable.looksStatic(this.name)) {
                node.value.isStatic = true;
              }
            }
            child.expressions = flatten(child.expressions);
          }
          return cont;
        });
        return directives;
      }
      setContext() {
        return this.body.traverseChildren(false, node => {
          if (node instanceof ThisLiteral) {
            return node.value = this.name;
          } else if (node instanceof Code && node.bound && (node.isStatic || !node.name)) {
            return node.context = this.name;
          }
        });
      }

      // Make class/prototype assignments for invalid ES properties
      addProperties(assigns) {
        var assign, base, name, prototype, result, value, variable;
        result = function () {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = assigns.length; j < len1; j++) {
            assign = assigns[j];
            variable = assign.variable;
            base = variable != null ? variable.base : void 0;
            value = assign.value;
            delete assign.context;
            if (base.value === 'constructor') {
              if (value instanceof Code) {
                base.error('constructors must be defined at the top level of a class body');
              }
              // The class scope is not available yet, so return the assignment to update later
              assign = this.externalCtor = new Assign(new Value(), value);
            } else if (!assign.variable.this) {
              name = base instanceof ComputedPropertyName ? new Index(base.value) : new (base.shouldCache() ? Index : Access)(base);
              prototype = new Access(new PropertyName('prototype'));
              variable = new Value(new ThisLiteral(), [prototype, name]);
              assign.variable = variable;
            } else if (assign.value instanceof Code) {
              assign.value.isStatic = true;
            }
            results1.push(assign);
          }
          return results1;
        }.call(this);
        return compact(result);
      }
    }
    ;
    ExecutableClassBody.prototype.children = ['class', 'body'];
    ExecutableClassBody.prototype.defaultClassVariableName = '_Class';
    return ExecutableClassBody;
  }.call(this);
  exports.ClassProperty = ClassProperty = function () {
    class ClassProperty extends Base {
      constructor({
        name: name1,
        isStatic,
        staticClassName: staticClassName1,
        value: value1,
        operatorToken: operatorToken1
      }) {
        super();
        this.name = name1;
        this.isStatic = isStatic;
        this.staticClassName = staticClassName1;
        this.value = value1;
        this.operatorToken = operatorToken1;
      }
      astProperties(o) {
        var ref1, ref2, ref3, ref4;
        return {
          key: this.name.ast(o, LEVEL_LIST),
          value: this.value.ast(o, LEVEL_LIST),
          static: !!this.isStatic,
          computed: this.name instanceof Index || this.name instanceof ComputedPropertyName,
          operator: (ref1 = (ref2 = this.operatorToken) != null ? ref2.value : void 0) != null ? ref1 : '=',
          staticClassName: (ref3 = (ref4 = this.staticClassName) != null ? ref4.ast(o) : void 0) != null ? ref3 : null
        };
      }
    }
    ;
    ClassProperty.prototype.children = ['name', 'value', 'staticClassName'];
    ClassProperty.prototype.isStatement = YES;
    return ClassProperty;
  }.call(this);
  exports.ClassPrototypeProperty = ClassPrototypeProperty = function () {
    class ClassPrototypeProperty extends Base {
      constructor({
        name: name1,
        value: value1
      }) {
        super();
        this.name = name1;
        this.value = value1;
      }
      astProperties(o) {
        return {
          key: this.name.ast(o, LEVEL_LIST),
          value: this.value.ast(o, LEVEL_LIST),
          computed: this.name instanceof ComputedPropertyName || this.name instanceof StringWithInterpolations
        };
      }
    }
    ;
    ClassPrototypeProperty.prototype.children = ['name', 'value'];
    ClassPrototypeProperty.prototype.isStatement = YES;
    return ClassPrototypeProperty;
  }.call(this);

  //### Import and Export
  exports.ModuleDeclaration = ModuleDeclaration = function () {
    class ModuleDeclaration extends Base {
      constructor(clause, source1, assertions) {
        super();
        this.clause = clause;
        this.source = source1;
        this.assertions = assertions;
        this.checkSource();
      }
      checkSource() {
        if (this.source != null && this.source instanceof StringWithInterpolations) {
          return this.source.error('the name of the module to be imported from must be an uninterpolated string');
        }
      }
      checkScope(o, moduleDeclarationType) {
        // TODO: would be appropriate to flag this error during AST generation (as
        // well as when compiling to JS). But `o.indent` isnt tracked during AST
        // generation, and there doesnt seem to be a current alternative way to track
        // whether were at the program top-level.
        if (o.indent.length !== 0) {
          return this.error(`${moduleDeclarationType} statements must be at top-level scope`);
        }
      }
      astAssertions(o) {
        var ref1;
        if (((ref1 = this.assertions) != null ? ref1.properties : void 0) != null) {
          return this.assertions.properties.map(assertion => {
            var end, left, loc, right, start;
            ({
              start,
              end,
              loc,
              left,
              right
            } = assertion.ast(o));
            return {
              type: 'ImportAttribute',
              start,
              end,
              loc,
              key: left,
              value: right
            };
          });
        } else {
          return [];
        }
      }
    }
    ;
    ModuleDeclaration.prototype.children = ['clause', 'source', 'assertions'];
    ModuleDeclaration.prototype.isStatement = YES;
    ModuleDeclaration.prototype.jumps = THIS;
    ModuleDeclaration.prototype.makeReturn = THIS;
    return ModuleDeclaration;
  }.call(this);
  exports.ImportDeclaration = ImportDeclaration = class ImportDeclaration extends ModuleDeclaration {
    compileNode(o) {
      var code, ref1;
      this.checkScope(o, 'import');
      o.importedSymbols = [];
      code = [];
      code.push(this.makeCode(`${this.tab}import `));
      if (this.clause != null) {
        code.push(...this.clause.compileNode(o));
      }
      if (((ref1 = this.source) != null ? ref1.value : void 0) != null) {
        if (this.clause !== null) {
          code.push(this.makeCode(' from '));
        }
        code.push(this.makeCode(this.source.value));
        if (this.assertions != null) {
          code.push(this.makeCode(' assert '));
          code.push(...this.assertions.compileToFragments(o));
        }
      }
      code.push(this.makeCode(';'));
      return code;
    }
    astNode(o) {
      o.importedSymbols = [];
      return super.astNode(o);
    }
    astProperties(o) {
      var ref1, ref2, ret;
      ret = {
        specifiers: (ref1 = (ref2 = this.clause) != null ? ref2.ast(o) : void 0) != null ? ref1 : [],
        source: this.source.ast(o),
        assertions: this.astAssertions(o)
      };
      if (this.clause) {
        ret.importKind = 'value';
      }
      return ret;
    }
  };
  exports.ImportClause = ImportClause = function () {
    class ImportClause extends Base {
      constructor(defaultBinding, namedImports) {
        super();
        this.defaultBinding = defaultBinding;
        this.namedImports = namedImports;
      }
      compileNode(o) {
        var code;
        code = [];
        if (this.defaultBinding != null) {
          code.push(...this.defaultBinding.compileNode(o));
          if (this.namedImports != null) {
            code.push(this.makeCode(', '));
          }
        }
        if (this.namedImports != null) {
          code.push(...this.namedImports.compileNode(o));
        }
        return code;
      }
      astNode(o) {
        var ref1, ref2;
        // The AST for `ImportClause` is the non-nested list of import specifiers
        // that will be the `specifiers` property of an `ImportDeclaration` AST
        return compact(flatten([(ref1 = this.defaultBinding) != null ? ref1.ast(o) : void 0, (ref2 = this.namedImports) != null ? ref2.ast(o) : void 0]));
      }
    }
    ;
    ImportClause.prototype.children = ['defaultBinding', 'namedImports'];
    return ImportClause;
  }.call(this);
  exports.ExportDeclaration = ExportDeclaration = class ExportDeclaration extends ModuleDeclaration {
    compileNode(o) {
      var code, ref1;
      this.checkScope(o, 'export');
      this.checkForAnonymousClassExport();
      code = [];
      code.push(this.makeCode(`${this.tab}export `));
      if (this instanceof ExportDefaultDeclaration) {
        code.push(this.makeCode('default '));
      }
      if (!(this instanceof ExportDefaultDeclaration) && (this.clause instanceof Assign || this.clause instanceof Class)) {
        code.push(this.makeCode('var '));
        this.clause.moduleDeclaration = 'export';
      }
      if (this.clause.body != null && this.clause.body instanceof Block) {
        code = code.concat(this.clause.compileToFragments(o, LEVEL_TOP));
      } else {
        code = code.concat(this.clause.compileNode(o));
      }
      if (((ref1 = this.source) != null ? ref1.value : void 0) != null) {
        code.push(this.makeCode(` from ${this.source.value}`));
        if (this.assertions != null) {
          code.push(this.makeCode(' assert '));
          code.push(...this.assertions.compileToFragments(o));
        }
      }
      code.push(this.makeCode(';'));
      return code;
    }

    // Prevent exporting an anonymous class; all exported members must be named
    checkForAnonymousClassExport() {
      if (!(this instanceof ExportDefaultDeclaration) && this.clause instanceof Class && !this.clause.variable) {
        return this.clause.error('anonymous classes cannot be exported');
      }
    }
    astNode(o) {
      this.checkForAnonymousClassExport();
      return super.astNode(o);
    }
  };
  exports.ExportNamedDeclaration = ExportNamedDeclaration = class ExportNamedDeclaration extends ExportDeclaration {
    astProperties(o) {
      var clauseAst, ref1, ref2, ret;
      ret = {
        source: (ref1 = (ref2 = this.source) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
        assertions: this.astAssertions(o),
        exportKind: 'value'
      };
      clauseAst = this.clause.ast(o);
      if (this.clause instanceof ExportSpecifierList) {
        ret.specifiers = clauseAst;
        ret.declaration = null;
      } else {
        ret.specifiers = [];
        ret.declaration = clauseAst;
      }
      return ret;
    }
  };
  exports.ExportDefaultDeclaration = ExportDefaultDeclaration = class ExportDefaultDeclaration extends ExportDeclaration {
    astProperties(o) {
      return {
        declaration: this.clause.ast(o),
        assertions: this.astAssertions(o)
      };
    }
  };
  exports.ExportAllDeclaration = ExportAllDeclaration = class ExportAllDeclaration extends ExportDeclaration {
    astProperties(o) {
      return {
        source: this.source.ast(o),
        assertions: this.astAssertions(o),
        exportKind: 'value'
      };
    }
  };
  exports.ModuleSpecifierList = ModuleSpecifierList = function () {
    class ModuleSpecifierList extends Base {
      constructor(specifiers) {
        super();
        this.specifiers = specifiers;
      }
      compileNode(o) {
        var code, compiledList, fragments, index, j, len1, specifier;
        code = [];
        o.indent += TAB;
        compiledList = function () {
          var j, len1, ref1, results1;
          ref1 = this.specifiers;
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            specifier = ref1[j];
            results1.push(specifier.compileToFragments(o, LEVEL_LIST));
          }
          return results1;
        }.call(this);
        if (this.specifiers.length !== 0) {
          code.push(this.makeCode(`{\n${o.indent}`));
          for (index = j = 0, len1 = compiledList.length; j < len1; index = ++j) {
            fragments = compiledList[index];
            if (index) {
              code.push(this.makeCode(`,\n${o.indent}`));
            }
            code.push(...fragments);
          }
          code.push(this.makeCode("\n}"));
        } else {
          code.push(this.makeCode('{}'));
        }
        return code;
      }
      astNode(o) {
        var j, len1, ref1, results1, specifier;
        ref1 = this.specifiers;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          specifier = ref1[j];
          results1.push(specifier.ast(o));
        }
        return results1;
      }
    }
    ;
    ModuleSpecifierList.prototype.children = ['specifiers'];
    return ModuleSpecifierList;
  }.call(this);
  exports.ImportSpecifierList = ImportSpecifierList = class ImportSpecifierList extends ModuleSpecifierList {};
  exports.ExportSpecifierList = ExportSpecifierList = class ExportSpecifierList extends ModuleSpecifierList {};
  exports.ModuleSpecifier = ModuleSpecifier = function () {
    class ModuleSpecifier extends Base {
      constructor(original, alias, moduleDeclarationType1) {
        var ref1, ref2;
        super();
        this.original = original;
        this.alias = alias;
        this.moduleDeclarationType = moduleDeclarationType1;
        if (this.original.comments || ((ref1 = this.alias) != null ? ref1.comments : void 0)) {
          this.comments = [];
          if (this.original.comments) {
            this.comments.push(...this.original.comments);
          }
          if ((ref2 = this.alias) != null ? ref2.comments : void 0) {
            this.comments.push(...this.alias.comments);
          }
        }
        // The name of the variable entering the local scope
        this.identifier = this.alias != null ? this.alias.value : this.original.value;
      }
      compileNode(o) {
        var code;
        this.addIdentifierToScope(o);
        code = [];
        code.push(this.makeCode(this.original.value));
        if (this.alias != null) {
          code.push(this.makeCode(` as ${this.alias.value}`));
        }
        return code;
      }
      addIdentifierToScope(o) {
        return o.scope.find(this.identifier, this.moduleDeclarationType);
      }
      astNode(o) {
        this.addIdentifierToScope(o);
        return super.astNode(o);
      }
    }
    ;
    ModuleSpecifier.prototype.children = ['original', 'alias'];
    return ModuleSpecifier;
  }.call(this);
  exports.ImportSpecifier = ImportSpecifier = class ImportSpecifier extends ModuleSpecifier {
    constructor(imported, local) {
      super(imported, local, 'import');
    }
    addIdentifierToScope(o) {
      var ref1;
      // Per the spec, symbols cant be imported multiple times
      // (e.g. `import { foo, foo } from 'lib'` is invalid)
      if ((ref1 = this.identifier, indexOf.call(o.importedSymbols, ref1) >= 0) || o.scope.check(this.identifier)) {
        this.error(`'${this.identifier}' has already been declared`);
      } else {
        o.importedSymbols.push(this.identifier);
      }
      return super.addIdentifierToScope(o);
    }
    astProperties(o) {
      var originalAst, ref1, ref2;
      originalAst = this.original.ast(o);
      return {
        imported: originalAst,
        local: (ref1 = (ref2 = this.alias) != null ? ref2.ast(o) : void 0) != null ? ref1 : originalAst,
        importKind: null
      };
    }
  };
  exports.ImportDefaultSpecifier = ImportDefaultSpecifier = class ImportDefaultSpecifier extends ImportSpecifier {
    astProperties(o) {
      return {
        local: this.original.ast(o)
      };
    }
  };
  exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier = class ImportNamespaceSpecifier extends ImportSpecifier {
    astProperties(o) {
      return {
        local: this.alias.ast(o)
      };
    }
  };
  exports.ExportSpecifier = ExportSpecifier = class ExportSpecifier extends ModuleSpecifier {
    constructor(local, exported) {
      super(local, exported, 'export');
    }
    astProperties(o) {
      var originalAst, ref1, ref2;
      originalAst = this.original.ast(o);
      return {
        local: originalAst,
        exported: (ref1 = (ref2 = this.alias) != null ? ref2.ast(o) : void 0) != null ? ref1 : originalAst
      };
    }
  };
  exports.DynamicImport = DynamicImport = class DynamicImport extends Base {
    compileNode() {
      return [this.makeCode('import')];
    }
    astType() {
      return 'Import';
    }
  };
  exports.DynamicImportCall = DynamicImportCall = class DynamicImportCall extends Call {
    compileNode(o) {
      this.checkArguments();
      return super.compileNode(o);
    }
    checkArguments() {
      var ref1;
      if (!(1 <= (ref1 = this.args.length) && ref1 <= 2)) {
        return this.error('import() accepts either one or two arguments');
      }
    }
    astNode(o) {
      this.checkArguments();
      return super.astNode(o);
    }
  };

  //### Assign

  // The **Assign** is used to assign a local variable to value, or to set the
  // property of an object -- including within object literals.
  exports.Assign = Assign = function () {
    class Assign extends Base {
      constructor(variable1, value1, context1, options = {}) {
        super();
        this.variable = variable1;
        this.value = value1;
        this.context = context1;
        ({
          param: this.param,
          subpattern: this.subpattern,
          operatorToken: this.operatorToken,
          moduleDeclaration: this.moduleDeclaration,
          originalContext: this.originalContext = this.context
        } = options);
        this.propagateLhs();
      }
      isStatement(o) {
        return (o != null ? o.level : void 0) === LEVEL_TOP && this.context != null && (this.moduleDeclaration || indexOf.call(this.context, "?") >= 0);
      }
      checkNameAssignability(o, varBase) {
        if (o.scope.type(varBase.value) === 'import') {
          return varBase.error(`'${varBase.value}' is read-only`);
        }
      }
      assigns(name) {
        return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);
      }
      unfoldSoak(o) {
        return unfoldSoak(o, this, 'variable');
      }

      // During AST generation, we need to allow assignment to these constructs
      // that are considered unassignable during compile-to-JS, while still
      // flagging things like `[null] = b`.
      addScopeVariables(o, {
        allowAssignmentToExpansion = false,
        allowAssignmentToNontrailingSplat = false,
        allowAssignmentToEmptyArray = false,
        allowAssignmentToComplexSplat = false
      } = {}) {
        var varBase;
        if (!(!this.context || this.context === '**=')) {
          return;
        }
        varBase = this.variable.unwrapAll();
        if (!varBase.isAssignable({
          allowExpansion: allowAssignmentToExpansion,
          allowNontrailingSplat: allowAssignmentToNontrailingSplat,
          allowEmptyArray: allowAssignmentToEmptyArray,
          allowComplexSplat: allowAssignmentToComplexSplat
        })) {
          this.variable.error(`'${this.variable.compile(o)}' can't be assigned`);
        }
        return varBase.eachName(name => {
          var alreadyDeclared, commentFragments, commentsNode, message;
          if (typeof name.hasProperties === "function" ? name.hasProperties() : void 0) {
            return;
          }
          message = isUnassignable(name.value);
          if (message) {
            name.error(message);
          }
          // `moduleDeclaration` can be `'import'` or `'export'`.
          this.checkNameAssignability(o, name);
          if (this.moduleDeclaration) {
            o.scope.add(name.value, this.moduleDeclaration);
            return name.isDeclaration = true;
          } else if (this.param) {
            return o.scope.add(name.value, this.param === 'alwaysDeclare' ? 'var' : 'param');
          } else {
            alreadyDeclared = o.scope.find(name.value);
            if (name.isDeclaration == null) {
              name.isDeclaration = !alreadyDeclared;
            }
            // If this assignment identifier has one or more herecomments
            // attached, output them as part of the declarations line (unless
            // other herecomments are already staged there) for compatibility
            // with Flow typing. Dont do this if this assignment is for a
            // class, e.g. `ClassName = class ClassName {`, as Flow requires
            // the comment to be between the class name and the `{`.
            if (name.comments && !o.scope.comments[name.value] && !(this.value instanceof Class) && name.comments.every(function (comment) {
              return comment.here && !comment.multiline;
            })) {
              commentsNode = new IdentifierLiteral(name.value);
              commentsNode.comments = name.comments;
              commentFragments = [];
              this.compileCommentFragments(o, commentsNode, commentFragments);
              return o.scope.comments[name.value] = commentFragments;
            }
          }
        });
      }

      // Compile an assignment, delegating to `compileDestructuring` or
      // `compileSplice` if appropriate. Keep track of the name of the base object
      // we've been assigned to, for correct internal references. If the variable
      // has not been seen yet within the current scope, declare it.
      compileNode(o) {
        var answer, compiledName, isValue, name, properties, prototype, ref1, ref2, ref3, ref4, val;
        isValue = this.variable instanceof Value;
        if (isValue) {
          // If `@variable` is an array or an object, were destructuring;
          // if its also `isAssignable()`, the destructuring syntax is supported
          // in ES and we can output it as is; otherwise we `@compileDestructuring`
          // and convert this ES-unsupported destructuring into acceptable output.
          if (this.variable.isArray() || this.variable.isObject()) {
            if (!this.variable.isAssignable()) {
              if (this.variable.isObject() && this.variable.base.hasSplat()) {
                return this.compileObjectDestruct(o);
              } else {
                return this.compileDestructuring(o);
              }
            }
          }
          if (this.variable.isSplice()) {
            return this.compileSplice(o);
          }
          if (this.isConditional()) {
            return this.compileConditional(o);
          }
          if ((ref1 = this.context) === '//=' || ref1 === '%%=') {
            return this.compileSpecialMath(o);
          }
        }
        this.addScopeVariables(o);
        if (this.value instanceof Code) {
          if (this.value.isStatic) {
            this.value.name = this.variable.properties[0];
          } else if (((ref2 = this.variable.properties) != null ? ref2.length : void 0) >= 2) {
            ref3 = this.variable.properties, [...properties] = ref3, [prototype, name] = splice.call(properties, -2);
            if (((ref4 = prototype.name) != null ? ref4.value : void 0) === 'prototype') {
              this.value.name = name;
            }
          }
        }
        val = this.value.compileToFragments(o, LEVEL_LIST);
        compiledName = this.variable.compileToFragments(o, LEVEL_LIST);
        if (this.context === 'object') {
          if (this.variable.shouldCache()) {
            compiledName.unshift(this.makeCode('['));
            compiledName.push(this.makeCode(']'));
          }
          return compiledName.concat(this.makeCode(': '), val);
        }
        answer = compiledName.concat(this.makeCode(` ${this.context || '='} `), val);
        // Per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Assignment_without_declaration,
        // if were destructuring without declaring, the destructuring assignment must be wrapped in parentheses.
        // The assignment is wrapped in parentheses if 'o.level' has lower precedence than LEVEL_LIST (3)
        // (i.e. LEVEL_COND (4), LEVEL_OP (5) or LEVEL_ACCESS (6)), or if we're destructuring object, e.g. {a,b} = obj.
        if (o.level > LEVEL_LIST || isValue && this.variable.base instanceof Obj && !this.nestedLhs && !(this.param === true)) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }

      // Object rest property is not assignable: `{{a}...}`
      compileObjectDestruct(o) {
        var assigns, props, refVal, splat, splatProp;
        this.variable.base.reorderProperties();
        ({
          properties: props
        } = this.variable.base);
        [splat] = slice1.call(props, -1);
        splatProp = splat.name;
        assigns = [];
        refVal = new Value(new IdentifierLiteral(o.scope.freeVariable('ref')));
        props.splice(-1, 1, new Splat(refVal));
        assigns.push(new Assign(new Value(new Obj(props)), this.value).compileToFragments(o, LEVEL_LIST));
        assigns.push(new Assign(new Value(splatProp), refVal).compileToFragments(o, LEVEL_LIST));
        return this.joinFragmentArrays(assigns, ', ');
      }

      // Brief implementation of recursive pattern matching, when assigning array or
      // object literals to a value. Peeks at their properties to assign inner names.
      compileDestructuring(o) {
        var assignObjects, assigns, code, compSlice, compSplice, complexObjects, expIdx, expans, fragments, hasObjAssigns, isExpans, isSplat, leftObjs, loopObjects, obj, objIsUnassignable, objects, olen, processObjects, pushAssign, ref, refExp, restVar, rightObjs, slicer, splatVar, splatVarAssign, splatVarRef, splats, splatsAndExpans, top, value, vvar, vvarText;
        top = o.level === LEVEL_TOP;
        ({
          value
        } = this);
        ({
          objects
        } = this.variable.base);
        olen = objects.length;
        // Special-case for `{} = a` and `[] = a` (empty patterns).
        // Compile to simply `a`.
        if (olen === 0) {
          code = value.compileToFragments(o);
          if (o.level >= LEVEL_OP) {
            return this.wrapInParentheses(code);
          } else {
            return code;
          }
        }
        [obj] = objects;
        this.disallowLoneExpansion();
        ({
          splats,
          expans,
          splatsAndExpans
        } = this.getAndCheckSplatsAndExpansions());
        isSplat = (splats != null ? splats.length : void 0) > 0;
        isExpans = (expans != null ? expans.length : void 0) > 0;
        vvar = value.compileToFragments(o, LEVEL_LIST);
        vvarText = fragmentsToText(vvar);
        assigns = [];
        pushAssign = (variable, val) => {
          return assigns.push(new Assign(variable, val, null, {
            param: this.param,
            subpattern: true
          }).compileToFragments(o, LEVEL_LIST));
        };
        if (isSplat) {
          splatVar = objects[splats[0]].name.unwrap();
          if (splatVar instanceof Arr || splatVar instanceof Obj) {
            splatVarRef = new IdentifierLiteral(o.scope.freeVariable('ref'));
            objects[splats[0]].name = splatVarRef;
            splatVarAssign = function () {
              return pushAssign(new Value(splatVar), splatVarRef);
            };
          }
        }
        // At this point, there are several things to destructure. So the `fn()` in
        // `{a, b} = fn()` must be cached, for example. Make vvar into a simple
        // variable if it isnt already.
        if (!(value.unwrap() instanceof IdentifierLiteral) || this.variable.assigns(vvarText)) {
          ref = o.scope.freeVariable('ref');
          assigns.push([this.makeCode(ref + ' = '), ...vvar]);
          vvar = [this.makeCode(ref)];
          vvarText = ref;
        }
        slicer = function (type) {
          return function (vvar, start, end = false) {
            var args, slice;
            if (!(vvar instanceof Value)) {
              vvar = new IdentifierLiteral(vvar);
            }
            args = [vvar, new NumberLiteral(start)];
            if (end) {
              args.push(new NumberLiteral(end));
            }
            slice = new Value(new IdentifierLiteral(utility(type, o)), [new Access(new PropertyName('call'))]);
            return new Value(new Call(slice, args));
          };
        };
        // Helper which outputs `[].slice` code.
        compSlice = slicer("slice");
        // Helper which outputs `[].splice` code.
        compSplice = slicer("splice");
        // Check if `objects` array contains any instance of `Assign`, e.g. {a:1}.
        hasObjAssigns = function (objs) {
          var i, j, len1, results1;
          results1 = [];
          for (i = j = 0, len1 = objs.length; j < len1; i = ++j) {
            obj = objs[i];
            if (obj instanceof Assign && obj.context === 'object') {
              results1.push(i);
            }
          }
          return results1;
        };
        // Check if `objects` array contains any unassignable object.
        objIsUnassignable = function (objs) {
          var j, len1;
          for (j = 0, len1 = objs.length; j < len1; j++) {
            obj = objs[j];
            if (!obj.isAssignable()) {
              return true;
            }
          }
          return false;
        };
        // `objects` are complex when there is object assign ({a:1}),
        // unassignable object, or just a single node.
        complexObjects = function (objs) {
          return hasObjAssigns(objs).length || objIsUnassignable(objs) || olen === 1;
        };
        // "Complex" `objects` are processed in a loop.
        // Examples: [a, b, {c, r...}, d], [a, ..., {b, r...}, c, d]
        loopObjects = (objs, vvar, vvarTxt) => {
          var acc, i, idx, j, len1, message, results1, vval;
          results1 = [];
          for (i = j = 0, len1 = objs.length; j < len1; i = ++j) {
            obj = objs[i];
            if (obj instanceof Elision) {
              // `Elision` can be skipped.
              continue;
            }
            // If `obj` is {a: 1}
            if (obj instanceof Assign && obj.context === 'object') {
              ({
                variable: {
                  base: idx
                },
                value: vvar
              } = obj);
              if (vvar instanceof Assign) {
                ({
                  variable: vvar
                } = vvar);
              }
              idx = vvar.this ? vvar.properties[0].name : new PropertyName(vvar.unwrap().value);
              acc = idx.unwrap() instanceof PropertyName;
              vval = new Value(value, [new (acc ? Access : Index)(idx)]);
            } else {
              // `obj` is [a...], {a...} or a
              vvar = function () {
                switch (false) {
                  case !(obj instanceof Splat):
                    return new Value(obj.name);
                  default:
                    return obj;
                }
              }();
              vval = function () {
                switch (false) {
                  case !(obj instanceof Splat):
                    return compSlice(vvarTxt, i);
                  default:
                    return new Value(new Literal(vvarTxt), [new Index(new NumberLiteral(i))]);
                }
              }();
            }
            message = isUnassignable(vvar.unwrap().value);
            if (message) {
              vvar.error(message);
            }
            results1.push(pushAssign(vvar, vval));
          }
          return results1;
        };
        // "Simple" `objects` can be split and compiled to arrays, [a, b, c] = arr, [a, b, c...] = arr
        assignObjects = (objs, vvar, vvarTxt) => {
          var vval;
          vvar = new Value(new Arr(objs, true));
          vval = vvarTxt instanceof Value ? vvarTxt : new Value(new Literal(vvarTxt));
          return pushAssign(vvar, vval);
        };
        processObjects = function (objs, vvar, vvarTxt) {
          if (complexObjects(objs)) {
            return loopObjects(objs, vvar, vvarTxt);
          } else {
            return assignObjects(objs, vvar, vvarTxt);
          }
        };
        // In case there is `Splat` or `Expansion` in `objects`,
        // we can split array in two simple subarrays.
        // `Splat` [a, b, c..., d, e] can be split into  [a, b, c...] and [d, e].
        // `Expansion` [a, b, ..., c, d] can be split into [a, b] and [c, d].
        // Examples:
        // a) `Splat`
        //   CS: [a, b, c..., d, e] = arr
        //   JS: [a, b, ...c] = arr, [d, e] = splice.call(c, -2)
        // b) `Expansion`
        //   CS: [a, b, ..., d, e] = arr
        //   JS: [a, b] = arr, [d, e] = slice.call(arr, -2)
        if (splatsAndExpans.length) {
          expIdx = splatsAndExpans[0];
          leftObjs = objects.slice(0, expIdx + (isSplat ? 1 : 0));
          rightObjs = objects.slice(expIdx + 1);
          if (leftObjs.length !== 0) {
            processObjects(leftObjs, vvar, vvarText);
          }
          if (rightObjs.length !== 0) {
            // Slice or splice `objects`.
            refExp = function () {
              switch (false) {
                case !isSplat:
                  return compSplice(new Value(objects[expIdx].name), rightObjs.length * -1);
                case !isExpans:
                  return compSlice(vvarText, rightObjs.length * -1);
              }
            }();
            if (complexObjects(rightObjs)) {
              restVar = refExp;
              refExp = o.scope.freeVariable('ref');
              assigns.push([this.makeCode(refExp + ' = '), ...restVar.compileToFragments(o, LEVEL_LIST)]);
            }
            processObjects(rightObjs, vvar, refExp);
          }
        } else {
          // There is no `Splat` or `Expansion` in `objects`.
          processObjects(objects, vvar, vvarText);
        }
        if (typeof splatVarAssign === "function") {
          splatVarAssign();
        }
        if (!(top || this.subpattern)) {
          assigns.push(vvar);
        }
        fragments = this.joinFragmentArrays(assigns, ', ');
        if (o.level < LEVEL_LIST) {
          return fragments;
        } else {
          return this.wrapInParentheses(fragments);
        }
      }

      // Disallow `[...] = a` for some reason. (Could be equivalent to `[] = a`?)
      disallowLoneExpansion() {
        var loneObject, objects;
        if (!(this.variable.base instanceof Arr)) {
          return;
        }
        ({
          objects
        } = this.variable.base);
        if ((objects != null ? objects.length : void 0) !== 1) {
          return;
        }
        [loneObject] = objects;
        if (loneObject instanceof Expansion) {
          return loneObject.error('Destructuring assignment has no target');
        }
      }

      // Show error if there is more than one `Splat`, or `Expansion`.
      // Examples: [a, b, c..., d, e, f...], [a, b, ..., c, d, ...], [a, b, ..., c, d, e...]
      getAndCheckSplatsAndExpansions() {
        var expans, i, obj, objects, splats, splatsAndExpans;
        if (!(this.variable.base instanceof Arr)) {
          return {
            splats: [],
            expans: [],
            splatsAndExpans: []
          };
        }
        ({
          objects
        } = this.variable.base);
        // Count all `Splats`: [a, b, c..., d, e]
        splats = function () {
          var j, len1, results1;
          results1 = [];
          for (i = j = 0, len1 = objects.length; j < len1; i = ++j) {
            obj = objects[i];
            if (obj instanceof Splat) {
              results1.push(i);
            }
          }
          return results1;
        }();
        // Count all `Expansions`: [a, b, ..., c, d]
        expans = function () {
          var j, len1, results1;
          results1 = [];
          for (i = j = 0, len1 = objects.length; j < len1; i = ++j) {
            obj = objects[i];
            if (obj instanceof Expansion) {
              results1.push(i);
            }
          }
          return results1;
        }();
        // Combine splats and expansions.
        splatsAndExpans = [...splats, ...expans];
        if (splatsAndExpans.length > 1) {
          // Sort 'splatsAndExpans' so we can show error at first disallowed token.
          objects[splatsAndExpans.sort()[1]].error("multiple splats/expansions are disallowed in an assignment");
        }
        return {
          splats,
          expans,
          splatsAndExpans
        };
      }

      // When compiling a conditional assignment, take care to ensure that the
      // operands are only evaluated once, even though we have to reference them
      // more than once.
      compileConditional(o) {
        var fragments, left, right;
        [left, right] = this.variable.cacheReference(o);
        // Disallow conditional assignment of undefined variables.
        if (!left.properties.length && left.base instanceof Literal && !(left.base instanceof ThisLiteral) && !o.scope.check(left.base.value)) {
          this.throwUnassignableConditionalError(left.base.value);
        }
        if (indexOf.call(this.context, "?") >= 0) {
          o.isExistentialEquals = true;
          return new If(new Existence(left), right, {
            type: 'if'
          }).addElse(new Assign(right, this.value, '=')).compileToFragments(o);
        } else {
          fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, '=')).compileToFragments(o);
          if (o.level <= LEVEL_LIST) {
            return fragments;
          } else {
            return this.wrapInParentheses(fragments);
          }
        }
      }

      // Convert special math assignment operators like `a //= b` to the equivalent
      // extended form `a = a ** b` and then compiles that.
      compileSpecialMath(o) {
        var left, right;
        [left, right] = this.variable.cacheReference(o);
        return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);
      }

      // Compile the assignment from an array splice literal, using JavaScript's
      // `Array#splice` method.
      compileSplice(o) {
        var answer, exclusive, from, fromDecl, fromRef, name, to, unwrappedVar, valDef, valRef;
        ({
          range: {
            from,
            to,
            exclusive
          }
        } = this.variable.properties.pop());
        unwrappedVar = this.variable.unwrapAll();
        if (unwrappedVar.comments) {
          moveComments(unwrappedVar, this);
          delete this.variable.comments;
        }
        name = this.variable.compile(o);
        if (from) {
          [fromDecl, fromRef] = this.cacheToCodeFragments(from.cache(o, LEVEL_OP));
        } else {
          fromDecl = fromRef = '0';
        }
        if (to) {
          if ((from != null ? from.isNumber() : void 0) && to.isNumber()) {
            to = to.compile(o) - fromRef;
            if (!exclusive) {
              to += 1;
            }
          } else {
            to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;
            if (!exclusive) {
              to += ' + 1';
            }
          }
        } else {
          to = "9e9";
        }
        [valDef, valRef] = this.value.cache(o, LEVEL_LIST);
        answer = [].concat(this.makeCode(`${utility('splice', o)}.apply(${name}, [${fromDecl}, ${to}].concat(`), valDef, this.makeCode(")), "), valRef);
        if (o.level > LEVEL_TOP) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }
      eachName(iterator) {
        return this.variable.unwrapAll().eachName(iterator);
      }
      isDefaultAssignment() {
        return this.param || this.nestedLhs;
      }
      propagateLhs() {
        var ref1, ref2;
        if (!(((ref1 = this.variable) != null ? typeof ref1.isArray === "function" ? ref1.isArray() : void 0 : void 0) || ((ref2 = this.variable) != null ? typeof ref2.isObject === "function" ? ref2.isObject() : void 0 : void 0))) {
          return;
        }
        // This is the left-hand side of an assignment; let `Arr` and `Obj`
        // know that, so that those nodes know that theyre assignable as
        // destructured variables.
        return this.variable.base.propagateLhs(true);
      }
      throwUnassignableConditionalError(name) {
        return this.variable.error(`the variable \"${name}\" can't be assigned with ${this.context} because it has not been declared before`);
      }
      isConditional() {
        var ref1;
        return (ref1 = this.context) === '||=' || ref1 === '&&=' || ref1 === '?=';
      }
      astNode(o) {
        var variable;
        this.disallowLoneExpansion();
        this.getAndCheckSplatsAndExpansions();
        if (this.isConditional()) {
          variable = this.variable.unwrap();
          if (variable instanceof IdentifierLiteral && !o.scope.check(variable.value)) {
            this.throwUnassignableConditionalError(variable.value);
          }
        }
        this.addScopeVariables(o, {
          allowAssignmentToExpansion: true,
          allowAssignmentToNontrailingSplat: true,
          allowAssignmentToEmptyArray: true,
          allowAssignmentToComplexSplat: true
        });
        return super.astNode(o);
      }
      astType() {
        if (this.isDefaultAssignment()) {
          return 'AssignmentPattern';
        } else {
          return 'AssignmentExpression';
        }
      }
      astProperties(o) {
        var ref1, ret;
        ret = {
          right: this.value.ast(o, LEVEL_LIST),
          left: this.variable.ast(o, LEVEL_LIST)
        };
        if (!this.isDefaultAssignment()) {
          ret.operator = (ref1 = this.originalContext) != null ? ref1 : '=';
        }
        return ret;
      }
    }
    ;
    Assign.prototype.children = ['variable', 'value'];
    Assign.prototype.isAssignable = YES;
    Assign.prototype.isStatementAst = NO;
    return Assign;
  }.call(this);

  //### FuncGlyph
  exports.FuncGlyph = FuncGlyph = class FuncGlyph extends Base {
    constructor(glyph) {
      super();
      this.glyph = glyph;
    }
  };

  //### Code

  // A function definition. This is the only node that creates a new Scope.
  // When for the purposes of walking the contents of a function body, the Code
  // has no *children* -- they're within the inner scope.
  exports.Code = Code = function () {
    class Code extends Base {
      constructor(params, body, funcGlyph, paramStart) {
        var ref1;
        super();
        this.funcGlyph = funcGlyph;
        this.paramStart = paramStart;
        this.params = params || [];
        this.body = body || new Block();
        this.bound = ((ref1 = this.funcGlyph) != null ? ref1.glyph : void 0) === '=>';
        this.isGenerator = false;
        this.isAsync = false;
        this.isMethod = false;
        this.body.traverseChildren(false, node => {
          if (node instanceof Op && node.isYield() || node instanceof YieldReturn) {
            this.isGenerator = true;
          }
          if (node instanceof Op && node.isAwait() || node instanceof AwaitReturn) {
            this.isAsync = true;
          }
          if (node instanceof For && node.isAwait()) {
            return this.isAsync = true;
          }
        });
        this.propagateLhs();
      }
      isStatement() {
        return this.isMethod;
      }
      makeScope(parentScope) {
        return new Scope(parentScope, this.body, this);
      }

      // Compilation creates a new scope unless explicitly asked to share with the
      // outer scope. Handles splat parameters in the parameter list by setting
      // such parameters to be the final parameter in the function definition, as
      // required per the ES2015 spec. If the CoffeeScript function definition had
      // parameters after the splat, they are declared via expressions in the
      // function body.
      compileNode(o) {
        var answer, body, boundMethodCheck, comment, condition, exprs, generatedVariables, haveBodyParam, haveSplatParam, i, ifTrue, j, k, l, len1, len2, len3, m, methodScope, modifiers, name, param, paramToAddToScope, params, paramsAfterSplat, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, scopeVariablesCount, signature, splatParamName, thisAssignments, wasEmpty, yieldNode;
        this.checkForAsyncOrGeneratorConstructor();
        if (this.bound) {
          if ((ref1 = o.scope.method) != null ? ref1.bound : void 0) {
            this.context = o.scope.method.context;
          }
          if (!this.context) {
            this.context = 'this';
          }
        }
        this.updateOptions(o);
        params = [];
        exprs = [];
        thisAssignments = (ref2 = (ref3 = this.thisAssignments) != null ? ref3.slice() : void 0) != null ? ref2 : [];
        paramsAfterSplat = [];
        haveSplatParam = false;
        haveBodyParam = false;
        this.checkForDuplicateParams();
        this.disallowLoneExpansionAndMultipleSplats();
        // Separate `this` assignments.
        this.eachParamName(function (name, node, param, obj) {
          var replacement, target;
          if (node.this) {
            name = node.properties[0].name.value;
            if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
              name = `_${name}`;
            }
            target = new IdentifierLiteral(o.scope.freeVariable(name, {
              reserve: false
            }));
            // `Param` is object destructuring with a default value: ({@prop = 1}) ->
            // In a case when the variable name is already reserved, we have to assign
            // a new variable name to the destructured variable: ({prop:prop1 = 1}) ->
            replacement = param.name instanceof Obj && obj instanceof Assign && obj.operatorToken.value === '=' ? new Assign(new IdentifierLiteral(name), target, 'object') : target; //, operatorToken: new Literal ':'
            param.renameParam(node, replacement);
            return thisAssignments.push(new Assign(node, target));
          }
        });
        ref4 = this.params;
        // Parse the parameters, adding them to the list of parameters to put in the
        // function definition; and dealing with splats or expansions, including
        // adding expressions to the function body to declare all parameter
        // variables that would have been after the splat/expansion parameter.
        // If we encounter a parameter that needs to be declared in the function
        // body for any reason, for example its destructured with `this`, also
        // declare and assign all subsequent parameters in the function body so that
        // any non-idempotent parameters are evaluated in the correct order.
        for (i = j = 0, len1 = ref4.length; j < len1; i = ++j) {
          param = ref4[i];
          // Was `...` used with this parameter? Splat/expansion parameters cannot
          // have default values, so we need not worry about that.
          if (param.splat || param instanceof Expansion) {
            haveSplatParam = true;
            if (param.splat) {
              if (param.name instanceof Arr || param.name instanceof Obj) {
                // Splat arrays are treated oddly by ES; deal with them the legacy
                // way in the function body. TODO: Should this be handled in the
                // function parameter list, and if so, how?
                splatParamName = o.scope.freeVariable('arg');
                params.push(ref = new Value(new IdentifierLiteral(splatParamName)));
                exprs.push(new Assign(new Value(param.name), ref));
              } else {
                params.push(ref = param.asReference(o));
                splatParamName = fragmentsToText(ref.compileNodeWithoutComments(o));
              }
              if (param.shouldCache()) {
                exprs.push(new Assign(new Value(param.name), ref)); // `param` is an Expansion
              }
            } else {
              splatParamName = o.scope.freeVariable('args');
              params.push(new Value(new IdentifierLiteral(splatParamName)));
            }
            o.scope.parameter(splatParamName);
          } else {
            // Parse all other parameters; if a splat paramater has not yet been
            // encountered, add these other parameters to the list to be output in
            // the function definition.
            if (param.shouldCache() || haveBodyParam) {
              param.assignedInBody = true;
              haveBodyParam = true;
              // This parameter cannot be declared or assigned in the parameter
              // list. So put a reference in the parameter list and add a statement
              // to the function body assigning it, e.g.
              // `(arg) => { var a = arg.a; }`, with a default value if it has one.
              if (param.value != null) {
                condition = new Op('===', param, new UndefinedLiteral());
                ifTrue = new Assign(new Value(param.name), param.value);
                exprs.push(new If(condition, ifTrue));
              } else {
                exprs.push(new Assign(new Value(param.name), param.asReference(o), null, {
                  param: 'alwaysDeclare'
                }));
              }
            }
            // If this parameter comes before the splat or expansion, it will go
            // in the function definition parameter list.
            if (!haveSplatParam) {
              // If this parameter has a default value, and it hasnt already been
              // set by the `shouldCache()` block above, define it as a statement in
              // the function body. This parameter comes after the splat parameter,
              // so we cant define its default value in the parameter list.
              if (param.shouldCache()) {
                ref = param.asReference(o);
              } else {
                if (param.value != null && !param.assignedInBody) {
                  ref = new Assign(new Value(param.name), param.value, null, {
                    param: true
                  });
                } else {
                  ref = param;
                }
              }
              // Add this parameters reference(s) to the function scope.
              if (param.name instanceof Arr || param.name instanceof Obj) {
                // This parameter is destructured.
                param.name.lhs = true;
                if (!param.shouldCache()) {
                  param.name.eachName(function (prop) {
                    return o.scope.parameter(prop.value);
                  });
                }
              } else {
                // This compilation of the parameter is only to get its name to add
                // to the scope name tracking; since the compilation output here
                // isnt kept for eventual output, dont include comments in this
                // compilation, so that they get output the real time this param
                // is compiled.
                paramToAddToScope = param.value != null ? param : ref;
                o.scope.parameter(fragmentsToText(paramToAddToScope.compileToFragmentsWithoutComments(o)));
              }
              params.push(ref);
            } else {
              paramsAfterSplat.push(param);
              // If this parameter had a default value, since its no longer in the
              // function parameter list we need to assign its default value
              // (if necessary) as an expression in the body.
              if (param.value != null && !param.shouldCache()) {
                condition = new Op('===', param, new UndefinedLiteral());
                ifTrue = new Assign(new Value(param.name), param.value);
                exprs.push(new If(condition, ifTrue));
              }
              if (((ref5 = param.name) != null ? ref5.value : void 0) != null) {
                // Add this parameter to the scope, since it wouldnt have been added
                // yet since it was skipped earlier.
                o.scope.add(param.name.value, 'var', true);
              }
            }
          }
        }
        // If there were parameters after the splat or expansion parameter, those
        // parameters need to be assigned in the body of the function.
        if (paramsAfterSplat.length !== 0) {
          // Create a destructured assignment, e.g. `[a, b, c] = [args..., b, c]`
          exprs.unshift(new Assign(new Value(new Arr([new Splat(new IdentifierLiteral(splatParamName)), ...function () {
            var k, len2, results1;
            results1 = [];
            for (k = 0, len2 = paramsAfterSplat.length; k < len2; k++) {
              param = paramsAfterSplat[k];
              results1.push(param.asReference(o));
            }
            return results1;
          }()])), new Value(new IdentifierLiteral(splatParamName))));
        }
        // Add new expressions to the function body
        wasEmpty = this.body.isEmpty();
        this.disallowSuperInParamDefaults();
        this.checkSuperCallsInConstructorBody();
        if (!this.expandCtorSuper(thisAssignments)) {
          this.body.expressions.unshift(...thisAssignments);
        }
        this.body.expressions.unshift(...exprs);
        if (this.isMethod && this.bound && !this.isStatic && this.classVariable) {
          boundMethodCheck = new Value(new Literal(utility('boundMethodCheck', o)));
          this.body.expressions.unshift(new Call(boundMethodCheck, [new Value(new ThisLiteral()), this.classVariable]));
        }
        if (!(wasEmpty || this.noReturn)) {
          this.body.makeReturn();
        }
        // JavaScript doesnt allow bound (`=>`) functions to also be generators.
        // This is usually caught via `Op::compileContinuation`, but double-check:
        if (this.bound && this.isGenerator) {
          yieldNode = this.body.contains(function (node) {
            return node instanceof Op && node.operator === 'yield';
          });
          (yieldNode || this).error('yield cannot occur inside bound (fat arrow) functions');
        }
        // Assemble the output
        modifiers = [];
        if (this.isMethod && this.isStatic) {
          modifiers.push('static');
        }
        if (this.isAsync) {
          modifiers.push('async');
        }
        if (!(this.isMethod || this.bound)) {
          modifiers.push(`function${this.isGenerator ? '*' : ''}`);
        } else if (this.isGenerator) {
          modifiers.push('*');
        }
        signature = [this.makeCode('(')];
        // Block comments between a function name and `(` get output between
        // `function` and `(`.
        if (((ref6 = this.paramStart) != null ? ref6.comments : void 0) != null) {
          this.compileCommentFragments(o, this.paramStart, signature);
        }
        for (i = k = 0, len2 = params.length; k < len2; i = ++k) {
          param = params[i];
          if (i !== 0) {
            signature.push(this.makeCode(', '));
          }
          if (haveSplatParam && i === params.length - 1) {
            signature.push(this.makeCode('...'));
          }
          // Compile this parameter, but if any generated variables get created
          // (e.g. `ref`), shift those into the parent scope since we cant put a
          // `var` line inside a function parameter list.
          scopeVariablesCount = o.scope.variables.length;
          signature.push(...param.compileToFragments(o, LEVEL_PAREN));
          if (scopeVariablesCount !== o.scope.variables.length) {
            generatedVariables = o.scope.variables.splice(scopeVariablesCount);
            o.scope.parent.variables.push(...generatedVariables);
          }
        }
        signature.push(this.makeCode(')'));
        // Block comments between `)` and `->`/`=>` get output between `)` and `{`.
        if (((ref7 = this.funcGlyph) != null ? ref7.comments : void 0) != null) {
          ref8 = this.funcGlyph.comments;
          for (l = 0, len3 = ref8.length; l < len3; l++) {
            comment = ref8[l];
            comment.unshift = false;
          }
          this.compileCommentFragments(o, this.funcGlyph, signature);
        }
        if (!this.body.isEmpty()) {
          body = this.body.compileWithDeclarations(o);
        }
        // We need to compile the body before method names to ensure `super`
        // references are handled.
        if (this.isMethod) {
          [methodScope, o.scope] = [o.scope, o.scope.parent];
          name = this.name.compileToFragments(o);
          if (name[0].code === '.') {
            name.shift();
          }
          o.scope = methodScope;
        }
        answer = this.joinFragmentArrays(function () {
          var len4, p, results1;
          results1 = [];
          for (p = 0, len4 = modifiers.length; p < len4; p++) {
            m = modifiers[p];
            results1.push(this.makeCode(m));
          }
          return results1;
        }.call(this), ' ');
        if (modifiers.length && name) {
          answer.push(this.makeCode(' '));
        }
        if (name) {
          answer.push(...name);
        }
        answer.push(...signature);
        if (this.bound && !this.isMethod) {
          answer.push(this.makeCode(' =>'));
        }
        answer.push(this.makeCode(' {'));
        if (body != null ? body.length : void 0) {
          answer.push(this.makeCode('\n'), ...body, this.makeCode(`\n${this.tab}`));
        }
        answer.push(this.makeCode('}'));
        if (this.isMethod) {
          return indentInitial(answer, this);
        }
        if (this.front || o.level >= LEVEL_ACCESS) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }
      updateOptions(o) {
        o.scope = del(o, 'classScope') || this.makeScope(o.scope);
        o.scope.shared = del(o, 'sharedScope');
        o.indent += TAB;
        delete o.bare;
        return delete o.isExistentialEquals;
      }
      checkForDuplicateParams() {
        var paramNames;
        paramNames = [];
        return this.eachParamName(function (name, node, param) {
          if (indexOf.call(paramNames, name) >= 0) {
            node.error(`multiple parameters named '${name}'`);
          }
          return paramNames.push(name);
        });
      }
      eachParamName(iterator) {
        var j, len1, param, ref1, results1;
        ref1 = this.params;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          param = ref1[j];
          results1.push(param.eachName(iterator));
        }
        return results1;
      }

      // Short-circuit `traverseChildren` method to prevent it from crossing scope
      // boundaries unless `crossScope` is `true`.
      traverseChildren(crossScope, func) {
        if (crossScope) {
          return super.traverseChildren(crossScope, func);
        }
      }

      // Short-circuit `replaceInContext` method to prevent it from crossing context boundaries. Bound
      // functions have the same context.
      replaceInContext(child, replacement) {
        if (this.bound) {
          return super.replaceInContext(child, replacement);
        } else {
          return false;
        }
      }
      disallowSuperInParamDefaults({
        forAst
      } = {}) {
        if (!this.ctor) {
          return false;
        }
        return this.eachSuperCall(Block.wrap(this.params), function (superCall) {
          return superCall.error("'super' is not allowed in constructor parameter defaults");
        }, {
          checkForThisBeforeSuper: !forAst
        });
      }
      checkSuperCallsInConstructorBody() {
        var seenSuper;
        if (!this.ctor) {
          return false;
        }
        seenSuper = this.eachSuperCall(this.body, superCall => {
          if (this.ctor === 'base') {
            return superCall.error("'super' is only allowed in derived class constructors");
          }
        });
        return seenSuper;
      }
      flagThisParamInDerivedClassConstructorWithoutCallingSuper(param) {
        return param.error("Can't use @params in derived class constructors without calling super");
      }
      checkForAsyncOrGeneratorConstructor() {
        if (this.ctor) {
          if (this.isAsync) {
            this.name.error('Class constructor may not be async');
          }
          if (this.isGenerator) {
            return this.name.error('Class constructor may not be a generator');
          }
        }
      }
      disallowLoneExpansionAndMultipleSplats() {
        var j, len1, param, ref1, results1, seenSplatParam;
        seenSplatParam = false;
        ref1 = this.params;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          param = ref1[j];
          // Was `...` used with this parameter? (Only one such parameter is allowed
          // per function.)
          if (param.splat || param instanceof Expansion) {
            if (seenSplatParam) {
              param.error('only one splat or expansion parameter is allowed per function definition');
            } else if (param instanceof Expansion && this.params.length === 1) {
              param.error('an expansion parameter cannot be the only parameter in a function definition');
            }
            results1.push(seenSplatParam = true);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }
      expandCtorSuper(thisAssignments) {
        var haveThisParam, param, ref1, seenSuper;
        if (!this.ctor) {
          return false;
        }
        seenSuper = this.eachSuperCall(this.body, superCall => {
          return superCall.expressions = thisAssignments;
        });
        haveThisParam = thisAssignments.length && thisAssignments.length !== ((ref1 = this.thisAssignments) != null ? ref1.length : void 0);
        if (this.ctor === 'derived' && !seenSuper && haveThisParam) {
          param = thisAssignments[0].variable;
          this.flagThisParamInDerivedClassConstructorWithoutCallingSuper(param);
        }
        return seenSuper;
      }

      // Find all super calls in the given context node;
      // returns `true` if `iterator` is called.
      eachSuperCall(context, iterator, {
        checkForThisBeforeSuper = true
      } = {}) {
        var seenSuper;
        seenSuper = false;
        context.traverseChildren(true, child => {
          var childArgs;
          if (child instanceof SuperCall) {
            // `super` in a constructor (the only `super` without an accessor)
            // cannot be given an argument with a reference to `this`, as that would
            // be referencing `this` before calling `super`.
            if (!child.variable.accessor) {
              childArgs = child.args.filter(function (arg) {
                return !(arg instanceof Class) && (!(arg instanceof Code) || arg.bound);
              });
              Block.wrap(childArgs).traverseChildren(true, node => {
                if (node.this) {
                  return node.error("Can't call super with @params in derived class constructors");
                }
              });
            }
            seenSuper = true;
            iterator(child);
          } else if (checkForThisBeforeSuper && child instanceof ThisLiteral && this.ctor === 'derived' && !seenSuper) {
            child.error("Can't reference 'this' before calling super in derived class constructors");
          }
          // `super` has the same target in bound (arrow) functions, so check them too
          return !(child instanceof SuperCall) && (!(child instanceof Code) || child.bound);
        });
        return seenSuper;
      }
      propagateLhs() {
        var j, len1, name, param, ref1, results1;
        ref1 = this.params;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          param = ref1[j];
          ({
            name
          } = param);
          if (name instanceof Arr || name instanceof Obj) {
            results1.push(name.propagateLhs(true));
          } else if (param instanceof Expansion) {
            results1.push(param.lhs = true);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }
      astAddParamsToScope(o) {
        return this.eachParamName(function (name) {
          return o.scope.add(name, 'param');
        });
      }
      astNode(o) {
        var seenSuper;
        this.updateOptions(o);
        this.checkForAsyncOrGeneratorConstructor();
        this.checkForDuplicateParams();
        this.disallowSuperInParamDefaults({
          forAst: true
        });
        this.disallowLoneExpansionAndMultipleSplats();
        seenSuper = this.checkSuperCallsInConstructorBody();
        if (this.ctor === 'derived' && !seenSuper) {
          this.eachParamName((name, node) => {
            if (node.this) {
              return this.flagThisParamInDerivedClassConstructorWithoutCallingSuper(node);
            }
          });
        }
        this.astAddParamsToScope(o);
        if (!(this.body.isEmpty() || this.noReturn)) {
          this.body.makeReturn(null, true);
        }
        return super.astNode(o);
      }
      astType() {
        if (this.isMethod) {
          return 'ClassMethod';
        } else if (this.bound) {
          return 'ArrowFunctionExpression';
        } else {
          return 'FunctionExpression';
        }
      }
      paramForAst(param) {
        var name, splat, value;
        if (param instanceof Expansion) {
          return param;
        }
        ({
          name,
          value,
          splat
        } = param);
        if (splat) {
          return new Splat(name, {
            lhs: true,
            postfix: splat.postfix
          }).withLocationDataFrom(param);
        } else if (value != null) {
          return new Assign(name, value, null, {
            param: true
          }).withLocationDataFrom({
            locationData: mergeLocationData(name.locationData, value.locationData)
          });
        } else {
          return name;
        }
      }
      methodAstProperties(o) {
        var getIsComputed, ref1, ref2, ref3, ref4;
        getIsComputed = () => {
          if (this.name instanceof Index) {
            return true;
          }
          if (this.name instanceof ComputedPropertyName) {
            return true;
          }
          if (this.name.name instanceof ComputedPropertyName) {
            return true;
          }
          return false;
        };
        return {
          static: !!this.isStatic,
          key: this.name.ast(o),
          computed: getIsComputed(),
          kind: this.ctor ? 'constructor' : 'method',
          operator: (ref1 = (ref2 = this.operatorToken) != null ? ref2.value : void 0) != null ? ref1 : '=',
          staticClassName: (ref3 = (ref4 = this.isStatic.staticClassName) != null ? ref4.ast(o) : void 0) != null ? ref3 : null,
          bound: !!this.bound
        };
      }
      astProperties(o) {
        var param, ref1;
        return Object.assign({
          params: function () {
            var j, len1, ref1, results1;
            ref1 = this.params;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              param = ref1[j];
              results1.push(this.paramForAst(param).ast(o));
            }
            return results1;
          }.call(this),
          body: this.body.ast(Object.assign({}, o, {
            checkForDirectives: true
          }), LEVEL_TOP),
          generator: !!this.isGenerator,
          async: !!this.isAsync,
          // We never generate named functions, so specify `id` as `null`, which
          // matches the Babel AST for anonymous function expressions/arrow functions
          id: null,
          hasIndentedBody: this.body.locationData.first_line > ((ref1 = this.funcGlyph) != null ? ref1.locationData.first_line : void 0)
        }, this.isMethod ? this.methodAstProperties(o) : {});
      }
      astLocationData() {
        var astLocationData, functionLocationData;
        functionLocationData = super.astLocationData();
        if (!this.isMethod) {
          return functionLocationData;
        }
        astLocationData = mergeAstLocationData(this.name.astLocationData(), functionLocationData);
        if (this.isStatic.staticClassName != null) {
          astLocationData = mergeAstLocationData(this.isStatic.staticClassName.astLocationData(), astLocationData);
        }
        return astLocationData;
      }
    }
    ;
    Code.prototype.children = ['params', 'body'];
    Code.prototype.jumps = NO;
    return Code;
  }.call(this);

  //### Param

  // A parameter in a function definition. Beyond a typical JavaScript parameter,
  // these parameters can also attach themselves to the context of the function,
  // as well as be a splat, gathering up a group of parameters into an array.
  exports.Param = Param = function () {
    class Param extends Base {
      constructor(name1, value1, splat1) {
        var message, token;
        super();
        this.name = name1;
        this.value = value1;
        this.splat = splat1;
        message = isUnassignable(this.name.unwrapAll().value);
        if (message) {
          this.name.error(message);
        }
        if (this.name instanceof Obj && this.name.generated) {
          token = this.name.objects[0].operatorToken;
          token.error(`unexpected ${token.value}`);
        }
      }
      compileToFragments(o) {
        return this.name.compileToFragments(o, LEVEL_LIST);
      }
      compileToFragmentsWithoutComments(o) {
        return this.name.compileToFragmentsWithoutComments(o, LEVEL_LIST);
      }
      asReference(o) {
        var name, node;
        if (this.reference) {
          return this.reference;
        }
        node = this.name;
        if (node.this) {
          name = node.properties[0].name.value;
          if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
            name = `_${name}`;
          }
          node = new IdentifierLiteral(o.scope.freeVariable(name));
        } else if (node.shouldCache()) {
          node = new IdentifierLiteral(o.scope.freeVariable('arg'));
        }
        node = new Value(node);
        node.updateLocationDataIfMissing(this.locationData);
        return this.reference = node;
      }
      shouldCache() {
        return this.name.shouldCache();
      }

      // Iterates the name or names of a `Param`.
      // In a sense, a destructured parameter represents multiple JS parameters. This
      // method allows to iterate them all.
      // The `iterator` function will be called as `iterator(name, node)` where
      // `name` is the name of the parameter and `node` is the AST node corresponding
      // to that name.
      eachName(iterator, name = this.name) {
        var atParam, checkAssignabilityOfLiteral, j, len1, nObj, node, obj, ref1, ref2;
        checkAssignabilityOfLiteral = function (literal) {
          var message;
          message = isUnassignable(literal.value);
          if (message) {
            literal.error(message);
          }
          if (!literal.isAssignable()) {
            return literal.error(`'${literal.value}' can't be assigned`);
          }
        };
        atParam = (obj, originalObj = null) => {
          return iterator(`@${obj.properties[0].name.value}`, obj, this, originalObj);
        };
        if (name instanceof Call) {
          name.error("Function invocation can't be assigned");
        }
        // * simple literals `foo`
        if (name instanceof Literal) {
          checkAssignabilityOfLiteral(name);
          return iterator(name.value, name, this);
        }
        if (name instanceof Value) {
          // * at-params `@foo`
          return atParam(name);
        }
        ref2 = (ref1 = name.objects) != null ? ref1 : [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          obj = ref2[j];
          // Save original obj.
          nObj = obj;
          // * destructured parameter with default value
          if (obj instanceof Assign && obj.context == null) {
            obj = obj.variable;
          }
          // * assignments within destructured parameters `{foo:bar}`
          if (obj instanceof Assign) {
            // ... possibly with a default value
            if (obj.value instanceof Assign) {
              obj = obj.value.variable;
            } else {
              obj = obj.value;
            }
            this.eachName(iterator, obj.unwrap());
            // * splats within destructured parameters `[xs...]`
          } else if (obj instanceof Splat) {
            node = obj.name.unwrap();
            iterator(node.value, node, this);
          } else if (obj instanceof Value) {
            // * destructured parameters within destructured parameters `[{a}]`
            if (obj.isArray() || obj.isObject()) {
              this.eachName(iterator, obj.base);
              // * at-params within destructured parameters `{@foo}`
            } else if (obj.this) {
              atParam(obj, nObj);
            } else {
              // * simple destructured parameters {foo}
              checkAssignabilityOfLiteral(obj.base);
              iterator(obj.base.value, obj.base, this);
            }
          } else if (obj instanceof Elision) {
            obj;
          } else if (!(obj instanceof Expansion)) {
            obj.error(`illegal parameter ${obj.compile()}`);
          }
        }
      }

      // Rename a param by replacing the given AST node for a name with a new node.
      // This needs to ensure that the the source for object destructuring does not change.
      renameParam(node, newNode) {
        var isNode, replacement;
        isNode = function (candidate) {
          return candidate === node;
        };
        replacement = (node, parent) => {
          var key;
          if (parent instanceof Obj) {
            key = node;
            if (node.this) {
              key = node.properties[0].name;
            }
            // No need to assign a new variable for the destructured variable if the variable isn't reserved.
            // Examples:
            // `({@foo}) ->`  should compile to `({foo}) { this.foo = foo}`
            // `foo = 1; ({@foo}) ->` should compile to `foo = 1; ({foo:foo1}) { this.foo = foo1 }`
            if (node.this && key.value === newNode.value) {
              return new Value(newNode);
            } else {
              return new Assign(new Value(key), newNode, 'object');
            }
          } else {
            return newNode;
          }
        };
        return this.replaceInContext(isNode, replacement);
      }
    }
    ;
    Param.prototype.children = ['name', 'value'];
    return Param;
  }.call(this);

  //### Splat

  // A splat, either as a parameter to a function, an argument to a call,
  // or as part of a destructuring assignment.
  exports.Splat = Splat = function () {
    class Splat extends Base {
      constructor(name, {
        lhs: lhs1,
        postfix = true
      } = {}) {
        super();
        this.lhs = lhs1;
        this.postfix = postfix;
        this.name = name.compile ? name : new Literal(name);
      }
      shouldCache() {
        return false;
      }
      isAssignable({
        allowComplexSplat = false
      } = {}) {
        if (this.name instanceof Obj || this.name instanceof Parens) {
          return allowComplexSplat;
        }
        return this.name.isAssignable() && (!this.name.isAtomic || this.name.isAtomic());
      }
      assigns(name) {
        return this.name.assigns(name);
      }
      compileNode(o) {
        var compiledSplat;
        compiledSplat = [this.makeCode('...'), ...this.name.compileToFragments(o, LEVEL_OP)];
        if (!this.jsx) {
          return compiledSplat;
        }
        return [this.makeCode('{'), ...compiledSplat, this.makeCode('}')];
      }
      unwrap() {
        return this.name;
      }
      propagateLhs(setLhs) {
        var base1;
        if (setLhs) {
          this.lhs = true;
        }
        if (!this.lhs) {
          return;
        }
        return typeof (base1 = this.name).propagateLhs === "function" ? base1.propagateLhs(true) : void 0;
      }
      astType() {
        if (this.jsx) {
          return 'JSXSpreadAttribute';
        } else if (this.lhs) {
          return 'RestElement';
        } else {
          return 'SpreadElement';
        }
      }
      astProperties(o) {
        return {
          argument: this.name.ast(o, LEVEL_OP),
          postfix: this.postfix
        };
      }
    }
    ;
    Splat.prototype.children = ['name'];
    return Splat;
  }.call(this);

  //### Expansion

  // Used to skip values inside an array destructuring (pattern matching) or
  // parameter list.
  exports.Expansion = Expansion = function () {
    class Expansion extends Base {
      compileNode(o) {
        return this.throwLhsError();
      }
      asReference(o) {
        return this;
      }
      eachName(iterator) {}
      throwLhsError() {
        return this.error('Expansion must be used inside a destructuring assignment or parameter list');
      }
      astNode(o) {
        if (!this.lhs) {
          this.throwLhsError();
        }
        return super.astNode(o);
      }
      astType() {
        return 'RestElement';
      }
      astProperties() {
        return {
          argument: null
        };
      }
    }
    ;
    Expansion.prototype.shouldCache = NO;
    return Expansion;
  }.call(this);

  //### Elision

  // Array elision element (for example, [,a, , , b, , c, ,]).
  exports.Elision = Elision = function () {
    class Elision extends Base {
      compileToFragments(o, level) {
        var fragment;
        fragment = super.compileToFragments(o, level);
        fragment.isElision = true;
        return fragment;
      }
      compileNode(o) {
        return [this.makeCode(', ')];
      }
      asReference(o) {
        return this;
      }
      eachName(iterator) {}
      astNode() {
        return null;
      }
    }
    ;
    Elision.prototype.isAssignable = YES;
    Elision.prototype.shouldCache = NO;
    return Elision;
  }.call(this);

  //### While

  // A while loop, the only sort of low-level loop exposed by CoffeeScript. From
  // it, all other loops can be manufactured. Useful in cases where you need more
  // flexibility or more speed than a comprehension can provide.
  exports.While = While = function () {
    class While extends Base {
      constructor(condition1, {
        invert: inverted,
        guard,
        isLoop
      } = {}) {
        super();
        this.condition = condition1;
        this.inverted = inverted;
        this.guard = guard;
        this.isLoop = isLoop;
      }
      makeReturn(results, mark) {
        if (results) {
          return super.makeReturn(results, mark);
        }
        this.returns = !this.jumps();
        if (mark) {
          if (this.returns) {
            this.body.makeReturn(results, mark);
          }
          return;
        }
        return this;
      }
      addBody(body1) {
        this.body = body1;
        return this;
      }
      jumps() {
        var expressions, j, jumpNode, len1, node;
        ({
          expressions
        } = this.body);
        if (!expressions.length) {
          return false;
        }
        for (j = 0, len1 = expressions.length; j < len1; j++) {
          node = expressions[j];
          if (jumpNode = node.jumps({
            loop: true
          })) {
            return jumpNode;
          }
        }
        return false;
      }

      // The main difference from a JavaScript *while* is that the CoffeeScript
      // *while* can be used as a part of a larger expression -- while loops may
      // return an array containing the computed result of each iteration.
      compileNode(o) {
        var answer, body, rvar, set;
        o.indent += TAB;
        set = '';
        ({
          body
        } = this);
        if (body.isEmpty()) {
          body = this.makeCode('');
        } else {
          if (this.returns) {
            body.makeReturn(rvar = o.scope.freeVariable('results'));
            set = `${this.tab}${rvar} = [];\n`;
          }
          if (this.guard) {
            if (body.expressions.length > 1) {
              body.expressions.unshift(new If(new Parens(this.guard).invert(), new StatementLiteral("continue")));
            } else {
              if (this.guard) {
                body = Block.wrap([new If(this.guard, body)]);
              }
            }
          }
          body = [].concat(this.makeCode("\n"), body.compileToFragments(o, LEVEL_TOP), this.makeCode(`\n${this.tab}`));
        }
        answer = [].concat(this.makeCode(set + this.tab + "while ("), this.processedCondition().compileToFragments(o, LEVEL_PAREN), this.makeCode(") {"), body, this.makeCode("}"));
        if (this.returns) {
          answer.push(this.makeCode(`\n${this.tab}return ${rvar};`));
        }
        return answer;
      }
      processedCondition() {
        return this.processedConditionCache != null ? this.processedConditionCache : this.processedConditionCache = this.inverted ? this.condition.invert() : this.condition;
      }
      astType() {
        return 'WhileStatement';
      }
      astProperties(o) {
        var ref1, ref2;
        return {
          test: this.condition.ast(o, LEVEL_PAREN),
          body: this.body.ast(o, LEVEL_TOP),
          guard: (ref1 = (ref2 = this.guard) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          inverted: !!this.inverted,
          postfix: !!this.postfix,
          loop: !!this.isLoop
        };
      }
    }
    ;
    While.prototype.children = ['condition', 'guard', 'body'];
    While.prototype.isStatement = YES;
    return While;
  }.call(this);

  //### Op

  // Simple Arithmetic and logical operations. Performs some conversion from
  // CoffeeScript operations into their JavaScript equivalents.
  exports.Op = Op = function () {
    var CONVERSIONS, INVERSIONS;
    class Op extends Base {
      constructor(op, first, second, flip, {
        invertOperator,
        originalOperator = op
      } = {}) {
        var call, firstCall, message, ref1, unwrapped;
        super();
        this.invertOperator = invertOperator;
        this.originalOperator = originalOperator;
        if (op === 'new') {
          if (((firstCall = unwrapped = first.unwrap()) instanceof Call || (firstCall = unwrapped.base) instanceof Call) && !firstCall.do && !firstCall.isNew) {
            return new Value(firstCall.newInstance(), firstCall === unwrapped ? [] : unwrapped.properties);
          }
          if (!(first instanceof Parens || first.unwrap() instanceof IdentifierLiteral || (typeof first.hasProperties === "function" ? first.hasProperties() : void 0))) {
            first = new Parens(first);
          }
          call = new Call(first, []);
          call.locationData = this.locationData;
          call.isNew = true;
          return call;
        }
        this.operator = CONVERSIONS[op] || op;
        this.first = first;
        this.second = second;
        this.flip = !!flip;
        if ((ref1 = this.operator) === '--' || ref1 === '++') {
          message = isUnassignable(this.first.unwrapAll().value);
          if (message) {
            this.first.error(message);
          }
        }
        return this;
      }
      isNumber() {
        var ref1;
        return this.isUnary() && ((ref1 = this.operator) === '+' || ref1 === '-') && this.first instanceof Value && this.first.isNumber();
      }
      isAwait() {
        return this.operator === 'await';
      }
      isYield() {
        var ref1;
        return (ref1 = this.operator) === 'yield' || ref1 === 'yield*';
      }
      isUnary() {
        return !this.second;
      }
      shouldCache() {
        return !this.isNumber();
      }

      // Am I capable of
      // [Python-style comparison chaining](https://docs.python.org/3/reference/expressions.html#not-in)?
      isChainable() {
        var ref1;
        return (ref1 = this.operator) === '<' || ref1 === '>' || ref1 === '>=' || ref1 === '<=' || ref1 === '===' || ref1 === '!==';
      }
      isChain() {
        return this.isChainable() && this.first.isChainable();
      }
      invert() {
        var allInvertable, curr, fst, op, ref1;
        if (this.isInOperator()) {
          this.invertOperator = '!';
          return this;
        }
        if (this.isChain()) {
          allInvertable = true;
          curr = this;
          while (curr && curr.operator) {
            allInvertable && (allInvertable = curr.operator in INVERSIONS);
            curr = curr.first;
          }
          if (!allInvertable) {
            return new Parens(this).invert();
          }
          curr = this;
          while (curr && curr.operator) {
            curr.invert = !curr.invert;
            curr.operator = INVERSIONS[curr.operator];
            curr = curr.first;
          }
          return this;
        } else if (op = INVERSIONS[this.operator]) {
          this.operator = op;
          if (this.first.unwrap() instanceof Op) {
            this.first.invert();
          }
          return this;
        } else if (this.second) {
          return new Parens(this).invert();
        } else if (this.operator === '!' && (fst = this.first.unwrap()) instanceof Op && ((ref1 = fst.operator) === '!' || ref1 === 'in' || ref1 === 'instanceof')) {
          return fst;
        } else {
          return new Op('!', this);
        }
      }
      unfoldSoak(o) {
        var ref1;
        return ((ref1 = this.operator) === '++' || ref1 === '--' || ref1 === 'delete') && unfoldSoak(o, this, 'first');
      }
      generateDo(exp) {
        var call, func, j, len1, param, passedParams, ref, ref1;
        passedParams = [];
        func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
        ref1 = func.params || [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          param = ref1[j];
          if (param.value) {
            passedParams.push(param.value);
            delete param.value;
          } else {
            passedParams.push(param);
          }
        }
        call = new Call(exp, passedParams);
        call.do = true;
        return call;
      }
      isInOperator() {
        return this.originalOperator === 'in';
      }
      compileNode(o) {
        var answer, inNode, isChain, lhs, rhs;
        if (this.isInOperator()) {
          inNode = new In(this.first, this.second);
          return (this.invertOperator ? inNode.invert() : inNode).compileNode(o);
        }
        if (this.invertOperator) {
          this.invertOperator = null;
          return this.invert().compileNode(o);
        }
        if (this.operator === 'do') {
          return Op.prototype.generateDo(this.first).compileNode(o);
        }
        isChain = this.isChain();
        if (!isChain) {
          // In chains, there's no need to wrap bare obj literals in parens,
          // as the chained expression is wrapped.
          this.first.front = this.front;
        }
        this.checkDeleteOperand(o);
        if (this.isYield() || this.isAwait()) {
          return this.compileContinuation(o);
        }
        if (this.isUnary()) {
          return this.compileUnary(o);
        }
        if (isChain) {
          return this.compileChain(o);
        }
        switch (this.operator) {
          case '?':
            return this.compileExistence(o, this.second.isDefaultValue);
          case '//':
            return this.compileFloorDivision(o);
          case '%%':
            return this.compileModulo(o);
          default:
            lhs = this.first.compileToFragments(o, LEVEL_OP);
            rhs = this.second.compileToFragments(o, LEVEL_OP);
            answer = [].concat(lhs, this.makeCode(` ${this.operator} `), rhs);
            if (o.level <= LEVEL_OP) {
              return answer;
            } else {
              return this.wrapInParentheses(answer);
            }
        }
      }

      // Mimic Python's chained comparisons when multiple comparison operators are
      // used sequentially. For example:

      //     bin/coffee -e 'console.log 50 < 65 > 10'
      //     true
      compileChain(o) {
        var fragments, fst, shared;
        [this.first.second, shared] = this.first.second.cache(o);
        fst = this.first.compileToFragments(o, LEVEL_OP);
        fragments = fst.concat(this.makeCode(` ${this.invert ? '&&' : '||'} `), shared.compileToFragments(o), this.makeCode(` ${this.operator} `), this.second.compileToFragments(o, LEVEL_OP));
        return this.wrapInParentheses(fragments);
      }

      // Keep reference to the left expression, unless this an existential assignment
      compileExistence(o, checkOnlyUndefined) {
        var fst, ref;
        if (this.first.shouldCache()) {
          ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
          fst = new Parens(new Assign(ref, this.first));
        } else {
          fst = this.first;
          ref = fst;
        }
        return new If(new Existence(fst, checkOnlyUndefined), ref, {
          type: 'if'
        }).addElse(this.second).compileToFragments(o);
      }

      // Compile a unary **Op**.
      compileUnary(o) {
        var op, parts, plusMinus;
        parts = [];
        op = this.operator;
        parts.push([this.makeCode(op)]);
        if (op === '!' && this.first instanceof Existence) {
          this.first.negated = !this.first.negated;
          return this.first.compileToFragments(o);
        }
        if (o.level >= LEVEL_ACCESS) {
          return new Parens(this).compileToFragments(o);
        }
        plusMinus = op === '+' || op === '-';
        if (op === 'typeof' || op === 'delete' || plusMinus && this.first instanceof Op && this.first.operator === op) {
          parts.push([this.makeCode(' ')]);
        }
        if (plusMinus && this.first instanceof Op) {
          this.first = new Parens(this.first);
        }
        parts.push(this.first.compileToFragments(o, LEVEL_OP));
        if (this.flip) {
          parts.reverse();
        }
        return this.joinFragmentArrays(parts, '');
      }
      compileContinuation(o) {
        var op, parts, ref1;
        parts = [];
        op = this.operator;
        if (!this.isAwait()) {
          this.checkContinuation(o);
        }
        if (indexOf.call(Object.keys(this.first), 'expression') >= 0 && !(this.first instanceof Throw)) {
          if (this.first.expression != null) {
            parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));
          }
        } else {
          if (o.level >= LEVEL_PAREN) {
            parts.push([this.makeCode("(")]);
          }
          parts.push([this.makeCode(op)]);
          if (((ref1 = this.first.base) != null ? ref1.value : void 0) !== '') {
            parts.push([this.makeCode(" ")]);
          }
          parts.push(this.first.compileToFragments(o, LEVEL_OP));
          if (o.level >= LEVEL_PAREN) {
            parts.push([this.makeCode(")")]);
          }
        }
        return this.joinFragmentArrays(parts, '');
      }
      checkContinuation(o) {
        var ref1;
        if (o.scope.parent == null) {
          this.error(`${this.operator} can only occur inside functions`);
        }
        if (((ref1 = o.scope.method) != null ? ref1.bound : void 0) && o.scope.method.isGenerator) {
          return this.error('yield cannot occur inside bound (fat arrow) functions');
        }
      }
      compileFloorDivision(o) {
        var div, floor, second;
        floor = new Value(new IdentifierLiteral('Math'), [new Access(new PropertyName('floor'))]);
        second = this.second.shouldCache() ? new Parens(this.second) : this.second;
        div = new Op('/', this.first, second);
        return new Call(floor, [div]).compileToFragments(o);
      }
      compileModulo(o) {
        var mod;
        mod = new Value(new Literal(utility('modulo', o)));
        return new Call(mod, [this.first, this.second]).compileToFragments(o);
      }
      toString(idt) {
        return super.toString(idt, this.constructor.name + ' ' + this.operator);
      }
      checkDeleteOperand(o) {
        if (this.operator === 'delete' && o.scope.check(this.first.unwrapAll().value)) {
          return this.error('delete operand may not be argument or var');
        }
      }
      astNode(o) {
        if (this.isYield()) {
          this.checkContinuation(o);
        }
        this.checkDeleteOperand(o);
        return super.astNode(o);
      }
      astType() {
        if (this.isAwait()) {
          return 'AwaitExpression';
        }
        if (this.isYield()) {
          return 'YieldExpression';
        }
        if (this.isChain()) {
          return 'ChainedComparison';
        }
        switch (this.operator) {
          case '||':
          case '&&':
          case '?':
            return 'LogicalExpression';
          case '++':
          case '--':
            return 'UpdateExpression';
          default:
            if (this.isUnary()) {
              return 'UnaryExpression';
            } else {
              return 'BinaryExpression';
            }
        }
      }
      operatorAst() {
        return `${this.invertOperator ? `${this.invertOperator} ` : ''}${this.originalOperator}`;
      }
      chainAstProperties(o) {
        var currentOp, operand, operands, operators;
        operators = [this.operatorAst()];
        operands = [this.second];
        currentOp = this.first;
        while (true) {
          operators.unshift(currentOp.operatorAst());
          operands.unshift(currentOp.second);
          currentOp = currentOp.first;
          if (!currentOp.isChainable()) {
            operands.unshift(currentOp);
            break;
          }
        }
        return {
          operators,
          operands: function () {
            var j, len1, results1;
            results1 = [];
            for (j = 0, len1 = operands.length; j < len1; j++) {
              operand = operands[j];
              results1.push(operand.ast(o, LEVEL_OP));
            }
            return results1;
          }()
        };
      }
      astProperties(o) {
        var argument, firstAst, operatorAst, ref1, secondAst;
        if (this.isChain()) {
          return this.chainAstProperties(o);
        }
        firstAst = this.first.ast(o, LEVEL_OP);
        secondAst = (ref1 = this.second) != null ? ref1.ast(o, LEVEL_OP) : void 0;
        operatorAst = this.operatorAst();
        switch (false) {
          case !this.isUnary():
            argument = this.isYield() && this.first.unwrap().value === '' ? null : firstAst;
            if (this.isAwait()) {
              return {
                argument
              };
            }
            if (this.isYield()) {
              return {
                argument,
                delegate: this.operator === 'yield*'
              };
            }
            return {
              argument,
              operator: operatorAst,
              prefix: !this.flip
            };
          default:
            return {
              left: firstAst,
              right: secondAst,
              operator: operatorAst
            };
        }
      }
    }
    ;

    // The map of conversions from CoffeeScript to JavaScript symbols.
    CONVERSIONS = {
      '==': '===',
      '!=': '!==',
      'of': 'in',
      'yieldfrom': 'yield*'
    };

    // The map of invertible operators.
    INVERSIONS = {
      '!==': '===',
      '===': '!=='
    };
    Op.prototype.children = ['first', 'second'];
    return Op;
  }.call(this);

  //### In
  exports.In = In = function () {
    class In extends Base {
      constructor(object1, array) {
        super();
        this.object = object1;
        this.array = array;
      }
      compileNode(o) {
        var hasSplat, j, len1, obj, ref1;
        if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) {
          ref1 = this.array.base.objects;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            obj = ref1[j];
            if (!(obj instanceof Splat)) {
              continue;
            }
            hasSplat = true;
            break;
          }
          if (!hasSplat) {
            // `compileOrTest` only if we have an array literal with no splats
            return this.compileOrTest(o);
          }
        }
        return this.compileLoopTest(o);
      }
      compileOrTest(o) {
        var cmp, cnj, i, item, j, len1, ref, ref1, sub, tests;
        [sub, ref] = this.object.cache(o, LEVEL_OP);
        [cmp, cnj] = this.negated ? [' !== ', ' && '] : [' === ', ' || '];
        tests = [];
        ref1 = this.array.base.objects;
        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
          item = ref1[i];
          if (i) {
            tests.push(this.makeCode(cnj));
          }
          tests = tests.concat(i ? ref : sub, this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));
        }
        if (o.level < LEVEL_OP) {
          return tests;
        } else {
          return this.wrapInParentheses(tests);
        }
      }
      compileLoopTest(o) {
        var fragments, ref, sub;
        [sub, ref] = this.object.cache(o, LEVEL_LIST);
        fragments = [].concat(this.makeCode(utility('indexOf', o) + ".call("), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), ref, this.makeCode(") " + (this.negated ? '< 0' : '>= 0')));
        if (fragmentsToText(sub) === fragmentsToText(ref)) {
          return fragments;
        }
        fragments = sub.concat(this.makeCode(', '), fragments);
        if (o.level < LEVEL_LIST) {
          return fragments;
        } else {
          return this.wrapInParentheses(fragments);
        }
      }
      toString(idt) {
        return super.toString(idt, this.constructor.name + (this.negated ? '!' : ''));
      }
    }
    ;
    In.prototype.children = ['object', 'array'];
    In.prototype.invert = NEGATE;
    return In;
  }.call(this);

  //### Try

  // A classic *try/catch/finally* block.
  exports.Try = Try = function () {
    class Try extends Base {
      constructor(attempt, _catch, ensure, finallyTag) {
        super();
        this.attempt = attempt;
        this.catch = _catch;
        this.ensure = ensure;
        this.finallyTag = finallyTag;
      }
      jumps(o) {
        var ref1;
        return this.attempt.jumps(o) || ((ref1 = this.catch) != null ? ref1.jumps(o) : void 0);
      }
      makeReturn(results, mark) {
        var ref1, ref2;
        if (mark) {
          if ((ref1 = this.attempt) != null) {
            ref1.makeReturn(results, mark);
          }
          if ((ref2 = this.catch) != null) {
            ref2.makeReturn(results, mark);
          }
          return;
        }
        if (this.attempt) {
          this.attempt = this.attempt.makeReturn(results);
        }
        if (this.catch) {
          this.catch = this.catch.makeReturn(results);
        }
        return this;
      }

      // Compilation is more or less as you would expect -- the *finally* clause
      // is optional, the *catch* is not.
      compileNode(o) {
        var catchPart, ensurePart, generatedErrorVariableName, originalIndent, tryPart;
        originalIndent = o.indent;
        o.indent += TAB;
        tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);
        catchPart = this.catch ? this.catch.compileToFragments(merge(o, {
          indent: originalIndent
        }), LEVEL_TOP) : !(this.ensure || this.catch) ? (generatedErrorVariableName = o.scope.freeVariable('error', {
          reserve: false
        }), [this.makeCode(` catch (${generatedErrorVariableName}) {}`)]) : [];
        ensurePart = this.ensure ? [].concat(this.makeCode(" finally {\n"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode(`\n${this.tab}}`)) : [];
        return [].concat(this.makeCode(`${this.tab}try {\n`), tryPart, this.makeCode(`\n${this.tab}}`), catchPart, ensurePart);
      }
      astType() {
        return 'TryStatement';
      }
      astProperties(o) {
        var ref1, ref2;
        return {
          block: this.attempt.ast(o, LEVEL_TOP),
          handler: (ref1 = (ref2 = this.catch) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          // Include `finally` keyword in location data.
          finalizer: this.ensure != null ? Object.assign(this.ensure.ast(o, LEVEL_TOP), mergeAstLocationData(jisonLocationDataToAstLocationData(this.finallyTag.locationData), this.ensure.astLocationData())) : null
        };
      }
    }
    ;
    Try.prototype.children = ['attempt', 'catch', 'ensure'];
    Try.prototype.isStatement = YES;
    return Try;
  }.call(this);
  exports.Catch = Catch = function () {
    class Catch extends Base {
      constructor(recovery, errorVariable) {
        var base1, ref1;
        super();
        this.recovery = recovery;
        this.errorVariable = errorVariable;
        if ((ref1 = this.errorVariable) != null) {
          if (typeof (base1 = ref1.unwrap()).propagateLhs === "function") {
            base1.propagateLhs(true);
          }
        }
      }
      jumps(o) {
        return this.recovery.jumps(o);
      }
      makeReturn(results, mark) {
        var ret;
        ret = this.recovery.makeReturn(results, mark);
        if (mark) {
          return;
        }
        this.recovery = ret;
        return this;
      }
      compileNode(o) {
        var generatedErrorVariableName, placeholder;
        o.indent += TAB;
        generatedErrorVariableName = o.scope.freeVariable('error', {
          reserve: false
        });
        placeholder = new IdentifierLiteral(generatedErrorVariableName);
        this.checkUnassignable();
        if (this.errorVariable) {
          this.recovery.unshift(new Assign(this.errorVariable, placeholder));
        }
        return [].concat(this.makeCode(" catch ("), placeholder.compileToFragments(o), this.makeCode(") {\n"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode(`\n${this.tab}}`));
      }
      checkUnassignable() {
        var message;
        if (this.errorVariable) {
          message = isUnassignable(this.errorVariable.unwrapAll().value);
          if (message) {
            return this.errorVariable.error(message);
          }
        }
      }
      astNode(o) {
        var ref1;
        this.checkUnassignable();
        if ((ref1 = this.errorVariable) != null) {
          ref1.eachName(function (name) {
            var alreadyDeclared;
            alreadyDeclared = o.scope.find(name.value);
            return name.isDeclaration = !alreadyDeclared;
          });
        }
        return super.astNode(o);
      }
      astType() {
        return 'CatchClause';
      }
      astProperties(o) {
        var ref1, ref2;
        return {
          param: (ref1 = (ref2 = this.errorVariable) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          body: this.recovery.ast(o, LEVEL_TOP)
        };
      }
    }
    ;
    Catch.prototype.children = ['recovery', 'errorVariable'];
    Catch.prototype.isStatement = YES;
    return Catch;
  }.call(this);

  //### Throw

  // Simple node to throw an exception.
  exports.Throw = Throw = function () {
    class Throw extends Base {
      constructor(expression1) {
        super();
        this.expression = expression1;
      }
      compileNode(o) {
        var fragments;
        fragments = this.expression.compileToFragments(o, LEVEL_LIST);
        unshiftAfterComments(fragments, this.makeCode('throw '));
        fragments.unshift(this.makeCode(this.tab));
        fragments.push(this.makeCode(';'));
        return fragments;
      }
      astType() {
        return 'ThrowStatement';
      }
      astProperties(o) {
        return {
          argument: this.expression.ast(o, LEVEL_LIST)
        };
      }
    }
    ;
    Throw.prototype.children = ['expression'];
    Throw.prototype.isStatement = YES;
    Throw.prototype.jumps = NO;

    // A **Throw** is already a return, of sorts...
    Throw.prototype.makeReturn = THIS;
    return Throw;
  }.call(this);

  //### Existence

  // Checks a variable for existence -- not `null` and not `undefined`. This is
  // similar to `.nil?` in Ruby, and avoids having to consult a JavaScript truth
  // table. Optionally only check if a variable is not `undefined`.
  exports.Existence = Existence = function () {
    class Existence extends Base {
      constructor(expression1, onlyNotUndefined = false) {
        var salvagedComments;
        super();
        this.expression = expression1;
        this.comparisonTarget = onlyNotUndefined ? 'undefined' : 'null';
        salvagedComments = [];
        this.expression.traverseChildren(true, function (child) {
          var comment, j, len1, ref1;
          if (child.comments) {
            ref1 = child.comments;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              comment = ref1[j];
              if (indexOf.call(salvagedComments, comment) < 0) {
                salvagedComments.push(comment);
              }
            }
            return delete child.comments;
          }
        });
        attachCommentsToNode(salvagedComments, this);
        moveComments(this.expression, this);
      }
      compileNode(o) {
        var cmp, cnj, code;
        this.expression.front = this.front;
        code = this.expression.compile(o, LEVEL_OP);
        if (this.expression.unwrap() instanceof IdentifierLiteral && !o.scope.check(code)) {
          [cmp, cnj] = this.negated ? ['===', '||'] : ['!==', '&&'];
          code = `typeof ${code} ${cmp} \"undefined\"` + (this.comparisonTarget !== 'undefined' ? ` ${cnj} ${code} ${cmp} ${this.comparisonTarget}` : '');
        } else {
          // We explicity want to use loose equality (`==`) when comparing against `null`,
          // so that an existence check roughly corresponds to a check for truthiness.
          // Do *not* change this to `===` for `null`, as this will break mountains of
          // existing code. When comparing only against `undefined`, however, we want to
          // use `===` because this use case is for parity with ES2015+ default values,
          // which only get assigned when the variable is `undefined` (but not `null`).
          cmp = this.comparisonTarget === 'null' ? this.negated ? '==' : '!=' : this.negated ? '===' : '!=='; // `undefined`
          code = `${code} ${cmp} ${this.comparisonTarget}`;
        }
        return [this.makeCode(o.level <= LEVEL_COND ? code : `(${code})`)];
      }
      astType() {
        return 'UnaryExpression';
      }
      astProperties(o) {
        return {
          argument: this.expression.ast(o),
          operator: '?',
          prefix: false
        };
      }
    }
    ;
    Existence.prototype.children = ['expression'];
    Existence.prototype.invert = NEGATE;
    return Existence;
  }.call(this);

  //### Parens

  // An extra set of parentheses, specified explicitly in the source. At one time
  // we tried to clean up the results by detecting and removing redundant
  // parentheses, but no longer -- you can put in as many as you please.

  // Parentheses are a good way to force any statement to become an expression.
  exports.Parens = Parens = function () {
    class Parens extends Base {
      constructor(body1) {
        super();
        this.body = body1;
      }
      unwrap() {
        return this.body;
      }
      shouldCache() {
        return this.body.shouldCache();
      }
      compileNode(o) {
        var bare, expr, fragments, ref1, shouldWrapComment;
        expr = this.body.unwrap();
        // If these parentheses are wrapping an `IdentifierLiteral` followed by a
        // block comment, output the parentheses (or put another way, dont optimize
        // away these redundant parentheses). This is because Flow requires
        // parentheses in certain circumstances to distinguish identifiers followed
        // by comment-based type annotations from JavaScript labels.
        shouldWrapComment = (ref1 = expr.comments) != null ? ref1.some(function (comment) {
          return comment.here && !comment.unshift && !comment.newLine;
        }) : void 0;
        if (expr instanceof Value && expr.isAtomic() && !this.jsxAttribute && !shouldWrapComment) {
          expr.front = this.front;
          return expr.compileToFragments(o);
        }
        fragments = expr.compileToFragments(o, LEVEL_PAREN);
        bare = o.level < LEVEL_OP && !shouldWrapComment && (expr instanceof Op && !expr.isInOperator() || expr.unwrap() instanceof Call || expr instanceof For && expr.returns) && (o.level < LEVEL_COND || fragments.length <= 3);
        if (this.jsxAttribute) {
          return this.wrapInBraces(fragments);
        }
        if (bare) {
          return fragments;
        } else {
          return this.wrapInParentheses(fragments);
        }
      }
      astNode(o) {
        return this.body.unwrap().ast(o, LEVEL_PAREN);
      }
    }
    ;
    Parens.prototype.children = ['body'];
    return Parens;
  }.call(this);

  //### StringWithInterpolations
  exports.StringWithInterpolations = StringWithInterpolations = function () {
    class StringWithInterpolations extends Base {
      constructor(body1, {
        quote,
        startQuote,
        jsxAttribute
      } = {}) {
        super();
        this.body = body1;
        this.quote = quote;
        this.startQuote = startQuote;
        this.jsxAttribute = jsxAttribute;
      }
      static fromStringLiteral(stringLiteral) {
        var updatedString, updatedStringValue;
        updatedString = stringLiteral.withoutQuotesInLocationData();
        updatedStringValue = new Value(updatedString).withLocationDataFrom(updatedString);
        return new StringWithInterpolations(Block.wrap([updatedStringValue]), {
          quote: stringLiteral.quote,
          jsxAttribute: stringLiteral.jsxAttribute
        }).withLocationDataFrom(stringLiteral);
      }

      // `unwrap` returns `this` to stop ancestor nodes reaching in to grab @body,
      // and using @body.compileNode. `StringWithInterpolations.compileNode` is
      // _the_ custom logic to output interpolated strings as code.
      unwrap() {
        return this;
      }
      shouldCache() {
        return this.body.shouldCache();
      }
      extractElements(o, {
        includeInterpolationWrappers,
        isJsx
      } = {}) {
        var elements, expr, salvagedComments;
        // Assumes that `expr` is `Block`
        expr = this.body.unwrap();
        elements = [];
        salvagedComments = [];
        expr.traverseChildren(false, node => {
          var comment, commentPlaceholder, empty, j, k, len1, len2, ref1, ref2, ref3, unwrapped;
          if (node instanceof StringLiteral) {
            if (node.comments) {
              salvagedComments.push(...node.comments);
              delete node.comments;
            }
            elements.push(node);
            return true;
          } else if (node instanceof Interpolation) {
            if (salvagedComments.length !== 0) {
              for (j = 0, len1 = salvagedComments.length; j < len1; j++) {
                comment = salvagedComments[j];
                comment.unshift = true;
                comment.newLine = true;
              }
              attachCommentsToNode(salvagedComments, node);
            }
            if ((unwrapped = (ref1 = node.expression) != null ? ref1.unwrapAll() : void 0) instanceof PassthroughLiteral && unwrapped.generated && !(isJsx && o.compiling)) {
              if (o.compiling) {
                commentPlaceholder = new StringLiteral('').withLocationDataFrom(node);
                commentPlaceholder.comments = unwrapped.comments;
                if (node.comments) {
                  (commentPlaceholder.comments != null ? commentPlaceholder.comments : commentPlaceholder.comments = []).push(...node.comments);
                }
                elements.push(new Value(commentPlaceholder));
              } else {
                empty = new Interpolation().withLocationDataFrom(node);
                empty.comments = node.comments;
                elements.push(empty);
              }
            } else if (node.expression || includeInterpolationWrappers) {
              if (node.comments) {
                ((ref2 = node.expression) != null ? ref2.comments != null ? ref2.comments : ref2.comments = [] : void 0).push(...node.comments);
              }
              elements.push(includeInterpolationWrappers ? node : node.expression);
            }
            return false;
          } else if (node.comments) {
            // This node is getting discarded, but salvage its comments.
            if (elements.length !== 0 && !(elements[elements.length - 1] instanceof StringLiteral)) {
              ref3 = node.comments;
              for (k = 0, len2 = ref3.length; k < len2; k++) {
                comment = ref3[k];
                comment.unshift = false;
                comment.newLine = true;
              }
              attachCommentsToNode(node.comments, elements[elements.length - 1]);
            } else {
              salvagedComments.push(...node.comments);
            }
            delete node.comments;
          }
          return true;
        });
        return elements;
      }
      compileNode(o) {
        var code, element, elements, fragments, j, len1, ref1, unquotedElementValue, wrapped;
        if (this.comments == null) {
          this.comments = (ref1 = this.startQuote) != null ? ref1.comments : void 0;
        }
        if (this.jsxAttribute) {
          wrapped = new Parens(new StringWithInterpolations(this.body));
          wrapped.jsxAttribute = true;
          return wrapped.compileNode(o);
        }
        elements = this.extractElements(o, {
          isJsx: this.jsx
        });
        fragments = [];
        if (!this.jsx) {
          fragments.push(this.makeCode('`'));
        }
        for (j = 0, len1 = elements.length; j < len1; j++) {
          element = elements[j];
          if (element instanceof StringLiteral) {
            unquotedElementValue = this.jsx ? element.unquotedValueForJSX : element.unquotedValueForTemplateLiteral;
            fragments.push(this.makeCode(unquotedElementValue));
          } else {
            if (!this.jsx) {
              fragments.push(this.makeCode('$'));
            }
            code = element.compileToFragments(o, LEVEL_PAREN);
            if (!this.isNestedTag(element) || code.some(function (fragment) {
              var ref2;
              return (ref2 = fragment.comments) != null ? ref2.some(function (comment) {
                return comment.here === false;
              }) : void 0;
            })) {
              code = this.wrapInBraces(code);
              // Flag the `{` and `}` fragments as having been generated by this
              // `StringWithInterpolations` node, so that `compileComments` knows
              // to treat them as bounds. But the braces are unnecessary if all of
              // the enclosed comments are `/* */` comments. Dont trust
              // `fragment.type`, which can report minified variable names when
              // this compiler is minified.
              code[0].isStringWithInterpolations = true;
              code[code.length - 1].isStringWithInterpolations = true;
            }
            fragments.push(...code);
          }
        }
        if (!this.jsx) {
          fragments.push(this.makeCode('`'));
        }
        return fragments;
      }
      isNestedTag(element) {
        var call;
        call = typeof element.unwrapAll === "function" ? element.unwrapAll() : void 0;
        return this.jsx && call instanceof JSXElement;
      }
      astType() {
        return 'TemplateLiteral';
      }
      astProperties(o) {
        var element, elements, emptyInterpolation, expression, expressions, index, j, last, len1, node, quasis;
        elements = this.extractElements(o, {
          includeInterpolationWrappers: true
        });
        [last] = slice1.call(elements, -1);
        quasis = [];
        expressions = [];
        for (index = j = 0, len1 = elements.length; j < len1; index = ++j) {
          element = elements[index];
          if (element instanceof StringLiteral) {
            quasis.push(new TemplateElement(element.originalValue, {
              tail: element === last
            }).withLocationDataFrom(element).ast(o)); // Interpolation
          } else {
            ({
              expression
            } = element);
            node = expression == null ? (emptyInterpolation = new EmptyInterpolation(), emptyInterpolation.locationData = emptyExpressionLocationData({
              interpolationNode: element,
              openingBrace: '#{',
              closingBrace: '}'
            }), emptyInterpolation) : expression.unwrapAll();
            expressions.push(astAsBlockIfNeeded(node, o));
          }
        }
        return {
          expressions,
          quasis,
          quote: this.quote
        };
      }
    }
    ;
    StringWithInterpolations.prototype.children = ['body'];
    return StringWithInterpolations;
  }.call(this);
  exports.TemplateElement = TemplateElement = class TemplateElement extends Base {
    constructor(value1, {
      tail: tail1
    } = {}) {
      super();
      this.value = value1;
      this.tail = tail1;
    }
    astProperties() {
      return {
        value: {
          raw: this.value
        },
        tail: !!this.tail
      };
    }
  };
  exports.Interpolation = Interpolation = function () {
    class Interpolation extends Base {
      constructor(expression1) {
        super();
        this.expression = expression1;
      }
    }
    ;
    Interpolation.prototype.children = ['expression'];
    return Interpolation;
  }.call(this);

  // Represents the contents of an empty interpolation (e.g. `#{}`).
  // Only used during AST generation.
  exports.EmptyInterpolation = EmptyInterpolation = class EmptyInterpolation extends Base {
    constructor() {
      super();
    }
  };

  //### For

  // CoffeeScript's replacement for the *for* loop is our array and object
  // comprehensions, that compile into *for* loops here. They also act as an
  // expression, able to return the result of each filtered iteration.

  // Unlike Python array comprehensions, they can be multi-line, and you can pass
  // the current index of the loop as a second parameter. Unlike Ruby blocks,
  // you can map and filter in a single pass.
  exports.For = For = function () {
    class For extends While {
      constructor(body, source) {
        super();
        this.addBody(body);
        this.addSource(source);
      }
      isAwait() {
        var ref1;
        return (ref1 = this.await) != null ? ref1 : false;
      }
      addBody(body) {
        var base1, expressions;
        this.body = Block.wrap([body]);
        ({
          expressions
        } = this.body);
        if (expressions.length) {
          if ((base1 = this.body).locationData == null) {
            base1.locationData = mergeLocationData(expressions[0].locationData, expressions[expressions.length - 1].locationData);
          }
        }
        return this;
      }
      addSource(source) {
        var attr, attribs, attribute, base1, j, k, len1, len2, ref1, ref2, ref3, ref4;
        ({
          source: this.source = false
        } = source);
        attribs = ["name", "index", "guard", "step", "own", "ownTag", "await", "awaitTag", "object", "from"];
        for (j = 0, len1 = attribs.length; j < len1; j++) {
          attr = attribs[j];
          this[attr] = (ref1 = source[attr]) != null ? ref1 : this[attr];
        }
        if (!this.source) {
          return this;
        }
        if (this.from && this.index) {
          this.index.error('cannot use index with for-from');
        }
        if (this.own && !this.object) {
          this.ownTag.error(`cannot use own with for-${this.from ? 'from' : 'in'}`);
        }
        if (this.object) {
          [this.name, this.index] = [this.index, this.name];
        }
        if (((ref2 = this.index) != null ? typeof ref2.isArray === "function" ? ref2.isArray() : void 0 : void 0) || ((ref3 = this.index) != null ? typeof ref3.isObject === "function" ? ref3.isObject() : void 0 : void 0)) {
          this.index.error('index cannot be a pattern matching expression');
        }
        if (this.await && !this.from) {
          this.awaitTag.error('await must be used with for-from');
        }
        this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length && !this.from;
        this.pattern = this.name instanceof Value;
        if (this.pattern) {
          if (typeof (base1 = this.name.unwrap()).propagateLhs === "function") {
            base1.propagateLhs(true);
          }
        }
        if (this.range && this.index) {
          this.index.error('indexes do not apply to range loops');
        }
        if (this.range && this.pattern) {
          this.name.error('cannot pattern match over range loops');
        }
        this.returns = false;
        ref4 = ['source', 'guard', 'step', 'name', 'index'];
        // Move up any comments in the `for` line, i.e. the line of code with `for`,
        // from any child nodes of that line up to the `for` node itself so that these
        // comments get output, and get output above the `for` loop.
        for (k = 0, len2 = ref4.length; k < len2; k++) {
          attribute = ref4[k];
          if (!this[attribute]) {
            continue;
          }
          this[attribute].traverseChildren(true, node => {
            var comment, l, len3, ref5;
            if (node.comments) {
              ref5 = node.comments;
              for (l = 0, len3 = ref5.length; l < len3; l++) {
                comment = ref5[l];
                // These comments are buried pretty deeply, so if they happen to be
                // trailing comments the line they trail will be unrecognizable when
                // were done compiling this `for` loop; so just shift them up to
                // output above the `for` line.
                comment.newLine = comment.unshift = true;
              }
              return moveComments(node, this[attribute]);
            }
          });
          moveComments(this[attribute], this);
        }
        return this;
      }

      // Welcome to the hairiest method in all of CoffeeScript. Handles the inner
      // loop, filtering, stepping, and result saving for array, object, and range
      // comprehensions. Some of the generated code can be shared in common, and
      // some cannot.
      compileNode(o) {
        var body, bodyFragments, compare, compareDown, declare, declareDown, defPart, down, forClose, forCode, forPartFragments, fragments, guardPart, idt1, increment, index, ivar, kvar, kvarAssign, last, lvar, name, namePart, ref, ref1, resultPart, returnResult, rvar, scope, source, step, stepNum, stepVar, svar, varPart;
        body = Block.wrap([this.body]);
        ref1 = body.expressions, [last] = slice1.call(ref1, -1);
        if ((last != null ? last.jumps() : void 0) instanceof Return) {
          this.returns = false;
        }
        source = this.range ? this.source.base : this.source;
        scope = o.scope;
        if (!this.pattern) {
          name = this.name && this.name.compile(o, LEVEL_LIST);
        }
        index = this.index && this.index.compile(o, LEVEL_LIST);
        if (name && !this.pattern) {
          scope.find(name);
        }
        if (index && !(this.index instanceof Value)) {
          scope.find(index);
        }
        if (this.returns) {
          rvar = scope.freeVariable('results');
        }
        if (this.from) {
          if (this.pattern) {
            ivar = scope.freeVariable('x', {
              single: true
            });
          }
        } else {
          ivar = this.object && index || scope.freeVariable('i', {
            single: true
          });
        }
        kvar = (this.range || this.from) && name || index || ivar;
        kvarAssign = kvar !== ivar ? `${kvar} = ` : "";
        if (this.step && !this.range) {
          [step, stepVar] = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST, shouldCacheOrIsAssignable));
          if (this.step.isNumber()) {
            stepNum = parseNumber(stepVar);
          }
        }
        if (this.pattern) {
          name = ivar;
        }
        varPart = '';
        guardPart = '';
        defPart = '';
        idt1 = this.tab + TAB;
        if (this.range) {
          forPartFragments = source.compileToFragments(merge(o, {
            index: ivar,
            name,
            step: this.step,
            shouldCache: shouldCacheOrIsAssignable
          }));
        } else {
          svar = this.source.compile(o, LEVEL_LIST);
          if ((name || this.own) && !(this.source.unwrap() instanceof IdentifierLiteral)) {
            defPart += `${this.tab}${ref = scope.freeVariable('ref')} = ${svar};\n`;
            svar = ref;
          }
          if (name && !this.pattern && !this.from) {
            namePart = `${name} = ${svar}[${kvar}]`;
          }
          if (!this.object && !this.from) {
            if (step !== stepVar) {
              defPart += `${this.tab}${step};\n`;
            }
            down = stepNum < 0;
            if (!(this.step && stepNum != null && down)) {
              lvar = scope.freeVariable('len');
            }
            declare = `${kvarAssign}${ivar} = 0, ${lvar} = ${svar}.length`;
            declareDown = `${kvarAssign}${ivar} = ${svar}.length - 1`;
            compare = `${ivar} < ${lvar}`;
            compareDown = `${ivar} >= 0`;
            if (this.step) {
              if (stepNum != null) {
                if (down) {
                  compare = compareDown;
                  declare = declareDown;
                }
              } else {
                compare = `${stepVar} > 0 ? ${compare} : ${compareDown}`;
                declare = `(${stepVar} > 0 ? (${declare}) : ${declareDown})`;
              }
              increment = `${ivar} += ${stepVar}`;
            } else {
              increment = `${kvar !== ivar ? `++${ivar}` : `${ivar}++`}`;
            }
            forPartFragments = [this.makeCode(`${declare}; ${compare}; ${kvarAssign}${increment}`)];
          }
        }
        if (this.returns) {
          resultPart = `${this.tab}${rvar} = [];\n`;
          returnResult = `\n${this.tab}return ${rvar};`;
          body.makeReturn(rvar);
        }
        if (this.guard) {
          if (body.expressions.length > 1) {
            body.expressions.unshift(new If(new Parens(this.guard).invert(), new StatementLiteral("continue")));
          } else {
            if (this.guard) {
              body = Block.wrap([new If(this.guard, body)]);
            }
          }
        }
        if (this.pattern) {
          body.expressions.unshift(new Assign(this.name, this.from ? new IdentifierLiteral(kvar) : new Literal(`${svar}[${kvar}]`)));
        }
        if (namePart) {
          varPart = `\n${idt1}${namePart};`;
        }
        if (this.object) {
          forPartFragments = [this.makeCode(`${kvar} in ${svar}`)];
          if (this.own) {
            guardPart = `\n${idt1}if (!${utility('hasProp', o)}.call(${svar}, ${kvar})) continue;`;
          }
        } else if (this.from) {
          if (this.await) {
            forPartFragments = new Op('await', new Parens(new Literal(`${kvar} of ${svar}`)));
            forPartFragments = forPartFragments.compileToFragments(o, LEVEL_TOP);
          } else {
            forPartFragments = [this.makeCode(`${kvar} of ${svar}`)];
          }
        }
        bodyFragments = body.compileToFragments(merge(o, {
          indent: idt1
        }), LEVEL_TOP);
        if (bodyFragments && bodyFragments.length > 0) {
          bodyFragments = [].concat(this.makeCode('\n'), bodyFragments, this.makeCode('\n'));
        }
        fragments = [this.makeCode(defPart)];
        if (resultPart) {
          fragments.push(this.makeCode(resultPart));
        }
        forCode = this.await ? 'for ' : 'for (';
        forClose = this.await ? '' : ')';
        fragments = fragments.concat(this.makeCode(this.tab), this.makeCode(forCode), forPartFragments, this.makeCode(`${forClose} {${guardPart}${varPart}`), bodyFragments, this.makeCode(this.tab), this.makeCode('}'));
        if (returnResult) {
          fragments.push(this.makeCode(returnResult));
        }
        return fragments;
      }
      astNode(o) {
        var addToScope, ref1, ref2;
        addToScope = function (name) {
          var alreadyDeclared;
          alreadyDeclared = o.scope.find(name.value);
          return name.isDeclaration = !alreadyDeclared;
        };
        if ((ref1 = this.name) != null) {
          ref1.eachName(addToScope, {
            checkAssignability: false
          });
        }
        if ((ref2 = this.index) != null) {
          ref2.eachName(addToScope, {
            checkAssignability: false
          });
        }
        return super.astNode(o);
      }
      astType() {
        return 'For';
      }
      astProperties(o) {
        var ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
        return {
          source: (ref1 = this.source) != null ? ref1.ast(o) : void 0,
          body: this.body.ast(o, LEVEL_TOP),
          guard: (ref2 = (ref3 = this.guard) != null ? ref3.ast(o) : void 0) != null ? ref2 : null,
          name: (ref4 = (ref5 = this.name) != null ? ref5.ast(o) : void 0) != null ? ref4 : null,
          index: (ref6 = (ref7 = this.index) != null ? ref7.ast(o) : void 0) != null ? ref6 : null,
          step: (ref8 = (ref9 = this.step) != null ? ref9.ast(o) : void 0) != null ? ref8 : null,
          postfix: !!this.postfix,
          own: !!this.own,
          await: !!this.await,
          style: function () {
            switch (false) {
              case !this.from:
                return 'from';
              case !this.object:
                return 'of';
              case !this.name:
                return 'in';
              default:
                return 'range';
            }
          }.call(this)
        };
      }
    }
    ;
    For.prototype.children = ['body', 'source', 'guard', 'step'];
    return For;
  }.call(this);

  //### Switch

  // A JavaScript *switch* statement. Converts into a returnable expression on-demand.
  exports.Switch = Switch = function () {
    class Switch extends Base {
      constructor(subject, cases1, otherwise) {
        super();
        this.subject = subject;
        this.cases = cases1;
        this.otherwise = otherwise;
      }
      jumps(o = {
        block: true
      }) {
        var block, j, jumpNode, len1, ref1, ref2;
        ref1 = this.cases;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          ({
            block
          } = ref1[j]);
          if (jumpNode = block.jumps(o)) {
            return jumpNode;
          }
        }
        return (ref2 = this.otherwise) != null ? ref2.jumps(o) : void 0;
      }
      makeReturn(results, mark) {
        var block, j, len1, ref1, ref2;
        ref1 = this.cases;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          ({
            block
          } = ref1[j]);
          block.makeReturn(results, mark);
        }
        if (results) {
          this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));
        }
        if ((ref2 = this.otherwise) != null) {
          ref2.makeReturn(results, mark);
        }
        return this;
      }
      compileNode(o) {
        var block, body, cond, conditions, expr, fragments, i, idt1, idt2, j, k, len1, len2, ref1, ref2;
        idt1 = o.indent + TAB;
        idt2 = o.indent = idt1 + TAB;
        fragments = [].concat(this.makeCode(this.tab + "switch ("), this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode("false"), this.makeCode(") {\n"));
        ref1 = this.cases;
        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
          ({
            conditions,
            block
          } = ref1[i]);
          ref2 = flatten([conditions]);
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            cond = ref2[k];
            if (!this.subject) {
              cond = cond.invert();
            }
            fragments = fragments.concat(this.makeCode(idt1 + "case "), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(":\n"));
          }
          if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) {
            fragments = fragments.concat(body, this.makeCode('\n'));
          }
          if (i === this.cases.length - 1 && !this.otherwise) {
            break;
          }
          expr = this.lastNode(block.expressions);
          if (expr instanceof Return || expr instanceof Throw || expr instanceof Literal && expr.jumps() && expr.value !== 'debugger') {
            continue;
          }
          fragments.push(cond.makeCode(idt2 + 'break;\n'));
        }
        if (this.otherwise && this.otherwise.expressions.length) {
          fragments.push(this.makeCode(idt1 + "default:\n"), ...this.otherwise.compileToFragments(o, LEVEL_TOP), this.makeCode("\n"));
        }
        fragments.push(this.makeCode(this.tab + '}'));
        return fragments;
      }
      astType() {
        return 'SwitchStatement';
      }
      casesAst(o) {
        var caseIndex, caseLocationData, cases, consequent, j, k, kase, l, lastTestIndex, len1, len2, len3, ref1, ref2, results1, test, testConsequent, testIndex, tests;
        cases = [];
        ref1 = this.cases;
        for (caseIndex = j = 0, len1 = ref1.length; j < len1; caseIndex = ++j) {
          kase = ref1[caseIndex];
          ({
            conditions: tests,
            block: consequent
          } = kase);
          tests = flatten([tests]);
          lastTestIndex = tests.length - 1;
          for (testIndex = k = 0, len2 = tests.length; k < len2; testIndex = ++k) {
            test = tests[testIndex];
            testConsequent = testIndex === lastTestIndex ? consequent : null;
            caseLocationData = test.locationData;
            if (testConsequent != null ? testConsequent.expressions.length : void 0) {
              caseLocationData = mergeLocationData(caseLocationData, testConsequent.expressions[testConsequent.expressions.length - 1].locationData);
            }
            if (testIndex === 0) {
              caseLocationData = mergeLocationData(caseLocationData, kase.locationData, {
                justLeading: true
              });
            }
            if (testIndex === lastTestIndex) {
              caseLocationData = mergeLocationData(caseLocationData, kase.locationData, {
                justEnding: true
              });
            }
            cases.push(new SwitchCase(test, testConsequent, {
              trailing: testIndex === lastTestIndex
            }).withLocationDataFrom({
              locationData: caseLocationData
            }));
          }
        }
        if ((ref2 = this.otherwise) != null ? ref2.expressions.length : void 0) {
          cases.push(new SwitchCase(null, this.otherwise).withLocationDataFrom(this.otherwise));
        }
        results1 = [];
        for (l = 0, len3 = cases.length; l < len3; l++) {
          kase = cases[l];
          results1.push(kase.ast(o));
        }
        return results1;
      }
      astProperties(o) {
        var ref1, ref2;
        return {
          discriminant: (ref1 = (ref2 = this.subject) != null ? ref2.ast(o, LEVEL_PAREN) : void 0) != null ? ref1 : null,
          cases: this.casesAst(o)
        };
      }
    }
    ;
    Switch.prototype.children = ['subject', 'cases', 'otherwise'];
    Switch.prototype.isStatement = YES;
    return Switch;
  }.call(this);
  SwitchCase = function () {
    class SwitchCase extends Base {
      constructor(test1, block1, {
        trailing
      } = {}) {
        super();
        this.test = test1;
        this.block = block1;
        this.trailing = trailing;
      }
      astProperties(o) {
        var ref1, ref2, ref3, ref4;
        return {
          test: (ref1 = (ref2 = this.test) != null ? ref2.ast(o, LEVEL_PAREN) : void 0) != null ? ref1 : null,
          consequent: (ref3 = (ref4 = this.block) != null ? ref4.ast(o, LEVEL_TOP).body : void 0) != null ? ref3 : [],
          trailing: !!this.trailing
        };
      }
    }
    ;
    SwitchCase.prototype.children = ['test', 'block'];
    return SwitchCase;
  }.call(this);
  exports.SwitchWhen = SwitchWhen = function () {
    class SwitchWhen extends Base {
      constructor(conditions1, block1) {
        super();
        this.conditions = conditions1;
        this.block = block1;
      }
    }
    ;
    SwitchWhen.prototype.children = ['conditions', 'block'];
    return SwitchWhen;
  }.call(this);

  //### If

  // *If/else* statements. Acts as an expression by pushing down requested returns
  // to the last line of each clause.

  // Single-expression **Ifs** are compiled into conditional operators if possible,
  // because ternaries are already proper expressions, and dont need conversion.
  exports.If = If = function () {
    class If extends Base {
      constructor(condition1, body1, options = {}) {
        super();
        this.condition = condition1;
        this.body = body1;
        this.elseBody = null;
        this.isChain = false;
        ({
          soak: this.soak,
          postfix: this.postfix,
          type: this.type
        } = options);
        if (this.condition.comments) {
          moveComments(this.condition, this);
        }
      }
      bodyNode() {
        var ref1;
        return (ref1 = this.body) != null ? ref1.unwrap() : void 0;
      }
      elseBodyNode() {
        var ref1;
        return (ref1 = this.elseBody) != null ? ref1.unwrap() : void 0;
      }

      // Rewrite a chain of **Ifs** to add a default case as the final *else*.
      addElse(elseBody) {
        if (this.isChain) {
          this.elseBodyNode().addElse(elseBody);
          this.locationData = mergeLocationData(this.locationData, this.elseBodyNode().locationData);
        } else {
          this.isChain = elseBody instanceof If;
          this.elseBody = this.ensureBlock(elseBody);
          this.elseBody.updateLocationDataIfMissing(elseBody.locationData);
          if (this.locationData != null && this.elseBody.locationData != null) {
            this.locationData = mergeLocationData(this.locationData, this.elseBody.locationData);
          }
        }
        return this;
      }

      // The **If** only compiles into a statement if either of its bodies needs
      // to be a statement. Otherwise a conditional operator is safe.
      isStatement(o) {
        var ref1;
        return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((ref1 = this.elseBodyNode()) != null ? ref1.isStatement(o) : void 0);
      }
      jumps(o) {
        var ref1;
        return this.body.jumps(o) || ((ref1 = this.elseBody) != null ? ref1.jumps(o) : void 0);
      }
      compileNode(o) {
        if (this.isStatement(o)) {
          return this.compileStatement(o);
        } else {
          return this.compileExpression(o);
        }
      }
      makeReturn(results, mark) {
        var ref1, ref2;
        if (mark) {
          if ((ref1 = this.body) != null) {
            ref1.makeReturn(results, mark);
          }
          if ((ref2 = this.elseBody) != null) {
            ref2.makeReturn(results, mark);
          }
          return;
        }
        if (results) {
          this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));
        }
        this.body && (this.body = new Block([this.body.makeReturn(results)]));
        this.elseBody && (this.elseBody = new Block([this.elseBody.makeReturn(results)]));
        return this;
      }
      ensureBlock(node) {
        if (node instanceof Block) {
          return node;
        } else {
          return new Block([node]);
        }
      }

      // Compile the `If` as a regular *if-else* statement. Flattened chains
      // force inner *else* bodies into statement form.
      compileStatement(o) {
        var answer, body, child, cond, exeq, ifPart, indent;
        child = del(o, 'chainChild');
        exeq = del(o, 'isExistentialEquals');
        if (exeq) {
          return new If(this.processedCondition().invert(), this.elseBodyNode(), {
            type: 'if'
          }).compileToFragments(o);
        }
        indent = o.indent + TAB;
        cond = this.processedCondition().compileToFragments(o, LEVEL_PAREN);
        body = this.ensureBlock(this.body).compileToFragments(merge(o, {
          indent
        }));
        ifPart = [].concat(this.makeCode("if ("), cond, this.makeCode(") {\n"), body, this.makeCode(`\n${this.tab}}`));
        if (!child) {
          ifPart.unshift(this.makeCode(this.tab));
        }
        if (!this.elseBody) {
          return ifPart;
        }
        answer = ifPart.concat(this.makeCode(' else '));
        if (this.isChain) {
          o.chainChild = true;
          answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));
        } else {
          answer = answer.concat(this.makeCode("{\n"), this.elseBody.compileToFragments(merge(o, {
            indent
          }), LEVEL_TOP), this.makeCode(`\n${this.tab}}`));
        }
        return answer;
      }

      // Compile the `If` as a conditional operator.
      compileExpression(o) {
        var alt, body, cond, fragments;
        cond = this.processedCondition().compileToFragments(o, LEVEL_COND);
        body = this.bodyNode().compileToFragments(o, LEVEL_LIST);
        alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [this.makeCode('void 0')];
        fragments = cond.concat(this.makeCode(" ? "), body, this.makeCode(" : "), alt);
        if (o.level >= LEVEL_COND) {
          return this.wrapInParentheses(fragments);
        } else {
          return fragments;
        }
      }
      unfoldSoak() {
        return this.soak && this;
      }
      processedCondition() {
        return this.processedConditionCache != null ? this.processedConditionCache : this.processedConditionCache = this.type === 'unless' ? this.condition.invert() : this.condition;
      }
      isStatementAst(o) {
        return o.level === LEVEL_TOP;
      }
      astType(o) {
        if (this.isStatementAst(o)) {
          return 'IfStatement';
        } else {
          return 'ConditionalExpression';
        }
      }
      astProperties(o) {
        var isStatement, ref1, ref2, ref3, ref4;
        isStatement = this.isStatementAst(o);
        return {
          test: this.condition.ast(o, isStatement ? LEVEL_PAREN : LEVEL_COND),
          consequent: isStatement ? this.body.ast(o, LEVEL_TOP) : this.bodyNode().ast(o, LEVEL_TOP),
          alternate: this.isChain ? this.elseBody.unwrap().ast(o, isStatement ? LEVEL_TOP : LEVEL_COND) : !isStatement && ((ref1 = this.elseBody) != null ? (ref2 = ref1.expressions) != null ? ref2.length : void 0 : void 0) === 1 ? this.elseBody.expressions[0].ast(o, LEVEL_TOP) : (ref3 = (ref4 = this.elseBody) != null ? ref4.ast(o, LEVEL_TOP) : void 0) != null ? ref3 : null,
          postfix: !!this.postfix,
          inverted: this.type === 'unless'
        };
      }
    }
    ;
    If.prototype.children = ['condition', 'body', 'elseBody'];
    return If;
  }.call(this);

  // A sequence expression e.g. `(a; b)`.
  // Currently only used during AST generation.
  exports.Sequence = Sequence = function () {
    class Sequence extends Base {
      constructor(expressions1) {
        super();
        this.expressions = expressions1;
      }
      astNode(o) {
        if (this.expressions.length === 1) {
          return this.expressions[0].ast(o);
        }
        return super.astNode(o);
      }
      astType() {
        return 'SequenceExpression';
      }
      astProperties(o) {
        var expression;
        return {
          expressions: function () {
            var j, len1, ref1, results1;
            ref1 = this.expressions;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              expression = ref1[j];
              results1.push(expression.ast(o));
            }
            return results1;
          }.call(this)
        };
      }
    }
    ;
    Sequence.prototype.children = ['expressions'];
    return Sequence;
  }.call(this);

  // Constants
  // ---------
  UTILITIES = {
    modulo: function () {
      return 'function(a, b) { return (+a % (b = +b) + b) % b; }';
    },
    boundMethodCheck: function () {
      return "function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } }";
    },
    // Shortcuts to speed up the lookup time for native functions.
    hasProp: function () {
      return '{}.hasOwnProperty';
    },
    indexOf: function () {
      return '[].indexOf';
    },
    slice: function () {
      return '[].slice';
    },
    splice: function () {
      return '[].splice';
    }
  };

  // Levels indicate a node's position in the AST. Useful for knowing if
  // parens are necessary or superfluous.
  LEVEL_TOP = 1; // ...;

  LEVEL_PAREN = 2; // (...)

  LEVEL_LIST = 3; // [...]

  LEVEL_COND = 4; // ... ? x : y

  LEVEL_OP = 5; // !...

  LEVEL_ACCESS = 6; // ...[0]

  // Tabs are two spaces for pretty printing.
  TAB = '  ';
  SIMPLENUM = /^[+-]?\d+$/;
  SIMPLE_STRING_OMIT = /\s*\n\s*/g;
  LEADING_BLANK_LINE = /^[^\n\S]*\n/;
  TRAILING_BLANK_LINE = /\n[^\n\S]*$/;
  STRING_OMIT = /((?:\\\\)+)|\\[^\S\n]*\n\s*/g; // Consume (and preserve) an even number of backslashes.
  // Remove escaped newlines.

  HEREGEX_OMIT = /((?:\\\\)+)|\\(\s)|\s+(?:#.*)?/g; // Consume (and preserve) an even number of backslashes.
  // Preserve escaped whitespace.
  // Remove whitespace and comments.

  // Helper Functions
  // ----------------

  // Helper for ensuring that utility functions are assigned at the top level.
  utility = function (name, o) {
    var ref, root;
    ({
      root
    } = o.scope);
    if (name in root.utilities) {
      return root.utilities[name];
    } else {
      ref = root.freeVariable(name);
      root.assign(ref, UTILITIES[name](o));
      return root.utilities[name] = ref;
    }
  };
  multident = function (code, tab, includingFirstLine = true) {
    var endsWithNewLine;
    endsWithNewLine = code[code.length - 1] === '\n';
    code = (includingFirstLine ? tab : '') + code.replace(/\n/g, `$&${tab}`);
    code = code.replace(/\s+$/, '');
    if (endsWithNewLine) {
      code = code + '\n';
    }
    return code;
  };

  // Wherever in CoffeeScript 1 we mightve inserted a `makeCode "#{@tab}"` to
  // indent a line of code, now we must account for the possibility of comments
  // preceding that line of code. If there are such comments, indent each line of
  // such comments, and _then_ indent the first following line of code.
  indentInitial = function (fragments, node) {
    var fragment, fragmentIndex, j, len1;
    for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {
      fragment = fragments[fragmentIndex];
      if (fragment.isHereComment) {
        fragment.code = multident(fragment.code, node.tab);
      } else {
        fragments.splice(fragmentIndex, 0, node.makeCode(`${node.tab}`));
        break;
      }
    }
    return fragments;
  };
  hasLineComments = function (node) {
    var comment, j, len1, ref1;
    if (!node.comments) {
      return false;
    }
    ref1 = node.comments;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      comment = ref1[j];
      if (comment.here === false) {
        return true;
      }
    }
    return false;
  };

  // Move the `comments` property from one object to another, deleting it from
  // the first object.
  moveComments = function (from, to) {
    if (!(from != null ? from.comments : void 0)) {
      return;
    }
    attachCommentsToNode(from.comments, to);
    return delete from.comments;
  };

  // Sometimes when compiling a node, we want to insert a fragment at the start
  // of an array of fragments; but if the start has one or more comment fragments,
  // we want to insert this fragment after those but before any non-comments.
  unshiftAfterComments = function (fragments, fragmentToInsert) {
    var fragment, fragmentIndex, inserted, j, len1;
    inserted = false;
    for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {
      fragment = fragments[fragmentIndex];
      if (!!fragment.isComment) {
        continue;
      }
      fragments.splice(fragmentIndex, 0, fragmentToInsert);
      inserted = true;
      break;
    }
    if (!inserted) {
      fragments.push(fragmentToInsert);
    }
    return fragments;
  };
  isLiteralArguments = function (node) {
    return node instanceof IdentifierLiteral && node.value === 'arguments';
  };
  isLiteralThis = function (node) {
    return node instanceof ThisLiteral || node instanceof Code && node.bound;
  };
  shouldCacheOrIsAssignable = function (node) {
    return node.shouldCache() || (typeof node.isAssignable === "function" ? node.isAssignable() : void 0);
  };

  // Unfold a node's child if soak, then tuck the node under created `If`
  unfoldSoak = function (o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

  // Constructs a string or regex by escaping certain characters.
  makeDelimitedLiteral = function (body, {
    delimiter: delimiterOption,
    escapeNewlines,
    double,
    includeDelimiters = true,
    escapeDelimiter = true,
    convertTrailingNullEscapes
  } = {}) {
    var escapeTemplateLiteralCurlies, printedDelimiter, regex;
    if (body === '' && delimiterOption === '/') {
      body = '(?:)';
    }
    escapeTemplateLiteralCurlies = delimiterOption === '`';
    regex = RegExp(`(\\\\\\\\)|(\\\\0(?=\\d))${convertTrailingNullEscapes ? /|(\\0)$/.source : '' // Escaped backslash. // Trailing null character that could be mistaken as octal escape.
    // Null character mistaken as octal escape.
    // Trailing null character that could be mistaken as octal escape.
    // (Possibly escaped) delimiter.
    // `${` inside template literals must be escaped.
    // (Possibly escaped) newlines.
    // Other escapes.
    }${escapeDelimiter ? RegExp(`|\\\\?(${delimiterOption})`).source : '' // (Possibly escaped) delimiter.
    }${escapeTemplateLiteralCurlies ? /|\\?(\$\{)/.source : '' // `${` inside template literals must be escaped.
    }|\\\\?(?:${escapeNewlines ? '(\n)|' : ''}(\\r)|(\\u2028)|(\\u2029))|(\\\\.)`, "g");
    body = body.replace(regex, function (match, backslash, nul, ...args) {
      var cr, delimiter, lf, ls, other, ps, templateLiteralCurly, trailingNullEscape;
      trailingNullEscape = convertTrailingNullEscapes ? args.shift() : void 0;
      delimiter = escapeDelimiter ? args.shift() : void 0;
      templateLiteralCurly = escapeTemplateLiteralCurlies ? args.shift() : void 0;
      lf = escapeNewlines ? args.shift() : void 0;
      [cr, ls, ps, other] = args;
      switch (false) {
        // Ignore escaped backslashes.
        case !backslash:
          if (double) {
            return backslash + backslash;
          } else {
            return backslash;
          }
        case !nul:
          return '\\x00';
        case !trailingNullEscape:
          return "\\x00";
        case !delimiter:
          return `\\${delimiter}`;
        case !templateLiteralCurly:
          return "\\${";
        case !lf:
          return '\\n';
        case !cr:
          return '\\r';
        case !ls:
          return '\\u2028';
        case !ps:
          return '\\u2029';
        case !other:
          if (double) {
            return `\\${other}`;
          } else {
            return other;
          }
      }
    });
    printedDelimiter = includeDelimiters ? delimiterOption : '';
    return `${printedDelimiter}${body}${printedDelimiter}`;
  };
  sniffDirectives = function (expressions, {
    notFinalExpression
  } = {}) {
    var expression, index, lastIndex, results1, unwrapped;
    index = 0;
    lastIndex = expressions.length - 1;
    results1 = [];
    while (index <= lastIndex) {
      if (index === lastIndex && notFinalExpression) {
        break;
      }
      expression = expressions[index];
      if ((unwrapped = expression != null ? typeof expression.unwrap === "function" ? expression.unwrap() : void 0 : void 0) instanceof PassthroughLiteral && unwrapped.generated) {
        index++;
        continue;
      }
      if (!(expression instanceof Value && expression.isString() && !expression.unwrap().shouldGenerateTemplateLiteral())) {
        break;
      }
      expressions[index] = new Directive(expression).withLocationDataFrom(expression);
      results1.push(index++);
    }
    return results1;
  };
  astAsBlockIfNeeded = function (node, o) {
    var unwrapped;
    unwrapped = node.unwrap();
    if (unwrapped instanceof Block && unwrapped.expressions.length > 1) {
      unwrapped.makeReturn(null, true);
      return unwrapped.ast(o, LEVEL_TOP);
    } else {
      return node.ast(o, LEVEL_PAREN);
    }
  };

  // Helpers for `mergeLocationData` and `mergeAstLocationData` below.
  lesser = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  greater = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  isAstLocGreater = function (a, b) {
    if (a.line > b.line) {
      return true;
    }
    if (a.line !== b.line) {
      return false;
    }
    return a.column > b.column;
  };
  isLocationDataStartGreater = function (a, b) {
    if (a.first_line > b.first_line) {
      return true;
    }
    if (a.first_line !== b.first_line) {
      return false;
    }
    return a.first_column > b.first_column;
  };
  isLocationDataEndGreater = function (a, b) {
    if (a.last_line > b.last_line) {
      return true;
    }
    if (a.last_line !== b.last_line) {
      return false;
    }
    return a.last_column > b.last_column;
  };

  // Take two nodes location data and return a new `locationData` object that
  // encompasses the location data of both nodes. So the new `first_line` value
  // will be the earlier of the two nodes `first_line` values, the new
  // `last_column` the later of the two nodes `last_column` values, etc.

  // If you only want to extend the first nodes location data with the start or
  // end location data of the second node, pass the `justLeading` or `justEnding`
  // options. So e.g. if `first`s range is [4, 5] and `second`s range is [1, 10],
  // youd get:
  // ```
  // mergeLocationData(first, second).range                   # [1, 10]
  // mergeLocationData(first, second, justLeading: yes).range # [1, 5]
  // mergeLocationData(first, second, justEnding:  yes).range # [4, 10]
  // ```
  exports.mergeLocationData = mergeLocationData = function (locationDataA, locationDataB, {
    justLeading,
    justEnding
  } = {}) {
    return Object.assign(justEnding ? {
      first_line: locationDataA.first_line,
      first_column: locationDataA.first_column
    } : isLocationDataStartGreater(locationDataA, locationDataB) ? {
      first_line: locationDataB.first_line,
      first_column: locationDataB.first_column
    } : {
      first_line: locationDataA.first_line,
      first_column: locationDataA.first_column
    }, justLeading ? {
      last_line: locationDataA.last_line,
      last_column: locationDataA.last_column,
      last_line_exclusive: locationDataA.last_line_exclusive,
      last_column_exclusive: locationDataA.last_column_exclusive
    } : isLocationDataEndGreater(locationDataA, locationDataB) ? {
      last_line: locationDataA.last_line,
      last_column: locationDataA.last_column,
      last_line_exclusive: locationDataA.last_line_exclusive,
      last_column_exclusive: locationDataA.last_column_exclusive
    } : {
      last_line: locationDataB.last_line,
      last_column: locationDataB.last_column,
      last_line_exclusive: locationDataB.last_line_exclusive,
      last_column_exclusive: locationDataB.last_column_exclusive
    }, {
      range: [justEnding ? locationDataA.range[0] : lesser(locationDataA.range[0], locationDataB.range[0]), justLeading ? locationDataA.range[1] : greater(locationDataA.range[1], locationDataB.range[1])]
    });
  };

  // Take two AST nodes, or two AST nodes location data objects, and return a new
  // location data object that encompasses the location data of both nodes. So the
  // new `start` value will be the earlier of the two nodes `start` values, the
  // new `end` value will be the later of the two nodes `end` values, etc.

  // If you only want to extend the first nodes location data with the start or
  // end location data of the second node, pass the `justLeading` or `justEnding`
  // options. So e.g. if `first`s range is [4, 5] and `second`s range is [1, 10],
  // youd get:
  // ```
  // mergeAstLocationData(first, second).range                   # [1, 10]
  // mergeAstLocationData(first, second, justLeading: yes).range # [1, 5]
  // mergeAstLocationData(first, second, justEnding:  yes).range # [4, 10]
  // ```
  exports.mergeAstLocationData = mergeAstLocationData = function (nodeA, nodeB, {
    justLeading,
    justEnding
  } = {}) {
    return {
      loc: {
        start: justEnding ? nodeA.loc.start : isAstLocGreater(nodeA.loc.start, nodeB.loc.start) ? nodeB.loc.start : nodeA.loc.start,
        end: justLeading ? nodeA.loc.end : isAstLocGreater(nodeA.loc.end, nodeB.loc.end) ? nodeA.loc.end : nodeB.loc.end
      },
      range: [justEnding ? nodeA.range[0] : lesser(nodeA.range[0], nodeB.range[0]), justLeading ? nodeA.range[1] : greater(nodeA.range[1], nodeB.range[1])],
      start: justEnding ? nodeA.start : lesser(nodeA.start, nodeB.start),
      end: justLeading ? nodeA.end : greater(nodeA.end, nodeB.end)
    };
  };

  // Convert Jison-style node class location data to Babel-style location data
  exports.jisonLocationDataToAstLocationData = jisonLocationDataToAstLocationData = function ({
    first_line,
    first_column,
    last_line_exclusive,
    last_column_exclusive,
    range
  }) {
    return {
      loc: {
        start: {
          line: first_line + 1,
          column: first_column
        },
        end: {
          line: last_line_exclusive + 1,
          column: last_column_exclusive
        }
      },
      range: [range[0], range[1]],
      start: range[0],
      end: range[1]
    };
  };

  // Generate a zero-width location data that corresponds to the end of another nodes location.
  zeroWidthLocationDataFromEndLocation = function ({
    range: [, endRange],
    last_line_exclusive,
    last_column_exclusive
  }) {
    return {
      first_line: last_line_exclusive,
      first_column: last_column_exclusive,
      last_line: last_line_exclusive,
      last_column: last_column_exclusive,
      last_line_exclusive,
      last_column_exclusive,
      range: [endRange, endRange]
    };
  };
  extractSameLineLocationDataFirst = function (numChars) {
    return function ({
      range: [startRange],
      first_line,
      first_column
    }) {
      return {
        first_line,
        first_column,
        last_line: first_line,
        last_column: first_column + numChars - 1,
        last_line_exclusive: first_line,
        last_column_exclusive: first_column + numChars,
        range: [startRange, startRange + numChars]
      };
    };
  };
  extractSameLineLocationDataLast = function (numChars) {
    return function ({
      range: [, endRange],
      last_line,
      last_column,
      last_line_exclusive,
      last_column_exclusive
    }) {
      return {
        first_line: last_line,
        first_column: last_column - (numChars - 1),
        last_line: last_line,
        last_column: last_column,
        last_line_exclusive,
        last_column_exclusive,
        range: [endRange - numChars, endRange]
      };
    };
  };

  // We dont currently have a token corresponding to the empty space
  // between interpolation/JSX expression braces, so piece together the location
  // data by trimming the braces from the Interpolations location data.
  // Technically the last_line/last_column calculation here could be
  // incorrect if the ending brace is preceded by a newline, but
  // last_line/last_column arent used for AST generation anyway.
  emptyExpressionLocationData = function ({
    interpolationNode: element,
    openingBrace,
    closingBrace
  }) {
    return {
      first_line: element.locationData.first_line,
      first_column: element.locationData.first_column + openingBrace.length,
      last_line: element.locationData.last_line,
      last_column: element.locationData.last_column - closingBrace.length,
      last_line_exclusive: element.locationData.last_line,
      last_column_exclusive: element.locationData.last_column,
      range: [element.locationData.range[0] + openingBrace.length, element.locationData.range[1] - closingBrace.length]
    };
  };
}).call(void 0);
}),
/* --- external:child_process --- */
"external:child_process": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
if (typeof require === "function") {
	module.exports = require("child_process");
} else if (typeof childProcess !== "undefined") {
	module.exports = childProcess;
} else if (typeof ChildProcess !== "undefined") {
	module.exports = ChildProcess;
} else {
	if ("production" !== "production") {
		console.warn("Failed to load external " + "child_process" + ". An empty module will be used instead, but this might cause problems in your code. Consider using a custom resolver to shim this external.");
	}
	module.exports = {};
}
}),
/* --- node_modules/yaml/dist/compose/compose-node.js --- */
"node_modules/yaml/dist/compose/compose-node.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Alias = _kame_require_("node_modules/yaml/dist/nodes/Alias.js");
var composeCollection = _kame_require_("node_modules/yaml/dist/compose/compose-collection.js");
var composeScalar = _kame_require_("node_modules/yaml/dist/compose/compose-scalar.js");
var resolveEnd = _kame_require_("node_modules/yaml/dist/compose/resolve-end.js");
var utilEmptyScalarPosition = _kame_require_("node_modules/yaml/dist/compose/util-empty-scalar-position.js");
const CN = {
  composeNode,
  composeEmptyNode
};
function composeNode(ctx, token, props, onError) {
  const {
    spaceBefore,
    comment,
    anchor,
    tag
  } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case 'alias':
      node = composeAlias(ctx, token, onError);
      if (anchor || tag) onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
      break;
    case 'scalar':
    case 'single-quoted-scalar':
    case 'double-quoted-scalar':
    case 'block-scalar':
      node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) node.anchor = anchor.source.substring(1);
      break;
    case 'block-map':
    case 'block-seq':
    case 'flow-collection':
      node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
      if (anchor) node.anchor = anchor.source.substring(1);
      break;
    default:
      {
        const message = token.type === 'error' ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, 'UNEXPECTED_TOKEN', message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
  }
  if (anchor && node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
  if (spaceBefore) node.spaceBefore = true;
  if (comment) {
    if (token.type === 'scalar' && token.source === '') node.comment = comment;else node.commentBefore = comment;
  }
  // @ts-expect-error Type checking misses meaning of isSrcToken
  if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, {
  spaceBefore,
  comment,
  anchor,
  tag,
  end
}, onError) {
  const token = {
    type: 'scalar',
    offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ''
  };
  const node = composeScalar.composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
  }
  if (spaceBefore) node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({
  options
}, {
  offset,
  source,
  end
}, onError) {
  const alias = new Alias.Alias(source.substring(1));
  if (alias.source === '') onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
  if (alias.source.endsWith(':')) onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
  const valueEnd = offset + source.length;
  const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment) alias.comment = re.comment;
  return alias;
}
exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;
}),
/* --- node_modules/yaml/dist/compose/resolve-props.js --- */
"node_modules/yaml/dist/compose/resolve-props.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

function resolveProps(tokens, {
  flow,
  indicator,
  next,
  offset,
  onError,
  startOnNewline
}) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = '';
  let commentSep = '';
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== 'space' && token.type !== 'newline' && token.type !== 'comma') onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
      reqSpace = false;
    }
    switch (token.type) {
      case 'space':
        // At the doc level, tabs at line start may be parsed
        // as leading white space rather than indentation.
        // In a flow collection, only the parser handles indent.
        if (!flow && atNewline && indicator !== 'doc-start' && token.source[0] === '\t') onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
        hasSpace = true;
        break;
      case 'comment':
        {
          if (!hasSpace) onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
          const cb = token.source.substring(1) || ' ';
          if (!comment) comment = cb;else comment += commentSep + cb;
          commentSep = '';
          atNewline = false;
          break;
        }
      case 'newline':
        if (atNewline) {
          if (comment) comment += token.source;else spaceBefore = true;
        } else commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag) hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case 'anchor':
        if (anchor) onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
        if (token.source.endsWith(':')) onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
        anchor = token;
        if (start === null) start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case 'tag':
        {
          if (tag) onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
          tag = token;
          if (start === null) start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
      case indicator:
        // Could here handle preceding comments differently
        if (anchor || tag) onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
        if (found) onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case 'comma':
        if (flow) {
          if (comma) onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== 'space' && next.type !== 'newline' && next.type !== 'comma' && (next.type !== 'scalar' || next.source !== '')) onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start ?? end
  };
}
exports.resolveProps = resolveProps;
}),
/* --- node_modules/yaml/dist/stringify/stringifyComment.js --- */
"node_modules/yaml/dist/stringify/stringifyComment.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = str => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment)) return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n') ? indentComment(comment, indent) : comment.includes('\n') ? '\n' + indentComment(comment, indent) : (str.endsWith(' ') ? '' : ' ') + comment;
exports.indentComment = indentComment;
exports.lineComment = lineComment;
exports.stringifyComment = stringifyComment;
}),
/* --- node_modules/yaml/dist/stringify/stringifyString.js --- */
"node_modules/yaml/dist/stringify/stringifyString.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var foldFlowLines = _kame_require_("node_modules/yaml/dist/stringify/foldFlowLines.js");
const getFoldOptions = ctx => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0) return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit) return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === '\n') {
      if (i - start > limit) return true;
      start = i + 1;
      if (strLen - start <= limit) return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON) return json;
  const {
    implicitKey
  } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  let str = '';
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
      // space before newline needs to be escaped to not be folded
      str += json.slice(start, i) + '\\ ';
      i += 1;
      start = i;
      ch = '\\';
    }
    if (ch === '\\') switch (json[i + 1]) {
      case 'u':
        {
          str += json.slice(start, i);
          const code = json.substr(i + 2, 4);
          switch (code) {
            case '0000':
              str += '\\0';
              break;
            case '0007':
              str += '\\a';
              break;
            case '000b':
              str += '\\v';
              break;
            case '001b':
              str += '\\e';
              break;
            case '0085':
              str += '\\N';
              break;
            case '00a0':
              str += '\\_';
              break;
            case '2028':
              str += '\\L';
              break;
            case '2029':
              str += '\\P';
              break;
            default:
              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
          }
          i += 5;
          start = i + 1;
        }
        break;
      case 'n':
        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
          i += 1;
        } else {
          // folding will eat first newline
          str += json.slice(start, i) + '\n\n';
          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
            str += '\n';
            i += 2;
          }
          str += indent;
          // space after newline needs to be escaped to not be folded
          if (json[i + 2] === ' ') str += '\\';
          i += 1;
          start = i + 1;
        }
        break;
      default:
        i += 1;
    }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes('\n') || /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
  ) return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const {
    singleQuote
  } = ctx.options;
  let qs;
  if (singleQuote === false) qs = doubleQuotedString;else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle) qs = singleQuotedString;else if (hasSingle && !hasDouble) qs = doubleQuotedString;else qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({
  comment,
  type,
  value
}, ctx, onComment, onChompKeep) {
  const {
    blockQuote,
    commentString,
    lineWidth
  } = ctx.options;
  // 1. Block can't end in whitespace unless the last line is non-empty.
  // 2. Strings consisting of only whitespace are best rendered explicitly.
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
  const literal = blockQuote === 'literal' ? true : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value) return literal ? '|\n' : '>\n';
  // determine chomping from whitespace at value end
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== '\n' && ch !== '\t' && ch !== ' ') break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf('\n');
  if (endNlPos === -1) {
    chomp = '-'; // strip
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = '+'; // keep
    if (onChompKeep) onChompKeep();
  } else {
    chomp = ''; // clip
  }

  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === '\n') end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  // determine indent indicator from whitespace at value start
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === ' ') startWithSpace = true;else if (ch === '\n') startNlPos = startEnd;else break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? '2' : '1'; // root is at -1
  let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
  if (comment) {
    header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
    if (onComment) onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}\n${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
  //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
  .replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const {
    type,
    value
  } = item;
  const {
    actualString,
    implicitKey,
    indent,
    inFlow
  } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || !value.includes('\n') ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes('\n')) {
    // Where allowed & type not set explicitly, prefer block style for multiline strings
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === '' && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value.replace(/\n+/g, `$&\n${indent}`);
  // Verify that output will be parsed as a string, as e.g. plain numbers and
  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
  // and others in v1.1.
  if (actualString) {
    const test = tag => {
      var _tag$test;
      return tag.default && tag.tag !== 'tag:yaml.org,2002:str' && ((_tag$test = tag.test) === null || _tag$test === void 0 ? void 0 : _tag$test.test(str));
    };
    const {
      compat,
      tags
    } = ctx.doc.schema;
    if (tags.some(test) || compat !== null && compat !== void 0 && compat.some(test)) return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const {
    implicitKey,
    inFlow
  } = ctx;
  const ss = typeof item.value === 'string' ? item : Object.assign({}, item, {
    value: String(item.value)
  });
  let {
    type
  } = item;
  if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
    // force double quotes on control characters & unpaired surrogates
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = Scalar.Scalar.QUOTE_DOUBLE;
  }
  const _stringify = _type => {
    switch (_type) {
      case Scalar.Scalar.BLOCK_FOLDED:
      case Scalar.Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
        : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const {
      defaultKeyType,
      defaultStringType
    } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null) throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
exports.stringifyString = stringifyString;
}),
/* --- node_modules/yaml/dist/schema/common/null.js --- */
"node_modules/yaml/dist/schema/common/null.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
const nullTag = {
  identify: value => value == null,
  createNode: () => new Scalar.Scalar(null),
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar.Scalar(null),
  stringify: ({
    source
  }, ctx) => typeof source === 'string' && nullTag.test.test(source) ? source : ctx.options.nullStr
};
exports.nullTag = nullTag;
}),
/* --- node_modules/yaml/dist/schema/core/bool.js --- */
"node_modules/yaml/dist/schema/core/bool.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
const boolTag = {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
  stringify({
    source,
    value
  }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === 't' || source[0] === 'T';
      if (value === sv) return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};
exports.boolTag = boolTag;
}),
/* --- node_modules/yaml/dist/schema/core/float.js --- */
"node_modules/yaml/dist/schema/core/float.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var stringifyNumber = _kame_require_("node_modules/yaml/dist/stringify/stringifyNumber.js");
const floatNaN = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: str => str.slice(-3).toLowerCase() === 'nan' ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
  }
};
const float = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar.Scalar(parseFloat(str));
    const dot = str.indexOf('.');
    if (dot !== -1 && str[str.length - 1] === '0') node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber.stringifyNumber
};
exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;
}),
/* --- node_modules/yaml/dist/schema/core/int.js --- */
"node_modules/yaml/dist/schema/core/int.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var stringifyNumber = _kame_require_("node_modules/yaml/dist/stringify/stringifyNumber.js");
const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);
const intResolve = (str, offset, radix, {
  intAsBigInt
}) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const {
    value
  } = node;
  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
  return stringifyNumber.stringifyNumber(node);
}
const intOct = {
  identify: value => intIdentify(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: node => intStringify(node, 8, '0o')
};
const int = {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber.stringifyNumber
};
const intHex = {
  identify: value => intIdentify(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: node => intStringify(node, 16, '0x')
};
exports.int = int;
exports.intHex = intHex;
exports.intOct = intOct;
}),
/* --- node_modules/yaml/dist/schema/core/schema.js --- */
"node_modules/yaml/dist/schema/core/schema.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var map = _kame_require_("node_modules/yaml/dist/schema/common/map.js");
var _null = _kame_require_("node_modules/yaml/dist/schema/common/null.js");
var seq = _kame_require_("node_modules/yaml/dist/schema/common/seq.js");
var string = _kame_require_("node_modules/yaml/dist/schema/common/string.js");
var bool = _kame_require_("node_modules/yaml/dist/schema/core/bool.js");
var float = _kame_require_("node_modules/yaml/dist/schema/core/float.js");
var int = _kame_require_("node_modules/yaml/dist/schema/core/int.js");
const schema = [map.map, seq.seq, string.string, _null.nullTag, bool.boolTag, int.intOct, int.int, int.intHex, float.floatNaN, float.floatExp, float.float];
exports.schema = schema;
}),
/* --- node_modules/yaml/dist/schema/json/schema.js --- */
"node_modules/yaml/dist/schema/json/schema.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var map = _kame_require_("node_modules/yaml/dist/schema/common/map.js");
var seq = _kame_require_("node_modules/yaml/dist/schema/common/seq.js");
function intIdentify(value) {
  return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({
  value
}) => JSON.stringify(value);
const jsonScalars = [{
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: str => str,
  stringify: stringifyJSON
}, {
  identify: value => value == null,
  createNode: () => new Scalar.Scalar(null),
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^null$/,
  resolve: () => null,
  stringify: stringifyJSON
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^true|false$/,
  resolve: str => str === 'true',
  stringify: stringifyJSON
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^-?(?:0|[1-9][0-9]*)$/,
  resolve: (str, _onError, {
    intAsBigInt
  }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
  stringify: ({
    value
  }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
  resolve: str => parseFloat(str),
  stringify: stringifyJSON
}];
const jsonError = {
  default: true,
  tag: '',
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
exports.schema = schema;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/binary.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/binary.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var stringifyString = _kame_require_("node_modules/yaml/dist/stringify/stringifyString.js");
const binary = {
  identify: value => value instanceof Uint8Array,
  default: false,
  tag: 'tag:yaml.org,2002:binary',
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof Buffer === 'function') {
      return Buffer.from(src, 'base64');
    } else if (typeof atob === 'function') {
      // On IE 11, atob() can't handle newlines
      const str = atob(src.replace(/[\n\r]/g, ''));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError('This environment does not support reading binary tags; either Buffer or atob is required');
      return src;
    }
  },
  stringify({
    comment,
    type,
    value
  }, ctx, onComment, onChompKeep) {
    const buf = value; // checked earlier by binary.identify()
    let str;
    if (typeof Buffer === 'function') {
      str = buf instanceof Buffer ? buf.toString('base64') : Buffer.from(buf.buffer).toString('base64');
    } else if (typeof btoa === 'function') {
      let s = '';
      for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
    }
    if (!type) type = Scalar.Scalar.BLOCK_LITERAL;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
    }
    return stringifyString.stringifyString({
      comment,
      type,
      value: str
    }, ctx, onComment, onChompKeep);
  }
};
exports.binary = binary;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/omap.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/omap.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var YAMLSeq = _kame_require_("node_modules/yaml/dist/nodes/YAMLSeq.js");
var toJS = _kame_require_("node_modules/yaml/dist/nodes/toJS.js");
var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var YAMLMap = _kame_require_("node_modules/yaml/dist/nodes/YAMLMap.js");
var pairs = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/pairs.js");
class YAMLOMap extends YAMLSeq.YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx) return super.toJSON(_);
    const map = new Map();
    if (ctx !== null && ctx !== void 0 && ctx.onCreate) ctx.onCreate(map);
    for (const pair of this.items) {
      let key, value;
      if (Node.isPair(pair)) {
        key = toJS.toJS(pair.key, '', ctx);
        value = toJS.toJS(pair.value, key, ctx);
      } else {
        key = toJS.toJS(pair, '', ctx);
      }
      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
      map.set(key, value);
    }
    return map;
  }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
  collection: 'seq',
  identify: value => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: 'tag:yaml.org,2002:omap',
  resolve(seq, onError) {
    const pairs$1 = pairs.resolvePairs(seq, onError);
    const seenKeys = [];
    for (const {
      key
    } of pairs$1.items) {
      if (Node.isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs$1);
  },
  createNode(schema, iterable, ctx) {
    const pairs$1 = pairs.createPairs(schema, iterable, ctx);
    const omap = new YAMLOMap();
    omap.items = pairs$1.items;
    return omap;
  }
};
exports.YAMLOMap = YAMLOMap;
exports.omap = omap;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/pairs.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/pairs.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Pair = _kame_require_("node_modules/yaml/dist/nodes/Pair.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var YAMLSeq = _kame_require_("node_modules/yaml/dist/nodes/YAMLSeq.js");
function resolvePairs(seq, onError) {
  if (Node.isSeq(seq)) {
    for (let i = 0; i < seq.items.length; ++i) {
      let item = seq.items[i];
      if (Node.isPair(item)) continue;else if (Node.isMap(item)) {
        if (item.items.length > 1) onError('Each pair must have its own sequence indicator');
        const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
        if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);
    }
  } else onError('Expected a sequence for this tag');
  return seq;
}
function createPairs(schema, iterable, ctx) {
  const {
    replacer
  } = ctx;
  const pairs = new YAMLSeq.YAMLSeq(schema);
  pairs.tag = 'tag:yaml.org,2002:pairs';
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
    if (typeof replacer === 'function') it = replacer.call(iterable, String(i++), it);
    let key, value;
    if (Array.isArray(it)) {
      if (it.length === 2) {
        key = it[0];
        value = it[1];
      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
    } else if (it && it instanceof Object) {
      const keys = Object.keys(it);
      if (keys.length === 1) {
        key = keys[0];
        value = it[key];
      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
    } else {
      key = it;
    }
    pairs.items.push(Pair.createPair(key, value, ctx));
  }
  return pairs;
}
const pairs = {
  collection: 'seq',
  default: false,
  tag: 'tag:yaml.org,2002:pairs',
  resolve: resolvePairs,
  createNode: createPairs
};
exports.createPairs = createPairs;
exports.pairs = pairs;
exports.resolvePairs = resolvePairs;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/schema.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/schema.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var map = _kame_require_("node_modules/yaml/dist/schema/common/map.js");
var _null = _kame_require_("node_modules/yaml/dist/schema/common/null.js");
var seq = _kame_require_("node_modules/yaml/dist/schema/common/seq.js");
var string = _kame_require_("node_modules/yaml/dist/schema/common/string.js");
var binary = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/binary.js");
var bool = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/bool.js");
var float = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/float.js");
var int = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/int.js");
var omap = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/omap.js");
var pairs = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/pairs.js");
var set = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/set.js");
var timestamp = _kame_require_("node_modules/yaml/dist/schema/yaml-1.1/timestamp.js");
const schema = [map.map, seq.seq, string.string, _null.nullTag, bool.trueTag, bool.falseTag, int.intBin, int.intOct, int.int, int.intHex, float.floatNaN, float.floatExp, float.float, binary.binary, omap.omap, pairs.pairs, set.set, timestamp.intTime, timestamp.floatTime, timestamp.timestamp];
exports.schema = schema;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/set.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/set.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Pair = _kame_require_("node_modules/yaml/dist/nodes/Pair.js");
var YAMLMap = _kame_require_("node_modules/yaml/dist/nodes/YAMLMap.js");
class YAMLSet extends YAMLMap.YAMLMap {
  constructor(schema) {
    super(schema);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (Node.isPair(key)) pair = key;else if (key && typeof key === 'object' && 'key' in key && 'value' in key && key.value === null) pair = new Pair.Pair(key.key, null);else pair = new Pair.Pair(key, null);
    const prev = YAMLMap.findPair(this.items, pair.key);
    if (!prev) this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = YAMLMap.findPair(this.items, key);
    return !keepPair && Node.isPair(pair) ? Node.isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = YAMLMap.findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair.Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, ctx, {
      allNullValues: true
    }), onComment, onChompKeep);else throw new Error('Set items must all have null values');
  }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
  collection: 'map',
  identify: value => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: 'tag:yaml.org,2002:set',
  resolve(map, onError) {
    if (Node.isMap(map)) {
      if (map.hasAllNullValues(true)) return Object.assign(new YAMLSet(), map);else onError('Set items must all have null values');
    } else onError('Expected a mapping for this tag');
    return map;
  },
  createNode(schema, iterable, ctx) {
    const {
      replacer
    } = ctx;
    const set = new YAMLSet(schema);
    if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable) {
      if (typeof replacer === 'function') value = replacer.call(iterable, value, value);
      set.items.push(Pair.createPair(value, null, ctx));
    }
    return set;
  }
};
exports.YAMLSet = YAMLSet;
exports.set = set;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/timestamp.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/timestamp.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var stringifyNumber = _kame_require_("node_modules/yaml/dist/stringify/stringifyNumber.js");

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
  const num = n => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, '').split(':').reduce((res, p) => res * num(60) + num(p), num(0));
  return sign === '-' ? num(-1) * res : res;
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
  let {
    value
  } = node;
  let num = n => n;
  if (typeof value === 'bigint') num = n => BigInt(n);else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
  let sign = '';
  if (value < 0) {
    sign = '-';
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60]; // seconds, including ms
  if (value < 60) {
    parts.unshift(0); // at least one : is required
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60); // minutes
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value); // hours
    }
  }

  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
  ;
}

const intTime = {
  identify: value => typeof value === 'bigint' || Number.isInteger(value),
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'TIME',
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, {
    intAsBigInt
  }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
const floatTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'TIME',
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: str => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
const timestamp = {
  identify: value => value instanceof Date,
  default: true,
  tag: 'tag:yaml.org,2002:timestamp',
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' +
  // YYYY-Mm-Dd
  '(?:' +
  // time is optional
  '(?:t|T|[ \\t]+)' +
  // t | T | whitespace
  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' +
  // Hh:Mm:Ss(.ss)?
  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' +
  // Z | +5 | -03:30
  ')?$'),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match) throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== 'Z') {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30) d *= 60;
      date -= 60000 * d;
    }
    return new Date(date);
  },
  stringify: ({
    value
  }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};
exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;
}),
/* --- node_modules/yaml/dist/compose/resolve-block-scalar.js --- */
"node_modules/yaml/dist/compose/resolve-block-scalar.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header) return {
    value: '',
    type: null,
    comment: '',
    range: [start, start, start]
  };
  const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  // determine the end of content & start of chomping
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === '' || content === '\r') chompStart = i;else break;
  }
  // shortcut for empty contents
  if (chompStart === 0) {
    const value = header.chomp === '+' && lines.length > 0 ? '\n'.repeat(Math.max(1, lines.length - 1)) : '';
    let end = start + header.length;
    if (scalar.source) end += scalar.source.length;
    return {
      value,
      type,
      comment: header.comment,
      range: [start, end, end]
    };
  }
  // find the indentation level to trim from start
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === '' || content === '\r') {
      if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
        onError(offset + indent.length, 'MISSING_CHAR', message);
      }
      if (header.indent === 0) trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  // include trailing more-indented empty lines in content
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent) chompStart = i + 1;
  }
  let value = '';
  let sep = '';
  let prevMoreIndented = false;
  // leading whitespace is kept intact
  for (let i = 0; i < contentStart; ++i) value += lines[i][0].slice(trimIndent) + '\n';
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === '\r';
    if (crlf) content = content.slice(0, -1);
    /* istanbul ignore if already caught in lexer */
    if (content && indent.length < trimIndent) {
      const src = header.indent ? 'explicit indentation indicator' : 'first line';
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
      indent = '';
    }
    if (type === Scalar.Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = '\n';
    } else if (indent.length > trimIndent || content[0] === '\t') {
      // more-indented content within a folded block
      if (sep === ' ') sep = '\n';else if (!prevMoreIndented && sep === '\n') sep = '\n\n';
      value += sep + indent.slice(trimIndent) + content;
      sep = '\n';
      prevMoreIndented = true;
    } else if (content === '') {
      // empty line
      if (sep === '\n') value += '\n';else sep = '\n';
    } else {
      value += sep + content;
      sep = ' ';
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case '-':
      break;
    case '+':
      for (let i = chompStart; i < lines.length; ++i) value += '\n' + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== '\n') value += '\n';
      break;
    default:
      value += '\n';
  }
  const end = start + header.length + scalar.source.length;
  return {
    value,
    type,
    comment: header.comment,
    range: [start, end, end]
  };
}
function parseBlockScalarHeader({
  offset,
  props
}, strict, onError) {
  /* istanbul ignore if should not happen */
  if (props[0].type !== 'block-scalar-header') {
    onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
    return null;
  }
  const {
    source
  } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = '';
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === '-' || ch === '+')) chomp = ch;else {
      const n = Number(ch);
      if (!indent && n) indent = n;else if (error === -1) error = offset + i;
    }
  }
  if (error !== -1) onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = '';
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case 'space':
        hasSpace = true;
      // fallthrough
      case 'newline':
        length += token.source.length;
        break;
      case 'comment':
        if (strict && !hasSpace) {
          const message = 'Comments must be separated from other tokens by white space characters';
          onError(token, 'MISSING_CHAR', message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case 'error':
        onError(token, 'UNEXPECTED_TOKEN', token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default:
        {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, 'UNEXPECTED_TOKEN', message);
          const ts = token.source;
          if (ts && typeof ts === 'string') length += ts.length;
        }
    }
  }
  return {
    mode,
    indent,
    chomp,
    comment,
    length
  };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m !== null && m !== void 0 && m[1] ? [m[1], first.slice(m[1].length)] : ['', first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2) lines.push([split[i], split[i + 1]]);
  return lines;
}
exports.resolveBlockScalar = resolveBlockScalar;
}),
/* --- node_modules/yaml/dist/compose/resolve-flow-scalar.js --- */
"node_modules/yaml/dist/compose/resolve-flow-scalar.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var resolveEnd = _kame_require_("node_modules/yaml/dist/compose/resolve-end.js");
function resolveFlowScalar(scalar, strict, onError) {
  const {
    offset,
    type,
    source,
    end
  } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case 'scalar':
      _type = Scalar.Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case 'single-quoted-scalar':
      _type = Scalar.Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case 'double-quoted-scalar':
      _type = Scalar.Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
      return {
        value: '',
        type: null,
        comment: '',
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = '';
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case '\t':
      badChar = 'a tab character';
      break;
    case ',':
      badChar = 'flow indicator character ,';
      break;
    case '%':
      badChar = 'directive indicator character %';
      break;
    case '|':
    case '>':
      {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
    case '@':
    case '`':
      {
        badChar = `reserved character ${source[0]}`;
        break;
      }
  }
  if (badChar) onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _match;
  /**
   * The negative lookbehind here and in the `re` RegExp is to
   * prevent causing a polynomial search time in certain cases.
   *
   * The try-catch is for Safari, which doesn't support this yet:
   * https://caniuse.com/js-regexp-lookbehind
   */
  let first, line;
  try {
    first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
    line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match) return source;
  let res = match[1];
  let sep = ' ';
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === '') {
      if (sep === '\n') res += sep;else sep = '\n';
    } else {
      res += sep + match[1];
      sep = ' ';
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + (((_match = match) === null || _match === void 0 ? void 0 : _match[1]) ?? '');
}
function doubleQuotedValue(source, onError) {
  let res = '';
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === '\r' && source[i + 1] === '\n') continue;
    if (ch === '\n') {
      const {
        fold,
        offset
      } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === '\\') {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc) res += cc;else if (next === '\n') {
        // skip escaped newlines, but still trim the following line
        next = source[i + 1];
        while (next === ' ' || next === '\t') next = source[++i + 1];
      } else if (next === '\r' && source[i + 1] === '\n') {
        // skip escaped CRLF newlines, but still trim the following line
        next = source[++i + 1];
        while (next === ' ' || next === '\t') next = source[++i + 1];
      } else if (next === 'x' || next === 'u' || next === 'U') {
        const length = {
          x: 2,
          u: 4,
          U: 8
        }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === ' ' || ch === '\t') {
      // trim trailing whitespace
      const wsStart = i;
      let next = source[i + 1];
      while (next === ' ' || next === '\t') next = source[++i + 1];
      if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n')) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1) onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
  return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
  let fold = '';
  let ch = source[offset + 1];
  while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
    if (ch === '\r' && source[offset + 2] !== '\n') break;
    if (ch === '\n') fold += '\n';
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold) fold = ' ';
  return {
    fold,
    offset
  };
}
const escapeCodes = {
  '0': '\0',
  a: '\x07',
  b: '\b',
  e: '\x1b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t',
  v: '\v',
  N: '\u0085',
  _: '\u00a0',
  L: '\u2028',
  P: '\u2029',
  ' ': ' ',
  '"': '"',
  '/': '/',
  '\\': '\\',
  '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
exports.resolveFlowScalar = resolveFlowScalar;
}),
/* --- node_modules/sucrase/dist/parser/traverser/util.js --- */
"node_modules/sucrase/dist/parser/traverser/util.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _index = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");

// ## Parser utilities

// Tests whether parsed token is a contextual keyword.
function isContextual(contextualKeyword) {
  return _base.state.contextualKeyword === contextualKeyword;
}
exports.isContextual = isContextual;
function isLookaheadContextual(contextualKeyword) {
  const l = _index.lookaheadTypeAndKeyword.call(void 0);
  return l.type === _types.TokenType.name && l.contextualKeyword === contextualKeyword;
}
exports.isLookaheadContextual = isLookaheadContextual;

// Consumes contextual keyword if possible.
function eatContextual(contextualKeyword) {
  return _base.state.contextualKeyword === contextualKeyword && _index.eat.call(void 0, _types.TokenType.name);
}
exports.eatContextual = eatContextual;

// Asserts that following token is given contextual keyword.
function expectContextual(contextualKeyword) {
  if (!eatContextual(contextualKeyword)) {
    unexpected();
  }
}
exports.expectContextual = expectContextual;

// Test whether a semicolon can be inserted at the current position.
function canInsertSemicolon() {
  return _index.match.call(void 0, _types.TokenType.eof) || _index.match.call(void 0, _types.TokenType.braceR) || hasPrecedingLineBreak();
}
exports.canInsertSemicolon = canInsertSemicolon;
function hasPrecedingLineBreak() {
  const prevToken = _base.state.tokens[_base.state.tokens.length - 1];
  const lastTokEnd = prevToken ? prevToken.end : 0;
  for (let i = lastTokEnd; i < _base.state.start; i++) {
    const code = _base.input.charCodeAt(i);
    if (code === _charcodes.charCodes.lineFeed || code === _charcodes.charCodes.carriageReturn || code === 0x2028 || code === 0x2029) {
      return true;
    }
  }
  return false;
}
exports.hasPrecedingLineBreak = hasPrecedingLineBreak;
function hasFollowingLineBreak() {
  const nextStart = _index.nextTokenStart.call(void 0);
  for (let i = _base.state.end; i < nextStart; i++) {
    const code = _base.input.charCodeAt(i);
    if (code === _charcodes.charCodes.lineFeed || code === _charcodes.charCodes.carriageReturn || code === 0x2028 || code === 0x2029) {
      return true;
    }
  }
  return false;
}
exports.hasFollowingLineBreak = hasFollowingLineBreak;
function isLineTerminator() {
  return _index.eat.call(void 0, _types.TokenType.semi) || canInsertSemicolon();
}
exports.isLineTerminator = isLineTerminator;

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.
function semicolon() {
  if (!isLineTerminator()) {
    unexpected('Unexpected token, expected ";"');
  }
}
exports.semicolon = semicolon;

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.
function expect(type) {
  const matched = _index.eat.call(void 0, type);
  if (!matched) {
    unexpected(`Unexpected token, expected "${_types.formatTokenType.call(void 0, type)}"`);
  }
}
exports.expect = expect;

/**
 * Transition the parser to an error state. All code needs to be written to naturally unwind in this
 * state, which allows us to backtrack without exceptions and without error plumbing everywhere.
 */
function unexpected(message = "Unexpected token", pos = _base.state.start) {
  if (_base.state.error) {
    return;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const err = new SyntaxError(message);
  err.pos = pos;
  _base.state.error = err;
  _base.state.pos = _base.input.length;
  _index.finishToken.call(void 0, _types.TokenType.eof);
}
exports.unexpected = unexpected;
}),
/* --- node_modules/sucrase/dist/parser/util/identifier.js --- */
"node_modules/sucrase/dist/parser/util/identifier.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _whitespace = _kame_require_("node_modules/sucrase/dist/parser/util/whitespace.js");
function computeIsIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code < 128) return false;
  throw new Error("Should not be called with non-ASCII char code.");
}
const IS_IDENTIFIER_CHAR = new Uint8Array(65536);
exports.IS_IDENTIFIER_CHAR = IS_IDENTIFIER_CHAR;
for (let i = 0; i < 128; i++) {
  exports.IS_IDENTIFIER_CHAR[i] = computeIsIdentifierChar(i) ? 1 : 0;
}
for (let i = 128; i < 65536; i++) {
  exports.IS_IDENTIFIER_CHAR[i] = 1;
}
// Aside from whitespace and newlines, all characters outside the ASCII space are either
// identifier characters or invalid. Since we're not performing code validation, we can just
// treat all invalid characters as identifier characters.
for (const whitespaceChar of _whitespace.WHITESPACE_CHARS) {
  exports.IS_IDENTIFIER_CHAR[whitespaceChar] = 0;
}
exports.IS_IDENTIFIER_CHAR[0x2028] = 0;
exports.IS_IDENTIFIER_CHAR[0x2029] = 0;
const IS_IDENTIFIER_START = exports.IS_IDENTIFIER_CHAR.slice();
exports.IS_IDENTIFIER_START = IS_IDENTIFIER_START;
for (let numChar = _charcodes.charCodes.digit0; numChar <= _charcodes.charCodes.digit9; numChar++) {
  exports.IS_IDENTIFIER_START[numChar] = 0;
}
}),
/* --- node_modules/sucrase/dist/parser/util/whitespace.js --- */
"node_modules/sucrase/dist/parser/util/whitespace.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");

// https://tc39.github.io/ecma262/#sec-white-space
const WHITESPACE_CHARS = [0x0009, 0x000b, 0x000c, _charcodes.charCodes.space, _charcodes.charCodes.nonBreakingSpace, _charcodes.charCodes.oghamSpaceMark, 0x2000,
// EN QUAD
0x2001,
// EM QUAD
0x2002,
// EN SPACE
0x2003,
// EM SPACE
0x2004,
// THREE-PER-EM SPACE
0x2005,
// FOUR-PER-EM SPACE
0x2006,
// SIX-PER-EM SPACE
0x2007,
// FIGURE SPACE
0x2008,
// PUNCTUATION SPACE
0x2009,
// THIN SPACE
0x200a,
// HAIR SPACE
0x202f,
// NARROW NO-BREAK SPACE
0x205f,
// MEDIUM MATHEMATICAL SPACE
0x3000,
// IDEOGRAPHIC SPACE
0xfeff // ZERO WIDTH NO-BREAK SPACE
];

exports.WHITESPACE_CHARS = WHITESPACE_CHARS;
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
exports.skipWhiteSpace = skipWhiteSpace;
const IS_WHITESPACE = new Uint8Array(65536);
exports.IS_WHITESPACE = IS_WHITESPACE;
for (const char of exports.WHITESPACE_CHARS) {
  exports.IS_WHITESPACE[char] = 1;
}
}),
/* --- node_modules/sucrase/dist/parser/tokenizer/readWord.js --- */
"node_modules/sucrase/dist/parser/tokenizer/readWord.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _identifier = _kame_require_("node_modules/sucrase/dist/parser/util/identifier.js");
var _index = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _readWordTree = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/readWordTree.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");

/**
 * Read an identifier, producing either a name token or matching on one of the existing keywords.
 * For performance, we pre-generate big decision tree that we traverse. Each node represents a
 * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if
 * not), and the other 26 values are the transitions to other nodes, or -1 to stop.
 */
function readWord() {
  let treePos = 0;
  let code = 0;
  let pos = _base.state.pos;
  while (pos < _base.input.length) {
    code = _base.input.charCodeAt(pos);
    if (code < _charcodes.charCodes.lowercaseA || code > _charcodes.charCodes.lowercaseZ) {
      break;
    }
    const next = _readWordTree.READ_WORD_TREE[treePos + (code - _charcodes.charCodes.lowercaseA) + 1];
    if (next === -1) {
      break;
    } else {
      treePos = next;
      pos++;
    }
  }
  const keywordValue = _readWordTree.READ_WORD_TREE[treePos];
  if (keywordValue > -1 && !_identifier.IS_IDENTIFIER_CHAR[code]) {
    _base.state.pos = pos;
    if (keywordValue & 1) {
      _index.finishToken.call(void 0, keywordValue >>> 1);
    } else {
      _index.finishToken.call(void 0, _types.TokenType.name, keywordValue >>> 1);
    }
    return;
  }
  while (pos < _base.input.length) {
    const ch = _base.input.charCodeAt(pos);
    if (_identifier.IS_IDENTIFIER_CHAR[ch]) {
      pos++;
    } else if (ch === _charcodes.charCodes.backslash) {
      // \u
      pos += 2;
      if (_base.input.charCodeAt(pos) === _charcodes.charCodes.leftCurlyBrace) {
        while (pos < _base.input.length && _base.input.charCodeAt(pos) !== _charcodes.charCodes.rightCurlyBrace) {
          pos++;
        }
        pos++;
      }
    } else if (ch === _charcodes.charCodes.atSign && _base.input.charCodeAt(pos + 1) === _charcodes.charCodes.atSign) {
      pos += 2;
    } else {
      break;
    }
  }
  _base.state.pos = pos;
  _index.finishToken.call(void 0, _types.TokenType.name);
}
exports.default = readWord;
}),
/* --- node_modules/sucrase/dist/util/getJSXPragmaInfo.js --- */
"node_modules/sucrase/dist/util/getJSXPragmaInfo.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function getJSXPragmaInfo(options) {
  const [base, suffix] = splitPragma(options.jsxPragma || "React.createElement");
  const [fragmentBase, fragmentSuffix] = splitPragma(options.jsxFragmentPragma || "React.Fragment");
  return {
    base,
    suffix,
    fragmentBase,
    fragmentSuffix
  };
}
exports.default = getJSXPragmaInfo;
function splitPragma(pragma) {
  let dotIndex = pragma.indexOf(".");
  if (dotIndex === -1) {
    dotIndex = pragma.length;
  }
  return [pragma.slice(0, dotIndex), pragma.slice(dotIndex)];
}
}),
/* --- node_modules/sucrase/dist/parser/tokenizer/state.js --- */
"node_modules/sucrase/dist/parser/tokenizer/state.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
class Scope {
  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {
    this.startTokenIndex = startTokenIndex;
    this.endTokenIndex = endTokenIndex;
    this.isFunctionScope = isFunctionScope;
  }
}
exports.Scope = Scope;
class StateSnapshot {
  constructor(potentialArrowAt, noAnonFunctionType, inDisallowConditionalTypesContext, tokensLength, scopesLength, pos, type, contextualKeyword, start, end, isType, scopeDepth, error) {
    ;
    this.potentialArrowAt = potentialArrowAt;
    this.noAnonFunctionType = noAnonFunctionType;
    this.inDisallowConditionalTypesContext = inDisallowConditionalTypesContext;
    this.tokensLength = tokensLength;
    this.scopesLength = scopesLength;
    this.pos = pos;
    this.type = type;
    this.contextualKeyword = contextualKeyword;
    this.start = start;
    this.end = end;
    this.isType = isType;
    this.scopeDepth = scopeDepth;
    this.error = error;
  }
}
exports.StateSnapshot = StateSnapshot;
class State {
  constructor() {
    State.prototype.__init.call(this);
    State.prototype.__init2.call(this);
    State.prototype.__init3.call(this);
    State.prototype.__init4.call(this);
    State.prototype.__init5.call(this);
    State.prototype.__init6.call(this);
    State.prototype.__init7.call(this);
    State.prototype.__init8.call(this);
    State.prototype.__init9.call(this);
    State.prototype.__init10.call(this);
    State.prototype.__init11.call(this);
    State.prototype.__init12.call(this);
    State.prototype.__init13.call(this);
  }
  // Used to signify the start of a potential arrow function
  __init() {
    this.potentialArrowAt = -1;
  }

  // Used by Flow to handle an edge case involving function type parsing.
  __init2() {
    this.noAnonFunctionType = false;
  }

  // Used by TypeScript to handle ambiguities when parsing conditional types.
  __init3() {
    this.inDisallowConditionalTypesContext = false;
  }

  // Token store.
  __init4() {
    this.tokens = [];
  }

  // Array of all observed scopes, ordered by their ending position.
  __init5() {
    this.scopes = [];
  }

  // The current position of the tokenizer in the input.
  __init6() {
    this.pos = 0;
  }

  // Information about the current token.
  __init7() {
    this.type = _types.TokenType.eof;
  }
  __init8() {
    this.contextualKeyword = _keywords.ContextualKeyword.NONE;
  }
  __init9() {
    this.start = 0;
  }
  __init10() {
    this.end = 0;
  }
  __init11() {
    this.isType = false;
  }
  __init12() {
    this.scopeDepth = 0;
  }

  /**
   * If the parser is in an error state, then the token is always tt.eof and all functions can
   * keep executing but should be written so they don't get into an infinite loop in this situation.
   *
   * This approach, combined with the ability to snapshot and restore state, allows us to implement
   * backtracking without exceptions and without needing to explicitly propagate error states
   * everywhere.
   */
  __init13() {
    this.error = null;
  }
  snapshot() {
    return new StateSnapshot(this.potentialArrowAt, this.noAnonFunctionType, this.inDisallowConditionalTypesContext, this.tokens.length, this.scopes.length, this.pos, this.type, this.contextualKeyword, this.start, this.end, this.isType, this.scopeDepth, this.error);
  }
  restoreFromSnapshot(snapshot) {
    this.potentialArrowAt = snapshot.potentialArrowAt;
    this.noAnonFunctionType = snapshot.noAnonFunctionType;
    this.inDisallowConditionalTypesContext = snapshot.inDisallowConditionalTypesContext;
    this.tokens.length = snapshot.tokensLength;
    this.scopes.length = snapshot.scopesLength;
    this.pos = snapshot.pos;
    this.type = snapshot.type;
    this.contextualKeyword = snapshot.contextualKeyword;
    this.start = snapshot.start;
    this.end = snapshot.end;
    this.isType = snapshot.isType;
    this.scopeDepth = snapshot.scopeDepth;
    this.error = snapshot.error;
  }
}
exports.default = State;
}),
/* --- node_modules/sucrase/dist/parser/traverser/statement.js --- */
"node_modules/sucrase/dist/parser/traverser/statement.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
}); /* eslint max-len: 0 */

var _index = _kame_require_("node_modules/sucrase/dist/parser/index.js");
var _flow = _kame_require_("node_modules/sucrase/dist/parser/plugins/flow.js");
var _typescript = _kame_require_("node_modules/sucrase/dist/parser/plugins/typescript.js");
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _state = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/state.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _expression = _kame_require_("node_modules/sucrase/dist/parser/traverser/expression.js");
var _lval = _kame_require_("node_modules/sucrase/dist/parser/traverser/lval.js");
var _util = _kame_require_("node_modules/sucrase/dist/parser/traverser/util.js");
function parseTopLevel() {
  parseBlockBody(_types.TokenType.eof);
  _base.state.scopes.push(new (0, _state.Scope)(0, _base.state.tokens.length, true));
  if (_base.state.scopeDepth !== 0) {
    throw new Error(`Invalid scope depth at end of file: ${_base.state.scopeDepth}`);
  }
  return new (0, _index.File)(_base.state.tokens, _base.state.scopes);
}
exports.parseTopLevel = parseTopLevel;

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

function parseStatement(declaration) {
  if (_base.isFlowEnabled) {
    if (_flow.flowTryParseStatement.call(void 0)) {
      return;
    }
  }
  if (_tokenizer.match.call(void 0, _types.TokenType.at)) {
    parseDecorators();
  }
  parseStatementContent(declaration);
}
exports.parseStatement = parseStatement;
function parseStatementContent(declaration) {
  if (_base.isTypeScriptEnabled) {
    if (_typescript.tsTryParseStatementContent.call(void 0)) {
      return;
    }
  }
  const starttype = _base.state.type;

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case _types.TokenType._break:
    case _types.TokenType._continue:
      parseBreakContinueStatement();
      return;
    case _types.TokenType._debugger:
      parseDebuggerStatement();
      return;
    case _types.TokenType._do:
      parseDoStatement();
      return;
    case _types.TokenType._for:
      parseForStatement();
      return;
    case _types.TokenType._function:
      if (_tokenizer.lookaheadType.call(void 0) === _types.TokenType.dot) break;
      if (!declaration) _util.unexpected.call(void 0);
      parseFunctionStatement();
      return;
    case _types.TokenType._class:
      if (!declaration) _util.unexpected.call(void 0);
      parseClass(true);
      return;
    case _types.TokenType._if:
      parseIfStatement();
      return;
    case _types.TokenType._return:
      parseReturnStatement();
      return;
    case _types.TokenType._switch:
      parseSwitchStatement();
      return;
    case _types.TokenType._throw:
      parseThrowStatement();
      return;
    case _types.TokenType._try:
      parseTryStatement();
      return;
    case _types.TokenType._let:
    case _types.TokenType._const:
      if (!declaration) _util.unexpected.call(void 0);
    // NOTE: falls through to _var

    case _types.TokenType._var:
      parseVarStatement(starttype);
      return;
    case _types.TokenType._while:
      parseWhileStatement();
      return;
    case _types.TokenType.braceL:
      parseBlock();
      return;
    case _types.TokenType.semi:
      parseEmptyStatement();
      return;
    case _types.TokenType._export:
    case _types.TokenType._import:
      {
        const nextType = _tokenizer.lookaheadType.call(void 0);
        if (nextType === _types.TokenType.parenL || nextType === _types.TokenType.dot) {
          break;
        }
        _tokenizer.next.call(void 0);
        if (starttype === _types.TokenType._import) {
          parseImport();
        } else {
          parseExport();
        }
        return;
      }
    case _types.TokenType.name:
      if (_base.state.contextualKeyword === _keywords.ContextualKeyword._async) {
        const functionStart = _base.state.start;
        // peek ahead and see if next token is a function
        const snapshot = _base.state.snapshot();
        _tokenizer.next.call(void 0);
        if (_tokenizer.match.call(void 0, _types.TokenType._function) && !_util.canInsertSemicolon.call(void 0)) {
          _util.expect.call(void 0, _types.TokenType._function);
          parseFunction(functionStart, true);
          return;
        } else {
          _base.state.restoreFromSnapshot(snapshot);
        }
      }
    default:
      // Do nothing.
      break;
  }

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  const initialTokensLength = _base.state.tokens.length;
  _expression.parseExpression.call(void 0);
  let simpleName = null;
  if (_base.state.tokens.length === initialTokensLength + 1) {
    const token = _base.state.tokens[_base.state.tokens.length - 1];
    if (token.type === _types.TokenType.name) {
      simpleName = token.contextualKeyword;
    }
  }
  if (simpleName == null) {
    _util.semicolon.call(void 0);
    return;
  }
  if (_tokenizer.eat.call(void 0, _types.TokenType.colon)) {
    parseLabeledStatement();
  } else {
    // This was an identifier, so we might want to handle flow/typescript-specific cases.
    parseIdentifierStatement(simpleName);
  }
}
function parseDecorators() {
  while (_tokenizer.match.call(void 0, _types.TokenType.at)) {
    parseDecorator();
  }
}
exports.parseDecorators = parseDecorators;
function parseDecorator() {
  _tokenizer.next.call(void 0);
  if (_tokenizer.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseExpression.call(void 0);
    _util.expect.call(void 0, _types.TokenType.parenR);
  } else {
    _expression.parseIdentifier.call(void 0);
    while (_tokenizer.eat.call(void 0, _types.TokenType.dot)) {
      _expression.parseIdentifier.call(void 0);
    }
  }
  parseMaybeDecoratorArguments();
}
function parseMaybeDecoratorArguments() {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseMaybeDecoratorArguments.call(void 0);
  } else {
    baseParseMaybeDecoratorArguments();
  }
}
function baseParseMaybeDecoratorArguments() {
  if (_tokenizer.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseCallExpressionArguments.call(void 0);
  }
}
exports.baseParseMaybeDecoratorArguments = baseParseMaybeDecoratorArguments;
function parseBreakContinueStatement() {
  _tokenizer.next.call(void 0);
  if (!_util.isLineTerminator.call(void 0)) {
    _expression.parseIdentifier.call(void 0);
    _util.semicolon.call(void 0);
  }
}
function parseDebuggerStatement() {
  _tokenizer.next.call(void 0);
  _util.semicolon.call(void 0);
}
function parseDoStatement() {
  _tokenizer.next.call(void 0);
  parseStatement(false);
  _util.expect.call(void 0, _types.TokenType._while);
  _expression.parseParenExpression.call(void 0);
  _tokenizer.eat.call(void 0, _types.TokenType.semi);
}
function parseForStatement() {
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  parseAmbiguousForStatement();
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, false));
  _base.state.scopeDepth--;
}

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
function parseAmbiguousForStatement() {
  _tokenizer.next.call(void 0);
  let forAwait = false;
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._await)) {
    forAwait = true;
    _tokenizer.next.call(void 0);
  }
  _util.expect.call(void 0, _types.TokenType.parenL);
  if (_tokenizer.match.call(void 0, _types.TokenType.semi)) {
    if (forAwait) {
      _util.unexpected.call(void 0);
    }
    parseFor();
    return;
  }
  if (_tokenizer.match.call(void 0, _types.TokenType._var) || _tokenizer.match.call(void 0, _types.TokenType._let) || _tokenizer.match.call(void 0, _types.TokenType._const)) {
    const varKind = _base.state.type;
    _tokenizer.next.call(void 0);
    parseVar(true, varKind);
    if (_tokenizer.match.call(void 0, _types.TokenType._in) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._of)) {
      parseForIn(forAwait);
      return;
    }
    parseFor();
    return;
  }
  _expression.parseExpression.call(void 0, true);
  if (_tokenizer.match.call(void 0, _types.TokenType._in) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._of)) {
    parseForIn(forAwait);
    return;
  }
  if (forAwait) {
    _util.unexpected.call(void 0);
  }
  parseFor();
}
function parseFunctionStatement() {
  const functionStart = _base.state.start;
  _tokenizer.next.call(void 0);
  parseFunction(functionStart, true);
}
function parseIfStatement() {
  _tokenizer.next.call(void 0);
  _expression.parseParenExpression.call(void 0);
  parseStatement(false);
  if (_tokenizer.eat.call(void 0, _types.TokenType._else)) {
    parseStatement(false);
  }
}
function parseReturnStatement() {
  _tokenizer.next.call(void 0);

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (!_util.isLineTerminator.call(void 0)) {
    _expression.parseExpression.call(void 0);
    _util.semicolon.call(void 0);
  }
}
function parseSwitchStatement() {
  _tokenizer.next.call(void 0);
  _expression.parseParenExpression.call(void 0);
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  _util.expect.call(void 0, _types.TokenType.braceL);

  // Don't bother validation; just go through any sequence of cases, defaults, and statements.
  while (!_tokenizer.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_tokenizer.match.call(void 0, _types.TokenType._case) || _tokenizer.match.call(void 0, _types.TokenType._default)) {
      const isCase = _tokenizer.match.call(void 0, _types.TokenType._case);
      _tokenizer.next.call(void 0);
      if (isCase) {
        _expression.parseExpression.call(void 0);
      }
      _util.expect.call(void 0, _types.TokenType.colon);
    } else {
      parseStatement(true);
    }
  }
  _tokenizer.next.call(void 0); // Closing brace
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, false));
  _base.state.scopeDepth--;
}
function parseThrowStatement() {
  _tokenizer.next.call(void 0);
  _expression.parseExpression.call(void 0);
  _util.semicolon.call(void 0);
}
function parseCatchClauseParam() {
  _lval.parseBindingAtom.call(void 0, true /* isBlockScope */);

  if (_base.isTypeScriptEnabled) {
    _typescript.tsTryParseTypeAnnotation.call(void 0);
  }
}
function parseTryStatement() {
  _tokenizer.next.call(void 0);
  parseBlock();
  if (_tokenizer.match.call(void 0, _types.TokenType._catch)) {
    _tokenizer.next.call(void 0);
    let catchBindingStartTokenIndex = null;
    if (_tokenizer.match.call(void 0, _types.TokenType.parenL)) {
      _base.state.scopeDepth++;
      catchBindingStartTokenIndex = _base.state.tokens.length;
      _util.expect.call(void 0, _types.TokenType.parenL);
      parseCatchClauseParam();
      _util.expect.call(void 0, _types.TokenType.parenR);
    }
    parseBlock();
    if (catchBindingStartTokenIndex != null) {
      // We need a special scope for the catch binding which includes the binding itself and the
      // catch block.
      const endTokenIndex = _base.state.tokens.length;
      _base.state.scopes.push(new (0, _state.Scope)(catchBindingStartTokenIndex, endTokenIndex, false));
      _base.state.scopeDepth--;
    }
  }
  if (_tokenizer.eat.call(void 0, _types.TokenType._finally)) {
    parseBlock();
  }
}
function parseVarStatement(kind) {
  _tokenizer.next.call(void 0);
  parseVar(false, kind);
  _util.semicolon.call(void 0);
}
exports.parseVarStatement = parseVarStatement;
function parseWhileStatement() {
  _tokenizer.next.call(void 0);
  _expression.parseParenExpression.call(void 0);
  parseStatement(false);
}
function parseEmptyStatement() {
  _tokenizer.next.call(void 0);
}
function parseLabeledStatement() {
  parseStatement(true);
}

/**
 * Parse a statement starting with an identifier of the given name. Subclasses match on the name
 * to handle statements like "declare".
 */
function parseIdentifierStatement(contextualKeyword) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseIdentifierStatement.call(void 0, contextualKeyword);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseIdentifierStatement.call(void 0, contextualKeyword);
  } else {
    _util.semicolon.call(void 0);
  }
}

// Parse a semicolon-enclosed block of statements.
function parseBlock(isFunctionScope = false, contextId = 0) {
  const startTokenIndex = _base.state.tokens.length;
  _base.state.scopeDepth++;
  _util.expect.call(void 0, _types.TokenType.braceL);
  if (contextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  }
  parseBlockBody(_types.TokenType.braceR);
  if (contextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  }
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, isFunctionScope));
  _base.state.scopeDepth--;
}
exports.parseBlock = parseBlock;
function parseBlockBody(end) {
  while (!_tokenizer.eat.call(void 0, end) && !_base.state.error) {
    parseStatement(true);
  }
}
exports.parseBlockBody = parseBlockBody;

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

function parseFor() {
  _util.expect.call(void 0, _types.TokenType.semi);
  if (!_tokenizer.match.call(void 0, _types.TokenType.semi)) {
    _expression.parseExpression.call(void 0);
  }
  _util.expect.call(void 0, _types.TokenType.semi);
  if (!_tokenizer.match.call(void 0, _types.TokenType.parenR)) {
    _expression.parseExpression.call(void 0);
  }
  _util.expect.call(void 0, _types.TokenType.parenR);
  parseStatement(false);
}

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

function parseForIn(forAwait) {
  if (forAwait) {
    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._of);
  } else {
    _tokenizer.next.call(void 0);
  }
  _expression.parseExpression.call(void 0);
  _util.expect.call(void 0, _types.TokenType.parenR);
  parseStatement(false);
}

// Parse a list of variable declarations.

function parseVar(isFor, kind) {
  while (true) {
    const isBlockScope = kind === _types.TokenType._const || kind === _types.TokenType._let;
    parseVarHead(isBlockScope);
    if (_tokenizer.eat.call(void 0, _types.TokenType.eq)) {
      const eqIndex = _base.state.tokens.length - 1;
      _expression.parseMaybeAssign.call(void 0, isFor);
      _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
    }
    if (!_tokenizer.eat.call(void 0, _types.TokenType.comma)) {
      break;
    }
  }
}
function parseVarHead(isBlockScope) {
  _lval.parseBindingAtom.call(void 0, isBlockScope);
  if (_base.isTypeScriptEnabled) {
    _typescript.tsAfterParseVarHead.call(void 0);
  } else if (_base.isFlowEnabled) {
    _flow.flowAfterParseVarHead.call(void 0);
  }
}

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

function parseFunction(functionStart, isStatement, optionalId = false) {
  if (_tokenizer.match.call(void 0, _types.TokenType.star)) {
    _tokenizer.next.call(void 0);
  }
  if (isStatement && !optionalId && !_tokenizer.match.call(void 0, _types.TokenType.name) && !_tokenizer.match.call(void 0, _types.TokenType._yield)) {
    _util.unexpected.call(void 0);
  }
  let nameScopeStartTokenIndex = null;
  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
    // Expression-style functions should limit their name's scope to the function body, so we make
    // a new function scope to enforce that.
    if (!isStatement) {
      nameScopeStartTokenIndex = _base.state.tokens.length;
      _base.state.scopeDepth++;
    }
    _lval.parseBindingIdentifier.call(void 0, false);
  }
  const startTokenIndex = _base.state.tokens.length;
  _base.state.scopeDepth++;
  parseFunctionParams();
  _expression.parseFunctionBodyAndFinish.call(void 0, functionStart);
  const endTokenIndex = _base.state.tokens.length;
  // In addition to the block scope of the function body, we need a separate function-style scope
  // that includes the params.
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
  _base.state.scopeDepth--;
  if (nameScopeStartTokenIndex !== null) {
    _base.state.scopes.push(new (0, _state.Scope)(nameScopeStartTokenIndex, endTokenIndex, true));
    _base.state.scopeDepth--;
  }
}
exports.parseFunction = parseFunction;
function parseFunctionParams(allowModifiers = false, funcContextId = 0) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsStartParseFunctionParams.call(void 0);
  } else if (_base.isFlowEnabled) {
    _flow.flowStartParseFunctionParams.call(void 0);
  }
  _util.expect.call(void 0, _types.TokenType.parenL);
  if (funcContextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;
  }
  _lval.parseBindingList.call(void 0, _types.TokenType.parenR, false /* isBlockScope */, false /* allowEmpty */, allowModifiers, funcContextId);
  if (funcContextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;
  }
}
exports.parseFunctionParams = parseFunctionParams;

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

function parseClass(isStatement, optionalId = false) {
  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later
  // code can easily navigate to meaningful points on the class.
  const contextId = _base.getNextContextId.call(void 0);
  _tokenizer.next.call(void 0);
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  _base.state.tokens[_base.state.tokens.length - 1].isExpression = !isStatement;
  // Like with functions, we declare a special "name scope" from the start of the name to the end
  // of the class, but only with expression-style classes, to represent the fact that the name is
  // available to the body of the class but not an outer declaration.
  let nameScopeStartTokenIndex = null;
  if (!isStatement) {
    nameScopeStartTokenIndex = _base.state.tokens.length;
    _base.state.scopeDepth++;
  }
  parseClassId(isStatement, optionalId);
  parseClassSuper();
  const openBraceIndex = _base.state.tokens.length;
  parseClassBody(contextId);
  if (_base.state.error) {
    return;
  }
  _base.state.tokens[openBraceIndex].contextId = contextId;
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  if (nameScopeStartTokenIndex !== null) {
    const endTokenIndex = _base.state.tokens.length;
    _base.state.scopes.push(new (0, _state.Scope)(nameScopeStartTokenIndex, endTokenIndex, false));
    _base.state.scopeDepth--;
  }
}
exports.parseClass = parseClass;
function isClassProperty() {
  return _tokenizer.match.call(void 0, _types.TokenType.eq) || _tokenizer.match.call(void 0, _types.TokenType.semi) || _tokenizer.match.call(void 0, _types.TokenType.braceR) || _tokenizer.match.call(void 0, _types.TokenType.bang) || _tokenizer.match.call(void 0, _types.TokenType.colon);
}
function isClassMethod() {
  return _tokenizer.match.call(void 0, _types.TokenType.parenL) || _tokenizer.match.call(void 0, _types.TokenType.lessThan);
}
function parseClassBody(classContextId) {
  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_tokenizer.eat.call(void 0, _types.TokenType.semi)) {
      continue;
    }
    if (_tokenizer.match.call(void 0, _types.TokenType.at)) {
      parseDecorator();
      continue;
    }
    const memberStart = _base.state.start;
    parseClassMember(memberStart, classContextId);
  }
}
function parseClassMember(memberStart, classContextId) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseModifiers.call(void 0, [_keywords.ContextualKeyword._declare, _keywords.ContextualKeyword._public, _keywords.ContextualKeyword._protected, _keywords.ContextualKeyword._private, _keywords.ContextualKeyword._override]);
  }
  let isStatic = false;
  if (_tokenizer.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._static) {
    _expression.parseIdentifier.call(void 0); // eats 'static'
    if (isClassMethod()) {
      parseClassMethod(memberStart, /* isConstructor */false);
      return;
    } else if (isClassProperty()) {
      parseClassProperty();
      return;
    }
    // otherwise something static
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
    isStatic = true;
    if (_tokenizer.match.call(void 0, _types.TokenType.braceL)) {
      // This is a static block. Mark the word "static" with the class context ID for class element
      // detection and parse as a regular block.
      _base.state.tokens[_base.state.tokens.length - 1].contextId = classContextId;
      parseBlock();
      return;
    }
  }
  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
}
function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
  if (_base.isTypeScriptEnabled) {
    if (_typescript.tsTryParseClassMemberWithIsStatic.call(void 0, isStatic)) {
      return;
    }
  }
  if (_tokenizer.eat.call(void 0, _types.TokenType.star)) {
    // a generator
    parseClassPropertyName(classContextId);
    parseClassMethod(memberStart, /* isConstructor */false);
    return;
  }

  // Get the identifier name so we can tell if it's actually a keyword like "async", "get", or
  // "set".
  parseClassPropertyName(classContextId);
  let isConstructor = false;
  const token = _base.state.tokens[_base.state.tokens.length - 1];
  // We allow "constructor" as either an identifier or a string.
  if (token.contextualKeyword === _keywords.ContextualKeyword._constructor) {
    isConstructor = true;
  }
  parsePostMemberNameModifiers();
  if (isClassMethod()) {
    parseClassMethod(memberStart, isConstructor);
  } else if (isClassProperty()) {
    parseClassProperty();
  } else if (token.contextualKeyword === _keywords.ContextualKeyword._async && !_util.isLineTerminator.call(void 0)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._async;
    // an async method
    const isGenerator = _tokenizer.match.call(void 0, _types.TokenType.star);
    if (isGenerator) {
      _tokenizer.next.call(void 0);
    }

    // The so-called parsed name would have been "async": get the real name.
    parseClassPropertyName(classContextId);
    parsePostMemberNameModifiers();
    parseClassMethod(memberStart, false /* isConstructor */);
  } else if ((token.contextualKeyword === _keywords.ContextualKeyword._get || token.contextualKeyword === _keywords.ContextualKeyword._set) && !(_util.isLineTerminator.call(void 0) && _tokenizer.match.call(void 0, _types.TokenType.star))) {
    if (token.contextualKeyword === _keywords.ContextualKeyword._get) {
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._get;
    } else {
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._set;
    }
    // `get\n*` is an uninitialized property named 'get' followed by a generator.
    // a getter or setter
    // The so-called parsed name would have been "get/set": get the real name.
    parseClassPropertyName(classContextId);
    parseClassMethod(memberStart, /* isConstructor */false);
  } else if (token.contextualKeyword === _keywords.ContextualKeyword._accessor && !_util.isLineTerminator.call(void 0)) {
    parseClassPropertyName(classContextId);
    parseClassProperty();
  } else if (_util.isLineTerminator.call(void 0)) {
    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
    parseClassProperty();
  } else {
    _util.unexpected.call(void 0);
  }
}
function parseClassMethod(functionStart, isConstructor) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsTryParseTypeParameters.call(void 0);
  } else if (_base.isFlowEnabled) {
    if (_tokenizer.match.call(void 0, _types.TokenType.lessThan)) {
      _flow.flowParseTypeParameterDeclaration.call(void 0);
    }
  }
  _expression.parseMethod.call(void 0, functionStart, isConstructor);
}

// Return the name of the class property, if it is a simple identifier.
function parseClassPropertyName(classContextId) {
  _expression.parsePropertyName.call(void 0, classContextId);
}
exports.parseClassPropertyName = parseClassPropertyName;
function parsePostMemberNameModifiers() {
  if (_base.isTypeScriptEnabled) {
    const oldIsType = _tokenizer.pushTypeContext.call(void 0, 0);
    _tokenizer.eat.call(void 0, _types.TokenType.question);
    _tokenizer.popTypeContext.call(void 0, oldIsType);
  }
}
exports.parsePostMemberNameModifiers = parsePostMemberNameModifiers;
function parseClassProperty() {
  if (_base.isTypeScriptEnabled) {
    _tokenizer.eatTypeToken.call(void 0, _types.TokenType.bang);
    _typescript.tsTryParseTypeAnnotation.call(void 0);
  } else if (_base.isFlowEnabled) {
    if (_tokenizer.match.call(void 0, _types.TokenType.colon)) {
      _flow.flowParseTypeAnnotation.call(void 0);
    }
  }
  if (_tokenizer.match.call(void 0, _types.TokenType.eq)) {
    const equalsTokenIndex = _base.state.tokens.length;
    _tokenizer.next.call(void 0);
    _expression.parseMaybeAssign.call(void 0);
    _base.state.tokens[equalsTokenIndex].rhsEndIndex = _base.state.tokens.length;
  }
  _util.semicolon.call(void 0);
}
exports.parseClassProperty = parseClassProperty;
function parseClassId(isStatement, optionalId = false) {
  if (_base.isTypeScriptEnabled && (!isStatement || optionalId) && _util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
    return;
  }
  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
    _lval.parseBindingIdentifier.call(void 0, true);
  }
  if (_base.isTypeScriptEnabled) {
    _typescript.tsTryParseTypeParameters.call(void 0);
  } else if (_base.isFlowEnabled) {
    if (_tokenizer.match.call(void 0, _types.TokenType.lessThan)) {
      _flow.flowParseTypeParameterDeclaration.call(void 0);
    }
  }
}

// Returns true if there was a superclass.
function parseClassSuper() {
  let hasSuper = false;
  if (_tokenizer.eat.call(void 0, _types.TokenType._extends)) {
    _expression.parseExprSubscripts.call(void 0);
    hasSuper = true;
  } else {
    hasSuper = false;
  }
  if (_base.isTypeScriptEnabled) {
    _typescript.tsAfterParseClassSuper.call(void 0, hasSuper);
  } else if (_base.isFlowEnabled) {
    _flow.flowAfterParseClassSuper.call(void 0, hasSuper);
  }
}

// Parses module export declaration.

function parseExport() {
  const exportIndex = _base.state.tokens.length - 1;
  if (_base.isTypeScriptEnabled) {
    if (_typescript.tsTryParseExport.call(void 0)) {
      return;
    }
  }
  // export * from '...'
  if (shouldParseExportStar()) {
    parseExportStar();
  } else if (isExportDefaultSpecifier()) {
    // export default from
    _expression.parseIdentifier.call(void 0);
    if (_tokenizer.match.call(void 0, _types.TokenType.comma) && _tokenizer.lookaheadType.call(void 0) === _types.TokenType.star) {
      _util.expect.call(void 0, _types.TokenType.comma);
      _util.expect.call(void 0, _types.TokenType.star);
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._as);
      _expression.parseIdentifier.call(void 0);
    } else {
      parseExportSpecifiersMaybe();
    }
    parseExportFrom();
  } else if (_tokenizer.eat.call(void 0, _types.TokenType._default)) {
    // export default ...
    parseExportDefaultExpression();
  } else if (shouldParseExportDeclaration()) {
    parseExportDeclaration();
  } else {
    // export { x, y as z } [from '...']
    parseExportSpecifiers();
    parseExportFrom();
  }
  _base.state.tokens[exportIndex].rhsEndIndex = _base.state.tokens.length;
}
exports.parseExport = parseExport;
function parseExportDefaultExpression() {
  if (_base.isTypeScriptEnabled) {
    if (_typescript.tsTryParseExportDefaultExpression.call(void 0)) {
      return;
    }
  }
  if (_base.isFlowEnabled) {
    if (_flow.flowTryParseExportDefaultExpression.call(void 0)) {
      return;
    }
  }
  const functionStart = _base.state.start;
  if (_tokenizer.eat.call(void 0, _types.TokenType._function)) {
    parseFunction(functionStart, true, true);
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._async) && _tokenizer.lookaheadType.call(void 0) === _types.TokenType._function) {
    // async function declaration
    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._async);
    _tokenizer.eat.call(void 0, _types.TokenType._function);
    parseFunction(functionStart, true, true);
  } else if (_tokenizer.match.call(void 0, _types.TokenType._class)) {
    parseClass(true, true);
  } else if (_tokenizer.match.call(void 0, _types.TokenType.at)) {
    parseDecorators();
    parseClass(true, true);
  } else {
    _expression.parseMaybeAssign.call(void 0);
    _util.semicolon.call(void 0);
  }
}
function parseExportDeclaration() {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseExportDeclaration.call(void 0);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseExportDeclaration.call(void 0);
  } else {
    parseStatement(true);
  }
}
function isExportDefaultSpecifier() {
  if (_base.isTypeScriptEnabled && _typescript.tsIsDeclarationStart.call(void 0)) {
    return false;
  } else if (_base.isFlowEnabled && _flow.flowShouldDisallowExportDefaultSpecifier.call(void 0)) {
    return false;
  }
  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
    return _base.state.contextualKeyword !== _keywords.ContextualKeyword._async;
  }
  if (!_tokenizer.match.call(void 0, _types.TokenType._default)) {
    return false;
  }
  const _next = _tokenizer.nextTokenStart.call(void 0);
  const lookahead = _tokenizer.lookaheadTypeAndKeyword.call(void 0);
  const hasFrom = lookahead.type === _types.TokenType.name && lookahead.contextualKeyword === _keywords.ContextualKeyword._from;
  if (lookahead.type === _types.TokenType.comma) {
    return true;
  }
  // lookahead again when `export default from` is seen
  if (hasFrom) {
    const nextAfterFrom = _base.input.charCodeAt(_tokenizer.nextTokenStartSince.call(void 0, _next + 4));
    return nextAfterFrom === _charcodes.charCodes.quotationMark || nextAfterFrom === _charcodes.charCodes.apostrophe;
  }
  return false;
}
function parseExportSpecifiersMaybe() {
  if (_tokenizer.eat.call(void 0, _types.TokenType.comma)) {
    parseExportSpecifiers();
  }
}
function parseExportFrom() {
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._from)) {
    _expression.parseExprAtom.call(void 0);
    maybeParseImportAssertions();
  }
  _util.semicolon.call(void 0);
}
exports.parseExportFrom = parseExportFrom;
function shouldParseExportStar() {
  if (_base.isFlowEnabled) {
    return _flow.flowShouldParseExportStar.call(void 0);
  } else {
    return _tokenizer.match.call(void 0, _types.TokenType.star);
  }
}
function parseExportStar() {
  if (_base.isFlowEnabled) {
    _flow.flowParseExportStar.call(void 0);
  } else {
    baseParseExportStar();
  }
}
function baseParseExportStar() {
  _util.expect.call(void 0, _types.TokenType.star);
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    parseExportNamespace();
  } else {
    parseExportFrom();
  }
}
exports.baseParseExportStar = baseParseExportStar;
function parseExportNamespace() {
  _tokenizer.next.call(void 0);
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._as;
  _expression.parseIdentifier.call(void 0);
  parseExportSpecifiersMaybe();
  parseExportFrom();
}
function shouldParseExportDeclaration() {
  return _base.isTypeScriptEnabled && _typescript.tsIsDeclarationStart.call(void 0) || _base.isFlowEnabled && _flow.flowShouldParseExportDeclaration.call(void 0) || _base.state.type === _types.TokenType._var || _base.state.type === _types.TokenType._const || _base.state.type === _types.TokenType._let || _base.state.type === _types.TokenType._function || _base.state.type === _types.TokenType._class || _util.isContextual.call(void 0, _keywords.ContextualKeyword._async) || _tokenizer.match.call(void 0, _types.TokenType.at);
}

// Parses a comma-separated list of module exports.
function parseExportSpecifiers() {
  let first = true;

  // export { x, y as z } [from '...']
  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types.TokenType.comma);
      if (_tokenizer.eat.call(void 0, _types.TokenType.braceR)) {
        break;
      }
    }
    parseExportSpecifier();
  }
}
exports.parseExportSpecifiers = parseExportSpecifiers;
function parseExportSpecifier() {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseExportSpecifier.call(void 0);
    return;
  }
  _expression.parseIdentifier.call(void 0);
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ExportAccess;
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    _expression.parseIdentifier.call(void 0);
  }
}

// Parses import declaration.

function parseImport() {
  if (_base.isTypeScriptEnabled && _tokenizer.match.call(void 0, _types.TokenType.name) && _tokenizer.lookaheadType.call(void 0) === _types.TokenType.eq) {
    _typescript.tsParseImportEqualsDeclaration.call(void 0);
    return;
  }
  if (_base.isTypeScriptEnabled && _util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    const lookahead = _tokenizer.lookaheadTypeAndKeyword.call(void 0);
    if (lookahead.type === _types.TokenType.name && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from) {
      // One of these `import type` cases:
      // import type T = require('T');
      // import type A from 'A';
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
      if (_tokenizer.lookaheadType.call(void 0) === _types.TokenType.eq) {
        _typescript.tsParseImportEqualsDeclaration.call(void 0);
        return;
      }
      // If this is an `import type...from` statement, then we already ate the
      // type token, so proceed to the regular import parser.
    } else if (lookahead.type === _types.TokenType.star || lookahead.type === _types.TokenType.braceL) {
      // One of these `import type` cases, in which case we can eat the type token
      // and proceed as normal:
      // import type * as A from 'A';
      // import type {a} from 'A';
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
    }
    // Otherwise, we are importing the name "type".
  }

  // import '...'
  if (_tokenizer.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0);
  } else {
    parseImportSpecifiers();
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._from);
    _expression.parseExprAtom.call(void 0);
  }
  maybeParseImportAssertions();
  _util.semicolon.call(void 0);
}
exports.parseImport = parseImport;

// eslint-disable-next-line no-unused-vars
function shouldParseDefaultImport() {
  return _tokenizer.match.call(void 0, _types.TokenType.name);
}
function parseImportSpecifierLocal() {
  _lval.parseImportedIdentifier.call(void 0);
}

// Parses a comma-separated list of module imports.
function parseImportSpecifiers() {
  if (_base.isFlowEnabled) {
    _flow.flowStartParseImportSpecifiers.call(void 0);
  }
  let first = true;
  if (shouldParseDefaultImport()) {
    // import defaultObj, { x, y as z } from '...'
    parseImportSpecifierLocal();
    if (!_tokenizer.eat.call(void 0, _types.TokenType.comma)) return;
  }
  if (_tokenizer.match.call(void 0, _types.TokenType.star)) {
    _tokenizer.next.call(void 0);
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._as);
    parseImportSpecifierLocal();
    return;
  }
  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      // Detect an attempt to deep destructure
      if (_tokenizer.eat.call(void 0, _types.TokenType.colon)) {
        _util.unexpected.call(void 0, "ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
      }
      _util.expect.call(void 0, _types.TokenType.comma);
      if (_tokenizer.eat.call(void 0, _types.TokenType.braceR)) {
        break;
      }
    }
    parseImportSpecifier();
  }
}
function parseImportSpecifier() {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseImportSpecifier.call(void 0);
    return;
  }
  if (_base.isFlowEnabled) {
    _flow.flowParseImportSpecifier.call(void 0);
    return;
  }
  _lval.parseImportedIdentifier.call(void 0);
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ImportAccess;
    _tokenizer.next.call(void 0);
    _lval.parseImportedIdentifier.call(void 0);
  }
}

/**
 * Parse import assertions like `assert {type: "json"}`.
 *
 * Import assertions technically have their own syntax, but are always parseable
 * as a plain JS object, so just do that for simplicity.
 */
function maybeParseImportAssertions() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._assert) && !_util.hasPrecedingLineBreak.call(void 0)) {
    _tokenizer.next.call(void 0);
    _expression.parseObj.call(void 0, false, false);
  }
}
}),
/* --- node_modules/sucrase/dist/util/elideImportEquals.js --- */
"node_modules/sucrase/dist/util/elideImportEquals.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
function elideImportEquals(tokens) {
  // import
  tokens.removeInitialToken();
  // name
  tokens.removeToken();
  // =
  tokens.removeToken();
  // name or require
  tokens.removeToken();
  // Handle either `import A = require('A')` or `import A = B.C.D`.
  if (tokens.matches1(_types.TokenType.parenL)) {
    // (
    tokens.removeToken();
    // path string
    tokens.removeToken();
    // )
    tokens.removeToken();
  } else {
    while (tokens.matches1(_types.TokenType.dot)) {
      // .
      tokens.removeToken();
      // name
      tokens.removeToken();
    }
  }
}
exports.default = elideImportEquals;
}),
/* --- node_modules/sucrase/dist/util/getDeclarationInfo.js --- */
"node_modules/sucrase/dist/util/getDeclarationInfo.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _tokenizer = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
const EMPTY_DECLARATION_INFO = {
  typeDeclarations: new Set(),
  valueDeclarations: new Set()
};
exports.EMPTY_DECLARATION_INFO = EMPTY_DECLARATION_INFO;

/**
 * Get all top-level identifiers that should be preserved when exported in TypeScript.
 *
 * Examples:
 * - If an identifier is declared as `const x`, then `export {x}` should be preserved.
 * - If it's declared as `type x`, then `export {x}` should be removed.
 * - If it's declared as both `const x` and `type x`, then the export should be preserved.
 * - Classes and enums should be preserved (even though they also introduce types).
 * - Imported identifiers should be preserved since we don't have enough information to
 *   rule them out. --isolatedModules disallows re-exports, which catches errors here.
 */
function getDeclarationInfo(tokens) {
  const typeDeclarations = new Set();
  const valueDeclarations = new Set();
  for (let i = 0; i < tokens.tokens.length; i++) {
    const token = tokens.tokens[i];
    if (token.type === _types.TokenType.name && _tokenizer.isTopLevelDeclaration.call(void 0, token)) {
      if (token.isType) {
        typeDeclarations.add(tokens.identifierNameForToken(token));
      } else {
        valueDeclarations.add(tokens.identifierNameForToken(token));
      }
    }
  }
  return {
    typeDeclarations,
    valueDeclarations
  };
}
exports.default = getDeclarationInfo;
}),
/* --- node_modules/sucrase/dist/util/removeMaybeImportAssertion.js --- */
"node_modules/sucrase/dist/util/removeMaybeImportAssertion.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");

/**
 * Starting at a potential `assert` token remove the import assertion if there
 * is one.
 */
function removeMaybeImportAssertion(tokens) {
  if (tokens.matches2(_types.TokenType.name, _types.TokenType.braceL) && tokens.matchesContextual(_keywords.ContextualKeyword._assert)) {
    // assert
    tokens.removeToken();
    // {
    tokens.removeToken();
    tokens.removeBalancedCode();
    // }
    tokens.removeToken();
  }
}
exports.removeMaybeImportAssertion = removeMaybeImportAssertion;
}),
/* --- node_modules/sucrase/dist/util/shouldElideDefaultExport.js --- */
"node_modules/sucrase/dist/util/shouldElideDefaultExport.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");

/**
 * Common method sharing code between CJS and ESM cases, since they're the same here.
 */
function shouldElideDefaultExport(isTypeScriptTransformEnabled, tokens, declarationInfo) {
  if (!isTypeScriptTransformEnabled) {
    return false;
  }
  const exportToken = tokens.currentToken();
  if (exportToken.rhsEndIndex == null) {
    throw new Error("Expected non-null rhsEndIndex on export token.");
  }
  // The export must be of the form `export default a` or `export default a;`.
  const numTokens = exportToken.rhsEndIndex - tokens.currentIndex();
  if (numTokens !== 3 && !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, _types.TokenType.semi))) {
    return false;
  }
  const identifierToken = tokens.tokenAtRelativeIndex(2);
  if (identifierToken.type !== _types.TokenType.name) {
    return false;
  }
  const exportedName = tokens.identifierNameForToken(identifierToken);
  return declarationInfo.typeDeclarations.has(exportedName) && !declarationInfo.valueDeclarations.has(exportedName);
}
exports.default = shouldElideDefaultExport;
}),
/* --- node_modules/sucrase/dist/transformers/Transformer.js --- */
"node_modules/sucrase/dist/transformers/Transformer.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
class Transformer {
  // Return true if anything was processed, false otherwise.

  getPrefixCode() {
    return "";
  }
  getHoistedCode() {
    return "";
  }
  getSuffixCode() {
    return "";
  }
}
exports.default = Transformer;
}),
/* --- node_modules/sucrase/dist/parser/plugins/jsx/xhtml.js --- */
"node_modules/sucrase/dist/parser/plugins/jsx/xhtml.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Use a Map rather than object to avoid unexpected __proto__ access.
exports.default = new Map([["quot", "\u0022"], ["amp", "&"], ["apos", "\u0027"], ["lt", "<"], ["gt", ">"], ["nbsp", "\u00A0"], ["iexcl", "\u00A1"], ["cent", "\u00A2"], ["pound", "\u00A3"], ["curren", "\u00A4"], ["yen", "\u00A5"], ["brvbar", "\u00A6"], ["sect", "\u00A7"], ["uml", "\u00A8"], ["copy", "\u00A9"], ["ordf", "\u00AA"], ["laquo", "\u00AB"], ["not", "\u00AC"], ["shy", "\u00AD"], ["reg", "\u00AE"], ["macr", "\u00AF"], ["deg", "\u00B0"], ["plusmn", "\u00B1"], ["sup2", "\u00B2"], ["sup3", "\u00B3"], ["acute", "\u00B4"], ["micro", "\u00B5"], ["para", "\u00B6"], ["middot", "\u00B7"], ["cedil", "\u00B8"], ["sup1", "\u00B9"], ["ordm", "\u00BA"], ["raquo", "\u00BB"], ["frac14", "\u00BC"], ["frac12", "\u00BD"], ["frac34", "\u00BE"], ["iquest", "\u00BF"], ["Agrave", "\u00C0"], ["Aacute", "\u00C1"], ["Acirc", "\u00C2"], ["Atilde", "\u00C3"], ["Auml", "\u00C4"], ["Aring", "\u00C5"], ["AElig", "\u00C6"], ["Ccedil", "\u00C7"], ["Egrave", "\u00C8"], ["Eacute", "\u00C9"], ["Ecirc", "\u00CA"], ["Euml", "\u00CB"], ["Igrave", "\u00CC"], ["Iacute", "\u00CD"], ["Icirc", "\u00CE"], ["Iuml", "\u00CF"], ["ETH", "\u00D0"], ["Ntilde", "\u00D1"], ["Ograve", "\u00D2"], ["Oacute", "\u00D3"], ["Ocirc", "\u00D4"], ["Otilde", "\u00D5"], ["Ouml", "\u00D6"], ["times", "\u00D7"], ["Oslash", "\u00D8"], ["Ugrave", "\u00D9"], ["Uacute", "\u00DA"], ["Ucirc", "\u00DB"], ["Uuml", "\u00DC"], ["Yacute", "\u00DD"], ["THORN", "\u00DE"], ["szlig", "\u00DF"], ["agrave", "\u00E0"], ["aacute", "\u00E1"], ["acirc", "\u00E2"], ["atilde", "\u00E3"], ["auml", "\u00E4"], ["aring", "\u00E5"], ["aelig", "\u00E6"], ["ccedil", "\u00E7"], ["egrave", "\u00E8"], ["eacute", "\u00E9"], ["ecirc", "\u00EA"], ["euml", "\u00EB"], ["igrave", "\u00EC"], ["iacute", "\u00ED"], ["icirc", "\u00EE"], ["iuml", "\u00EF"], ["eth", "\u00F0"], ["ntilde", "\u00F1"], ["ograve", "\u00F2"], ["oacute", "\u00F3"], ["ocirc", "\u00F4"], ["otilde", "\u00F5"], ["ouml", "\u00F6"], ["divide", "\u00F7"], ["oslash", "\u00F8"], ["ugrave", "\u00F9"], ["uacute", "\u00FA"], ["ucirc", "\u00FB"], ["uuml", "\u00FC"], ["yacute", "\u00FD"], ["thorn", "\u00FE"], ["yuml", "\u00FF"], ["OElig", "\u0152"], ["oelig", "\u0153"], ["Scaron", "\u0160"], ["scaron", "\u0161"], ["Yuml", "\u0178"], ["fnof", "\u0192"], ["circ", "\u02C6"], ["tilde", "\u02DC"], ["Alpha", "\u0391"], ["Beta", "\u0392"], ["Gamma", "\u0393"], ["Delta", "\u0394"], ["Epsilon", "\u0395"], ["Zeta", "\u0396"], ["Eta", "\u0397"], ["Theta", "\u0398"], ["Iota", "\u0399"], ["Kappa", "\u039A"], ["Lambda", "\u039B"], ["Mu", "\u039C"], ["Nu", "\u039D"], ["Xi", "\u039E"], ["Omicron", "\u039F"], ["Pi", "\u03A0"], ["Rho", "\u03A1"], ["Sigma", "\u03A3"], ["Tau", "\u03A4"], ["Upsilon", "\u03A5"], ["Phi", "\u03A6"], ["Chi", "\u03A7"], ["Psi", "\u03A8"], ["Omega", "\u03A9"], ["alpha", "\u03B1"], ["beta", "\u03B2"], ["gamma", "\u03B3"], ["delta", "\u03B4"], ["epsilon", "\u03B5"], ["zeta", "\u03B6"], ["eta", "\u03B7"], ["theta", "\u03B8"], ["iota", "\u03B9"], ["kappa", "\u03BA"], ["lambda", "\u03BB"], ["mu", "\u03BC"], ["nu", "\u03BD"], ["xi", "\u03BE"], ["omicron", "\u03BF"], ["pi", "\u03C0"], ["rho", "\u03C1"], ["sigmaf", "\u03C2"], ["sigma", "\u03C3"], ["tau", "\u03C4"], ["upsilon", "\u03C5"], ["phi", "\u03C6"], ["chi", "\u03C7"], ["psi", "\u03C8"], ["omega", "\u03C9"], ["thetasym", "\u03D1"], ["upsih", "\u03D2"], ["piv", "\u03D6"], ["ensp", "\u2002"], ["emsp", "\u2003"], ["thinsp", "\u2009"], ["zwnj", "\u200C"], ["zwj", "\u200D"], ["lrm", "\u200E"], ["rlm", "\u200F"], ["ndash", "\u2013"], ["mdash", "\u2014"], ["lsquo", "\u2018"], ["rsquo", "\u2019"], ["sbquo", "\u201A"], ["ldquo", "\u201C"], ["rdquo", "\u201D"], ["bdquo", "\u201E"], ["dagger", "\u2020"], ["Dagger", "\u2021"], ["bull", "\u2022"], ["hellip", "\u2026"], ["permil", "\u2030"], ["prime", "\u2032"], ["Prime", "\u2033"], ["lsaquo", "\u2039"], ["rsaquo", "\u203A"], ["oline", "\u203E"], ["frasl", "\u2044"], ["euro", "\u20AC"], ["image", "\u2111"], ["weierp", "\u2118"], ["real", "\u211C"], ["trade", "\u2122"], ["alefsym", "\u2135"], ["larr", "\u2190"], ["uarr", "\u2191"], ["rarr", "\u2192"], ["darr", "\u2193"], ["harr", "\u2194"], ["crarr", "\u21B5"], ["lArr", "\u21D0"], ["uArr", "\u21D1"], ["rArr", "\u21D2"], ["dArr", "\u21D3"], ["hArr", "\u21D4"], ["forall", "\u2200"], ["part", "\u2202"], ["exist", "\u2203"], ["empty", "\u2205"], ["nabla", "\u2207"], ["isin", "\u2208"], ["notin", "\u2209"], ["ni", "\u220B"], ["prod", "\u220F"], ["sum", "\u2211"], ["minus", "\u2212"], ["lowast", "\u2217"], ["radic", "\u221A"], ["prop", "\u221D"], ["infin", "\u221E"], ["ang", "\u2220"], ["and", "\u2227"], ["or", "\u2228"], ["cap", "\u2229"], ["cup", "\u222A"], ["int", "\u222B"], ["there4", "\u2234"], ["sim", "\u223C"], ["cong", "\u2245"], ["asymp", "\u2248"], ["ne", "\u2260"], ["equiv", "\u2261"], ["le", "\u2264"], ["ge", "\u2265"], ["sub", "\u2282"], ["sup", "\u2283"], ["nsub", "\u2284"], ["sube", "\u2286"], ["supe", "\u2287"], ["oplus", "\u2295"], ["otimes", "\u2297"], ["perp", "\u22A5"], ["sdot", "\u22C5"], ["lceil", "\u2308"], ["rceil", "\u2309"], ["lfloor", "\u230A"], ["rfloor", "\u230B"], ["lang", "\u2329"], ["rang", "\u232A"], ["loz", "\u25CA"], ["spades", "\u2660"], ["clubs", "\u2663"], ["hearts", "\u2665"], ["diams", "\u2666"]]);
}),
/* --- node_modules/sucrase/dist/util/isIdentifier.js --- */
"node_modules/sucrase/dist/util/isIdentifier.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _identifier = _kame_require_("node_modules/sucrase/dist/parser/util/identifier.js");

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar
// Hard-code a list of reserved words rather than trying to use keywords or contextual keywords
// from the parser, since currently there are various exceptions, like `package` being reserved
// but unused and various contextual keywords being reserved. Note that we assume that all code
// compiled by Sucrase is in a module, so strict mode words and await are all considered reserved
// here.
const RESERVED_WORDS = new Set([
// Reserved keywords as of ECMAScript 2015
"break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "in", "instanceof", "new", "return", "super", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "yield",
// Future reserved keywords
"enum", "implements", "interface", "let", "package", "private", "protected", "public", "static", "await",
// Literals that cannot be used as identifiers
"false", "null", "true"]);

/**
 * Determine if the given name is a legal variable name.
 *
 * This is needed when transforming TypeScript enums; if an enum key is a valid
 * variable name, it might be referenced later in the enum, so we need to
 * declare a variable.
 */
function isIdentifier(name) {
  if (name.length === 0) {
    return false;
  }
  if (!_identifier.IS_IDENTIFIER_START[name.charCodeAt(0)]) {
    return false;
  }
  for (let i = 1; i < name.length; i++) {
    if (!_identifier.IS_IDENTIFIER_CHAR[name.charCodeAt(i)]) {
      return false;
    }
  }
  return !RESERVED_WORDS.has(name);
}
exports.default = isIdentifier;
}),
/* --- node_modules/coffeescript/lib/coffeescript/rewriter.js --- */
"node_modules/coffeescript/lib/coffeescript/rewriter.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  // The CoffeeScript language has a good deal of optional syntax, implicit syntax,
  // and shorthand syntax. This can greatly complicate a grammar and bloat
  // the resulting parse table. Instead of making the parser handle it all, we take
  // a series of passes over the token stream, using this **Rewriter** to convert
  // shorthand into the unambiguous long form, add implicit indentation and
  // parentheses, and generally clean things up.
  var BALANCED_PAIRS,
    CALL_CLOSERS,
    CONTROL_IN_IMPLICIT,
    DISCARDED,
    EXPRESSION_CLOSE,
    EXPRESSION_END,
    EXPRESSION_START,
    IMPLICIT_CALL,
    IMPLICIT_END,
    IMPLICIT_FUNC,
    IMPLICIT_UNSPACED_CALL,
    INVERSES,
    LINEBREAKS,
    Rewriter,
    SINGLE_CLOSERS,
    SINGLE_LINERS,
    UNFINISHED,
    extractAllCommentTokens,
    generate,
    k,
    left,
    len,
    moveComments,
    right,
    throwSyntaxError,
    indexOf = [].indexOf,
    hasProp = {}.hasOwnProperty;
  ({
    throwSyntaxError,
    extractAllCommentTokens
  } = _kame_require_("node_modules/coffeescript/lib/coffeescript/helpers.js"));

  // Move attached comments from one token to another.
  moveComments = function (fromToken, toToken) {
    var comment, k, len, ref, unshiftedComments;
    if (!fromToken.comments) {
      return;
    }
    if (toToken.comments && toToken.comments.length !== 0) {
      unshiftedComments = [];
      ref = fromToken.comments;
      for (k = 0, len = ref.length; k < len; k++) {
        comment = ref[k];
        if (comment.unshift) {
          unshiftedComments.push(comment);
        } else {
          toToken.comments.push(comment);
        }
      }
      toToken.comments = unshiftedComments.concat(toToken.comments);
    } else {
      toToken.comments = fromToken.comments;
    }
    return delete fromToken.comments;
  };

  // Create a generated token: one that exists due to a use of implicit syntax.
  // Optionally have this new token take the attached comments from another token.
  generate = function (tag, value, origin, commentsToken) {
    var token;
    token = [tag, value];
    token.generated = true;
    if (origin) {
      token.origin = origin;
    }
    if (commentsToken) {
      moveComments(commentsToken, token);
    }
    return token;
  };

  // The **Rewriter** class is used by the [Lexer](lexer.html), directly against
  // its internal array of tokens.
  exports.Rewriter = Rewriter = function () {
    class Rewriter {
      // Rewrite the token stream in multiple passes, one logical filter at
      // a time. This could certainly be changed into a single pass through the
      // stream, with a big ol efficient switch, but its much nicer to work with
      // like this. The order of these passes mattersindentation must be
      // corrected before implicit parentheses can be wrapped around blocks of code.
      rewrite(tokens1) {
        var ref, ref1, t;
        this.tokens = tokens1;
        // Set environment variable `DEBUG_TOKEN_STREAM` to `true` to output token
        // debugging info. Also set `DEBUG_REWRITTEN_TOKEN_STREAM` to `true` to
        // output the token stream after it has been rewritten by this file.
        if (typeof process !== "undefined" && process !== null ? (ref = process.env) != null ? ref.DEBUG_TOKEN_STREAM : void 0 : void 0) {
          if (process.env.DEBUG_REWRITTEN_TOKEN_STREAM) {
            console.log('Initial token stream:');
          }
          console.log(function () {
            var k, len, ref1, results;
            ref1 = this.tokens;
            results = [];
            for (k = 0, len = ref1.length; k < len; k++) {
              t = ref1[k];
              results.push(t[0] + '/' + t[1] + (t.comments ? '*' : ''));
            }
            return results;
          }.call(this).join(' '));
        }
        this.removeLeadingNewlines();
        this.closeOpenCalls();
        this.closeOpenIndexes();
        this.normalizeLines();
        this.tagPostfixConditionals();
        this.addImplicitBracesAndParens();
        this.rescueStowawayComments();
        this.addLocationDataToGeneratedTokens();
        this.enforceValidJSXAttributes();
        this.fixIndentationLocationData();
        this.exposeTokenDataToGrammar();
        if (typeof process !== "undefined" && process !== null ? (ref1 = process.env) != null ? ref1.DEBUG_REWRITTEN_TOKEN_STREAM : void 0 : void 0) {
          if (process.env.DEBUG_TOKEN_STREAM) {
            console.log('Rewritten token stream:');
          }
          console.log(function () {
            var k, len, ref2, results;
            ref2 = this.tokens;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              t = ref2[k];
              results.push(t[0] + '/' + t[1] + (t.comments ? '*' : ''));
            }
            return results;
          }.call(this).join(' '));
        }
        return this.tokens;
      }

      // Rewrite the token stream, looking one token ahead and behind.
      // Allow the return value of the block to tell us how many tokens to move
      // forwards (or backwards) in the stream, to make sure we dont miss anything
      // as tokens are inserted and removed, and the stream changes length under
      // our feet.
      scanTokens(block) {
        var i, token, tokens;
        ({
          tokens
        } = this);
        i = 0;
        while (token = tokens[i]) {
          i += block.call(this, token, i, tokens);
        }
        return true;
      }
      detectEnd(i, condition, action, opts = {}) {
        var levels, ref, ref1, token, tokens;
        ({
          tokens
        } = this);
        levels = 0;
        while (token = tokens[i]) {
          if (levels === 0 && condition.call(this, token, i)) {
            return action.call(this, token, i);
          }
          if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {
            levels += 1;
          } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {
            levels -= 1;
          }
          if (levels < 0) {
            if (opts.returnOnNegativeLevel) {
              return;
            }
            return action.call(this, token, i);
          }
          i += 1;
        }
        return i - 1;
      }

      // Leading newlines would introduce an ambiguity in the grammar, so we
      // dispatch them here.
      removeLeadingNewlines() {
        var i, k, l, leadingNewlineToken, len, len1, ref, ref1, tag;
        ref = this.tokens;
        for (i = k = 0, len = ref.length; k < len; i = ++k) {
          [tag] = ref[i];
          if (tag !== 'TERMINATOR') {
            // Find the index of the first non-`TERMINATOR` token.
            break;
          }
        }
        if (i === 0) {
          return;
        }
        ref1 = this.tokens.slice(0, i);
        // If there are any comments attached to the tokens were about to discard,
        // shift them forward to what will become the new first token.
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          leadingNewlineToken = ref1[l];
          moveComments(leadingNewlineToken, this.tokens[i]);
        }
        // Discard all the leading newline tokens.
        return this.tokens.splice(0, i);
      }

      // The lexer has tagged the opening parenthesis of a method call. Match it with
      // its paired close.
      closeOpenCalls() {
        var action, condition;
        condition = function (token, i) {
          var ref;
          return (ref = token[0]) === ')' || ref === 'CALL_END';
        };
        action = function (token, i) {
          return token[0] = 'CALL_END';
        };
        return this.scanTokens(function (token, i) {
          if (token[0] === 'CALL_START') {
            this.detectEnd(i + 1, condition, action);
          }
          return 1;
        });
      }

      // The lexer has tagged the opening bracket of an indexing operation call.
      // Match it with its paired close.
      closeOpenIndexes() {
        var action, condition, startToken;
        startToken = null;
        condition = function (token, i) {
          var ref;
          return (ref = token[0]) === ']' || ref === 'INDEX_END';
        };
        action = function (token, i) {
          if (this.tokens.length >= i && this.tokens[i + 1][0] === ':') {
            startToken[0] = '[';
            return token[0] = ']';
          } else {
            return token[0] = 'INDEX_END';
          }
        };
        return this.scanTokens(function (token, i) {
          if (token[0] === 'INDEX_START') {
            startToken = token;
            this.detectEnd(i + 1, condition, action);
          }
          return 1;
        });
      }

      // Match tags in token stream starting at `i` with `pattern`.
      // `pattern` may consist of strings (equality), an array of strings (one of)
      // or null (wildcard). Returns the index of the match or -1 if no match.
      indexOfTag(i, ...pattern) {
        var fuzz, j, k, ref, ref1;
        fuzz = 0;
        for (j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
          if (pattern[j] == null) {
            continue;
          }
          if (typeof pattern[j] === 'string') {
            pattern[j] = [pattern[j]];
          }
          if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {
            return -1;
          }
        }
        return i + j + fuzz - 1;
      }

      // Returns `yes` if standing in front of something looking like
      // `@<x>:`, `<x>:` or `<EXPRESSION_START><x>...<EXPRESSION_END>:`.
      looksObjectish(j) {
        var end, index;
        if (this.indexOfTag(j, '@', null, ':') !== -1 || this.indexOfTag(j, null, ':') !== -1) {
          return true;
        }
        index = this.indexOfTag(j, EXPRESSION_START);
        if (index !== -1) {
          end = null;
          this.detectEnd(index + 1, function (token) {
            var ref;
            return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;
          }, function (token, i) {
            return end = i;
          });
          if (this.tag(end + 1) === ':') {
            return true;
          }
        }
        return false;
      }

      // Returns `yes` if current line of tokens contain an element of tags on same
      // expression level. Stop searching at `LINEBREAKS` or explicit start of
      // containing balanced expression.
      findTagsBackwards(i, tags) {
        var backStack, ref, ref1, ref2, ref3, ref4, ref5;
        backStack = [];
        while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {
          if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {
            backStack.push(this.tag(i));
          }
          if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {
            backStack.pop();
          }
          i -= 1;
        }
        return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;
      }

      // Look for signs of implicit calls and objects in the token stream and
      // add them.
      addImplicitBracesAndParens() {
        var stack, start;
        // Track current balancing depth (both implicit and explicit) on stack.
        stack = [];
        start = null;
        return this.scanTokens(function (token, i, tokens) {
          var endImplicitCall, endImplicitObject, forward, implicitObjectContinues, implicitObjectIndent, inControlFlow, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, isImplicit, isImplicitCall, isImplicitObject, k, newLine, nextTag, nextToken, offset, preContinuationLineIndent, preObjectToken, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackItem, stackNext, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startIndex, startTag, startsLine, tag;
          [tag] = token;
          [prevTag] = prevToken = i > 0 ? tokens[i - 1] : [];
          [nextTag] = nextToken = i < tokens.length - 1 ? tokens[i + 1] : [];
          stackTop = function () {
            return stack[stack.length - 1];
          };
          startIdx = i;
          // Helper function, used for keeping track of the number of tokens consumed
          // and spliced, when returning for getting a new token.
          forward = function (n) {
            return i - startIdx + n;
          };
          // Helper functions
          isImplicit = function (stackItem) {
            var ref;
            return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;
          };
          isImplicitObject = function (stackItem) {
            return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '{';
          };
          isImplicitCall = function (stackItem) {
            return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '(';
          };
          inImplicit = function () {
            return isImplicit(stackTop());
          };
          inImplicitCall = function () {
            return isImplicitCall(stackTop());
          };
          inImplicitObject = function () {
            return isImplicitObject(stackTop());
          };
          // Unclosed control statement inside implicit parens (like
          // class declaration or if-conditionals).
          inImplicitControl = function () {
            var ref;
            return inImplicit() && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';
          };
          startImplicitCall = function (idx) {
            stack.push(['(', idx, {
              ours: true
            }]);
            return tokens.splice(idx, 0, generate('CALL_START', '(', ['', 'implicit function call', token[2]], prevToken));
          };
          endImplicitCall = function () {
            stack.pop();
            tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]], prevToken));
            return i += 1;
          };
          startImplicitObject = function (idx, {
            startsLine = true,
            continuationLineIndent
          } = {}) {
            var val;
            stack.push(['{', idx, {
              sameLine: true,
              startsLine: startsLine,
              ours: true,
              continuationLineIndent: continuationLineIndent
            }]);
            val = new String('{');
            val.generated = true;
            return tokens.splice(idx, 0, generate('{', val, token, prevToken));
          };
          endImplicitObject = function (j) {
            j = j != null ? j : i;
            stack.pop();
            tokens.splice(j, 0, generate('}', '}', token, prevToken));
            return i += 1;
          };
          implicitObjectContinues = j => {
            var nextTerminatorIdx;
            nextTerminatorIdx = null;
            this.detectEnd(j, function (token) {
              return token[0] === 'TERMINATOR';
            }, function (token, i) {
              return nextTerminatorIdx = i;
            }, {
              returnOnNegativeLevel: true
            });
            if (nextTerminatorIdx == null) {
              return false;
            }
            return this.looksObjectish(nextTerminatorIdx + 1);
          };
          // Dont end an implicit call/object on next indent if any of these are in an argument/value.
          if ((inImplicitCall() || inImplicitObject()) && indexOf.call(CONTROL_IN_IMPLICIT, tag) >= 0 || inImplicitObject() && prevTag === ':' && tag === 'FOR') {
            stack.push(['CONTROL', i, {
              ours: true
            }]);
            return forward(1);
          }
          if (tag === 'INDENT' && inImplicit()) {
            // An `INDENT` closes an implicit call unless

            //  1. We have seen a `CONTROL` argument on the line.
            //  2. The last token before the indent is part of the list below.
            if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'ELSE' && prevTag !== '=') {
              while (inImplicitCall() || inImplicitObject() && prevTag !== ':') {
                if (inImplicitCall()) {
                  endImplicitCall();
                } else {
                  endImplicitObject();
                }
              }
            }
            if (inImplicitControl()) {
              stack.pop();
            }
            stack.push([tag, i]);
            return forward(1);
          }
          // Straightforward start of explicit expression.
          if (indexOf.call(EXPRESSION_START, tag) >= 0) {
            stack.push([tag, i]);
            return forward(1);
          }
          // Close all implicit expressions inside of explicitly closed expressions.
          if (indexOf.call(EXPRESSION_END, tag) >= 0) {
            while (inImplicit()) {
              if (inImplicitCall()) {
                endImplicitCall();
              } else if (inImplicitObject()) {
                endImplicitObject();
              } else {
                stack.pop();
              }
            }
            start = stack.pop();
          }
          inControlFlow = () => {
            var controlFlow, isFunc, seenFor, tagCurrentLine;
            seenFor = this.findTagsBackwards(i, ['FOR']) && this.findTagsBackwards(i, ['FORIN', 'FOROF', 'FORFROM']);
            controlFlow = seenFor || this.findTagsBackwards(i, ['WHILE', 'UNTIL', 'LOOP', 'LEADING_WHEN']);
            if (!controlFlow) {
              return false;
            }
            isFunc = false;
            tagCurrentLine = token[2].first_line;
            this.detectEnd(i, function (token, i) {
              var ref;
              return ref = token[0], indexOf.call(LINEBREAKS, ref) >= 0;
            }, function (token, i) {
              var first_line;
              [prevTag,, {
                first_line
              }] = tokens[i - 1] || [];
              return isFunc = tagCurrentLine === first_line && (prevTag === '->' || prevTag === '=>');
            }, {
              returnOnNegativeLevel: true
            });
            return isFunc;
          };
          // Recognize standard implicit calls like
          // f a, f() b, f? c, h[0] d etc.
          // Added support for spread dots on the left side: f ...a
          if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || nextTag === '...' && (ref = this.tag(i + 2), indexOf.call(IMPLICIT_CALL, ref) >= 0) && !this.findTagsBackwards(i, ['INDEX_START', '[']) || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !nextToken.spaced && !nextToken.newLine) && !inControlFlow()) {
            if (tag === '?') {
              tag = token[0] = 'FUNC_EXIST';
            }
            startImplicitCall(i + 1);
            return forward(2);
          }
          // Implicit call taking an implicit indented object as first argument.

          //     f
          //       a: b
          //       c: d

          // Dont accept implicit calls of this type, when on the same line
          // as the control structures below as that may misinterpret constructs like:

          //     if f
          //        a: 1
          // as

          //     if f(a: 1)

          // which is probably always unintended.
          // Furthermore dont allow this in the first line of a literal array
          // or explicit object, as that creates grammatical ambiguities (#5368).
          if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL']) && !(((ref1 = s = (ref2 = stackTop()) != null ? ref2[0] : void 0) === '{' || ref1 === '[') && !isImplicit(stackTop()) && this.findTagsBackwards(i, s))) {
            startImplicitCall(i + 1);
            stack.push(['INDENT', i + 2]);
            return forward(3);
          }
          // Implicit objects start here.
          if (tag === ':') {
            // Go back to the (implicit) start of the object.
            s = function () {
              var ref3;
              switch (false) {
                case (ref3 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref3) < 0):
                  [startTag, startIndex] = start;
                  if (startTag === '[' && startIndex > 0 && this.tag(startIndex - 1) === '@' && !tokens[startIndex - 1].spaced) {
                    return startIndex - 1;
                  } else {
                    return startIndex;
                  }
                  break;
                case this.tag(i - 2) !== '@':
                  return i - 2;
                default:
                  return i - 1;
              }
            }.call(this);
            startsLine = s <= 0 || (ref3 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref3) >= 0) || tokens[s - 1].newLine;
            // Are we just continuing an already declared object?
            // Including the case where we indent on the line after an explicit '{'.
            if (stackTop()) {
              [stackTag, stackIdx] = stackTop();
              stackNext = stack[stack.length - 2];
              if ((stackTag === '{' || stackTag === 'INDENT' && (stackNext != null ? stackNext[0] : void 0) === '{' && !isImplicit(stackNext) && this.findTagsBackwards(stackIdx - 1, ['{'])) && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{') && (ref4 = this.tag(s - 1), indexOf.call(UNFINISHED, ref4) < 0)) {
                return forward(1);
              }
            }
            preObjectToken = i > 1 ? tokens[i - 2] : [];
            startImplicitObject(s, {
              startsLine: !!startsLine,
              continuationLineIndent: preObjectToken.continuationLineIndent
            });
            return forward(2);
          }
          // End implicit calls when chaining method calls
          // like e.g.:

          //     f ->
          //       a
          //     .g b, ->
          //       c
          //     .h a

          // and also

          //     f a
          //     .g b
          //     .h a

          // Mark all enclosing objects as not sameLine
          if (indexOf.call(LINEBREAKS, tag) >= 0) {
            for (k = stack.length - 1; k >= 0; k += -1) {
              stackItem = stack[k];
              if (!isImplicit(stackItem)) {
                break;
              }
              if (isImplicitObject(stackItem)) {
                stackItem[2].sameLine = false;
              }
            }
          }
          // End indented-continuation-line implicit objects once that indentation is over.
          if (tag === 'TERMINATOR' && token.endsContinuationLineIndentation) {
            ({
              preContinuationLineIndent
            } = token.endsContinuationLineIndentation);
            while (inImplicitObject() && (implicitObjectIndent = stackTop()[2].continuationLineIndent) != null && implicitObjectIndent > preContinuationLineIndent) {
              endImplicitObject();
            }
          }
          newLine = prevTag === 'OUTDENT' || prevToken.newLine;
          if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine || (tag === '..' || tag === '...') && this.findTagsBackwards(i, ["INDEX_START"])) {
            while (inImplicit()) {
              [stackTag, stackIdx, {
                sameLine,
                startsLine
              }] = stackTop();
              // Close implicit calls when reached end of argument list
              if (inImplicitCall() && prevTag !== ',' || prevTag === ',' && tag === 'TERMINATOR' && nextTag == null) {
                endImplicitCall();
                // Close implicit objects such as:
                // return a: 1, b: 2 unless true
              } else if (inImplicitObject() && sameLine && tag !== 'TERMINATOR' && prevTag !== ':' && !((tag === 'POST_IF' || tag === 'FOR' || tag === 'WHILE' || tag === 'UNTIL') && startsLine && implicitObjectContinues(i + 1))) {
                endImplicitObject();
                // Close implicit objects when at end of line, line didn't end with a comma
                // and the implicit object didn't start the line or the next line doesnt look like
                // the continuation of an object.
              } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {
                endImplicitObject();
              } else if (inImplicitControl() && tokens[stackTop()[1]][0] === 'CLASS' && tag === 'TERMINATOR') {
                stack.pop();
              } else {
                break;
              }
            }
          }
          // Close implicit object if comma is the last character
          // and what comes after doesnt look like it belongs.
          // This is used for trailing commas and calls, like:

          //     x =
          //         a: b,
          //         c: d,
          //     e = 2

          // and

          //     f a, b: c, d: e, f, g: h: i, j

          if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !((ref5 = this.tag(i + 2)) === 'FOROF' || ref5 === 'FORIN') && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {
            // When nextTag is OUTDENT the comma is insignificant and
            // should just be ignored so embed it in the implicit object.

            // When it isnt the comma go on to play a role in a call or
            // array further up the stack, so give it a chance.
            offset = nextTag === 'OUTDENT' ? 1 : 0;
            while (inImplicitObject()) {
              endImplicitObject(i + offset);
            }
          }
          return forward(1);
        });
      }

      // Make sure only strings and wrapped expressions are used in JSX attributes.
      enforceValidJSXAttributes() {
        return this.scanTokens(function (token, i, tokens) {
          var next, ref;
          if (token.jsxColon) {
            next = tokens[i + 1];
            if ((ref = next[0]) !== 'STRING_START' && ref !== 'STRING' && ref !== '(') {
              throwSyntaxError('expected wrapped or quoted JSX attribute', next[2]);
            }
          }
          return 1;
        });
      }

      // Not all tokens survive processing by the parser. To avoid comments getting
      // lost into the ether, find comments attached to doomed tokens and move them
      // to a token that will make it to the other side.
      rescueStowawayComments() {
        var dontShiftForward, insertPlaceholder, shiftCommentsBackward, shiftCommentsForward;
        insertPlaceholder = function (token, j, tokens, method) {
          if (tokens[j][0] !== 'TERMINATOR') {
            tokens[method](generate('TERMINATOR', '\n', tokens[j]));
          }
          return tokens[method](generate('JS', '', tokens[j], token));
        };
        dontShiftForward = function (i, tokens) {
          var j, ref;
          j = i + 1;
          while (j !== tokens.length && (ref = tokens[j][0], indexOf.call(DISCARDED, ref) >= 0)) {
            if (tokens[j][0] === 'INTERPOLATION_END') {
              return true;
            }
            j++;
          }
          return false;
        };
        shiftCommentsForward = function (token, i, tokens) {
          var comment, j, k, len, ref, ref1, ref2;
          // Find the next surviving token and attach this tokens comments to it,
          // with a flag that we know to output such comments *before* that
          // tokens own compilation. (Otherwise comments are output following
          // the token theyre attached to.)
          j = i;
          while (j !== tokens.length && (ref = tokens[j][0], indexOf.call(DISCARDED, ref) >= 0)) {
            j++;
          }
          if (!(j === tokens.length || (ref1 = tokens[j][0], indexOf.call(DISCARDED, ref1) >= 0))) {
            ref2 = token.comments;
            for (k = 0, len = ref2.length; k < len; k++) {
              comment = ref2[k];
              comment.unshift = true;
            }
            moveComments(token, tokens[j]);
            return 1; // All following tokens are doomed!
          } else {
            j = tokens.length - 1;
            insertPlaceholder(token, j, tokens, 'push');
            // The generated tokens were added to the end, not inline, so we dont skip.
            return 1;
          }
        };
        shiftCommentsBackward = function (token, i, tokens) {
          var j, ref, ref1;
          // Find the last surviving token and attach this tokens comments to it.
          j = i;
          while (j !== -1 && (ref = tokens[j][0], indexOf.call(DISCARDED, ref) >= 0)) {
            j--;
          }
          if (!(j === -1 || (ref1 = tokens[j][0], indexOf.call(DISCARDED, ref1) >= 0))) {
            moveComments(token, tokens[j]);
            return 1; // All previous tokens are doomed!
          } else {
            insertPlaceholder(token, 0, tokens, 'unshift');
            // We added two tokens, so shift forward to account for the insertion.
            return 3;
          }
        };
        return this.scanTokens(function (token, i, tokens) {
          var dummyToken, j, ref, ref1, ret;
          if (!token.comments) {
            return 1;
          }
          ret = 1;
          if (ref = token[0], indexOf.call(DISCARDED, ref) >= 0) {
            // This token wont survive passage through the parser, so we need to
            // rescue its attached tokens and redistribute them to nearby tokens.
            // Comments that dont start a new line can shift backwards to the last
            // safe token, while other tokens should shift forward.
            dummyToken = {
              comments: []
            };
            j = token.comments.length - 1;
            while (j !== -1) {
              if (token.comments[j].newLine === false && token.comments[j].here === false) {
                dummyToken.comments.unshift(token.comments[j]);
                token.comments.splice(j, 1);
              }
              j--;
            }
            if (dummyToken.comments.length !== 0) {
              ret = shiftCommentsBackward(dummyToken, i - 1, tokens);
            }
            if (token.comments.length !== 0) {
              shiftCommentsForward(token, i, tokens);
            }
          } else if (!dontShiftForward(i, tokens)) {
            // If any of this tokens comments start a linetheres only
            // whitespace between the preceding newline and the start of the
            // commentand this isnt one of the special `JS` tokens, then
            // shift this comment forward to precede the next valid token.
            // `Block.compileComments` also has logic to make sure that
            // starting new line comments follow or precede the nearest
            // newline relative to the token that the comment is attached to,
            // but that newline might be inside a `}` or `)` or other generated
            // token that we really want this comment to output after. Therefore
            // we need to shift the comments here, avoiding such generated and
            // discarded tokens.
            dummyToken = {
              comments: []
            };
            j = token.comments.length - 1;
            while (j !== -1) {
              if (token.comments[j].newLine && !token.comments[j].unshift && !(token[0] === 'JS' && token.generated)) {
                dummyToken.comments.unshift(token.comments[j]);
                token.comments.splice(j, 1);
              }
              j--;
            }
            if (dummyToken.comments.length !== 0) {
              ret = shiftCommentsForward(dummyToken, i + 1, tokens);
            }
          }
          if (((ref1 = token.comments) != null ? ref1.length : void 0) === 0) {
            delete token.comments;
          }
          return ret;
        });
      }

      // Add location data to all tokens generated by the rewriter.
      addLocationDataToGeneratedTokens() {
        return this.scanTokens(function (token, i, tokens) {
          var column, line, nextLocation, prevLocation, rangeIndex, ref, ref1;
          if (token[2]) {
            return 1;
          }
          if (!(token.generated || token.explicit)) {
            return 1;
          }
          if (token.fromThen && token[0] === 'INDENT') {
            token[2] = token.origin[2];
            return 1;
          }
          if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {
            ({
              first_line: line,
              first_column: column,
              range: [rangeIndex]
            } = nextLocation);
          } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {
            ({
              last_line: line,
              last_column: column,
              range: [, rangeIndex]
            } = prevLocation);
            column += 1;
          } else {
            line = column = 0;
            rangeIndex = 0;
          }
          token[2] = {
            first_line: line,
            first_column: column,
            last_line: line,
            last_column: column,
            last_line_exclusive: line,
            last_column_exclusive: column,
            range: [rangeIndex, rangeIndex]
          };
          return 1;
        });
      }

      // `OUTDENT` tokens should always be positioned at the last character of the
      // previous token, so that AST nodes ending in an `OUTDENT` token end up with a
      // location corresponding to the last real token under the node.
      fixIndentationLocationData() {
        var findPrecedingComment;
        if (this.allComments == null) {
          this.allComments = extractAllCommentTokens(this.tokens);
        }
        findPrecedingComment = (token, {
          afterPosition,
          indentSize,
          first,
          indented
        }) => {
          var comment, k, l, lastMatching, matches, ref, ref1, tokenStart;
          tokenStart = token[2].range[0];
          matches = function (comment) {
            if (comment.outdented) {
              if (!(indentSize != null && comment.indentSize > indentSize)) {
                return false;
              }
            }
            if (indented && !comment.indented) {
              return false;
            }
            if (!(comment.locationData.range[0] < tokenStart)) {
              return false;
            }
            if (!(comment.locationData.range[0] > afterPosition)) {
              return false;
            }
            return true;
          };
          if (first) {
            lastMatching = null;
            ref = this.allComments;
            for (k = ref.length - 1; k >= 0; k += -1) {
              comment = ref[k];
              if (matches(comment)) {
                lastMatching = comment;
              } else if (lastMatching) {
                return lastMatching;
              }
            }
            return lastMatching;
          }
          ref1 = this.allComments;
          for (l = ref1.length - 1; l >= 0; l += -1) {
            comment = ref1[l];
            if (matches(comment)) {
              return comment;
            }
          }
          return null;
        };
        return this.scanTokens(function (token, i, tokens) {
          var isIndent, nextToken, nextTokenIndex, precedingComment, prevLocationData, prevToken, ref, ref1, ref2, useNextToken;
          if (!((ref = token[0]) === 'INDENT' || ref === 'OUTDENT' || token.generated && token[0] === 'CALL_END' && !((ref1 = token.data) != null ? ref1.closingTagNameToken : void 0) || token.generated && token[0] === '}')) {
            return 1;
          }
          isIndent = token[0] === 'INDENT';
          prevToken = (ref2 = token.prevToken) != null ? ref2 : tokens[i - 1];
          prevLocationData = prevToken[2];
          // addLocationDataToGeneratedTokens() set the outdents location data
          // to the preceding tokens, but in order to detect comments inside an
          // empty "block" we want to look for comments preceding the next token.
          useNextToken = token.explicit || token.generated;
          if (useNextToken) {
            nextToken = token;
            nextTokenIndex = i;
            while ((nextToken.explicit || nextToken.generated) && nextTokenIndex !== tokens.length - 1) {
              nextToken = tokens[nextTokenIndex++];
            }
          }
          precedingComment = findPrecedingComment(useNextToken ? nextToken : token, {
            afterPosition: prevLocationData.range[0],
            indentSize: token.indentSize,
            first: isIndent,
            indented: useNextToken
          });
          if (isIndent) {
            if (!(precedingComment != null ? precedingComment.newLine : void 0)) {
              return 1;
            }
          }
          if (token.generated && token[0] === 'CALL_END' && (precedingComment != null ? precedingComment.indented : void 0)) {
            // We dont want e.g. an implicit call at the end of an `if` condition to
            // include a following indented comment.
            return 1;
          }
          if (precedingComment != null) {
            prevLocationData = precedingComment.locationData;
          }
          token[2] = {
            first_line: precedingComment != null ? prevLocationData.first_line : prevLocationData.last_line,
            first_column: precedingComment != null ? isIndent ? 0 : prevLocationData.first_column : prevLocationData.last_column,
            last_line: prevLocationData.last_line,
            last_column: prevLocationData.last_column,
            last_line_exclusive: prevLocationData.last_line_exclusive,
            last_column_exclusive: prevLocationData.last_column_exclusive,
            range: isIndent && precedingComment != null ? [prevLocationData.range[0] - precedingComment.indentSize, prevLocationData.range[1]] : prevLocationData.range
          };
          return 1;
        });
      }

      // Because our grammar is LALR(1), it cant handle some single-line
      // expressions that lack ending delimiters. The **Rewriter** adds the implicit
      // blocks, so it doesnt need to. To keep the grammar clean and tidy, trailing
      // newlines within expressions are removed and the indentation tokens of empty
      // blocks are added.
      normalizeLines() {
        var action, closeElseTag, condition, ifThens, indent, leading_if_then, leading_switch_when, outdent, starter;
        starter = indent = outdent = null;
        leading_switch_when = null;
        leading_if_then = null;
        // Count `THEN` tags
        ifThens = [];
        condition = function (token, i) {
          var ref, ref1, ref2, ref3;
          return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && (starter !== 'THEN' || leading_if_then || leading_switch_when)) && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === 'OUTDENT');
        };
        action = function (token, i) {
          if (token[0] === 'ELSE' && starter === 'THEN') {
            ifThens.pop();
          }
          return this.tokens.splice(this.tag(i - 1) === ',' ? i - 1 : i, 0, outdent);
        };
        closeElseTag = (tokens, i) => {
          var lastThen, outdentElse, tlen;
          tlen = ifThens.length;
          if (!(tlen > 0)) {
            return i;
          }
          lastThen = ifThens.pop();
          [, outdentElse] = this.indentation(tokens[lastThen]);
          // Insert `OUTDENT` to close inner `IF`.
          outdentElse[1] = tlen * 2;
          tokens.splice(i, 0, outdentElse);
          // Insert `OUTDENT` to close outer `IF`.
          outdentElse[1] = 2;
          tokens.splice(i + 1, 0, outdentElse);
          // Remove outdents from the end.
          this.detectEnd(i + 2, function (token, i) {
            var ref;
            return (ref = token[0]) === 'OUTDENT' || ref === 'TERMINATOR';
          }, function (token, i) {
            if (this.tag(i) === 'OUTDENT' && this.tag(i + 1) === 'OUTDENT') {
              return tokens.splice(i, 2);
            }
          });
          return i + 2;
        };
        return this.scanTokens(function (token, i, tokens) {
          var conditionTag, j, k, ref, ref1, ref2, tag;
          [tag] = token;
          conditionTag = (tag === '->' || tag === '=>') && this.findTagsBackwards(i, ['IF', 'WHILE', 'FOR', 'UNTIL', 'SWITCH', 'WHEN', 'LEADING_WHEN', '[', 'INDEX_START']) && !this.findTagsBackwards(i, ['THEN', '..', '...']);
          if (tag === 'TERMINATOR') {
            if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
              tokens.splice(i, 1, ...this.indentation());
              return 1;
            }
            if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {
              if (token[1] === ';' && this.tag(i + 1) === 'OUTDENT') {
                tokens[i + 1].prevToken = token;
                moveComments(token, tokens[i + 1]);
              }
              tokens.splice(i, 1);
              return 0;
            }
          }
          if (tag === 'CATCH') {
            for (j = k = 1; k <= 2; j = ++k) {
              if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {
                continue;
              }
              tokens.splice(i + j, 0, ...this.indentation());
              return 2 + j;
            }
          }
          if ((tag === '->' || tag === '=>') && ((ref2 = this.tag(i + 1)) === ',' || ref2 === ']' || this.tag(i + 1) === '.' && token.newLine)) {
            [indent, outdent] = this.indentation(tokens[i]);
            tokens.splice(i + 1, 0, indent, outdent);
            return 1;
          }
          if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF') && !conditionTag) {
            starter = tag;
            [indent, outdent] = this.indentation(tokens[i]);
            if (starter === 'THEN') {
              indent.fromThen = true;
            }
            if (tag === 'THEN') {
              leading_switch_when = this.findTagsBackwards(i, ['LEADING_WHEN']) && this.tag(i + 1) === 'IF';
              leading_if_then = this.findTagsBackwards(i, ['IF']) && this.tag(i + 1) === 'IF';
            }
            if (tag === 'THEN' && this.findTagsBackwards(i, ['IF'])) {
              ifThens.push(i);
            }
            // `ELSE` tag is not closed.
            if (tag === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
              i = closeElseTag(tokens, i);
            }
            tokens.splice(i + 1, 0, indent);
            this.detectEnd(i + 2, condition, action);
            if (tag === 'THEN') {
              tokens.splice(i, 1);
            }
            return 1;
          }
          return 1;
        });
      }

      // Tag postfix conditionals as such, so that we can parse them with a
      // different precedence.
      tagPostfixConditionals() {
        var action, condition, original;
        original = null;
        condition = function (token, i) {
          var prevTag, tag;
          [tag] = token;
          [prevTag] = this.tokens[i - 1];
          return tag === 'TERMINATOR' || tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0;
        };
        action = function (token, i) {
          if (token[0] !== 'INDENT' || token.generated && !token.fromThen) {
            return original[0] = 'POST_' + original[0];
          }
        };
        return this.scanTokens(function (token, i) {
          if (token[0] !== 'IF') {
            return 1;
          }
          original = token;
          this.detectEnd(i + 1, condition, action);
          return 1;
        });
      }

      // For tokens with extra data, we want to make that data visible to the grammar
      // by wrapping the token value as a String() object and setting the data as
      // properties of that object. The grammar should then be responsible for
      // cleaning this up for the node constructor: unwrapping the token value to a
      // primitive string and separately passing any expected token data properties
      exposeTokenDataToGrammar() {
        return this.scanTokens(function (token, i) {
          var key, ref, ref1, val;
          if (token.generated || token.data && Object.keys(token.data).length !== 0) {
            token[1] = new String(token[1]);
            ref1 = (ref = token.data) != null ? ref : {};
            for (key in ref1) {
              if (!hasProp.call(ref1, key)) continue;
              val = ref1[key];
              token[1][key] = val;
            }
            if (token.generated) {
              token[1].generated = true;
            }
          }
          return 1;
        });
      }

      // Generate the indentation tokens, based on another token on the same line.
      indentation(origin) {
        var indent, outdent;
        indent = ['INDENT', 2];
        outdent = ['OUTDENT', 2];
        if (origin) {
          indent.generated = outdent.generated = true;
          indent.origin = outdent.origin = origin;
        } else {
          indent.explicit = outdent.explicit = true;
        }
        return [indent, outdent];
      }

      // Look up a tag by token index.
      tag(i) {
        var ref;
        return (ref = this.tokens[i]) != null ? ref[0] : void 0;
      }
    }
    ;
    Rewriter.prototype.generate = generate;
    return Rewriter;
  }.call(this);

  // Constants
  // ---------

  // List of the token pairs that must be balanced.
  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['INTERPOLATION_START', 'INTERPOLATION_END'], ['REGEX_START', 'REGEX_END']];

  // The inverse mappings of `BALANCED_PAIRS` were trying to fix up, so we can
  // look things up from either end.
  exports.INVERSES = INVERSES = {};

  // The tokens that signal the start/end of a balanced pair.
  EXPRESSION_START = [];
  EXPRESSION_END = [];
  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {
    [left, right] = BALANCED_PAIRS[k];
    EXPRESSION_START.push(INVERSES[right] = left);
    EXPRESSION_END.push(INVERSES[left] = right);
  }

  // Tokens that indicate the close of a clause of an expression.
  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  // Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
  IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];

  // If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
  IMPLICIT_CALL = ['IDENTIFIER', 'JSX_TAG', 'PROPERTY', 'NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'JS', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'DYNAMIC_IMPORT', 'IMPORT_META', 'NEW_TARGET', 'UNDEFINED', 'NULL', 'BOOL', 'UNARY', 'DO', 'DO_IIFE', 'YIELD', 'AWAIT', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];
  IMPLICIT_UNSPACED_CALL = ['+', '-'];

  // Tokens that always mark the end of an implicit call for single-liners.
  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];

  // Single-line flavors of block expressions that have unclosed endings.
  // The grammar cant disambiguate them, so we insert the implicit indentation.
  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];
  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  // Tokens that end a line.
  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

  // Tokens that close open calls when they follow a newline.
  CALL_CLOSERS = ['.', '?.', '::', '?::'];

  // Tokens that prevent a subsequent indent from ending implicit calls/objects
  CONTROL_IN_IMPLICIT = ['IF', 'TRY', 'FINALLY', 'CATCH', 'CLASS', 'SWITCH'];

  // Tokens that are swallowed up by the parser, never leading to code generation.
  // You can spot these in `grammar.coffee` because the `o` function second
  // argument doesnt contain a `new` call for these tokens.
  // `STRING_START` isnt on this list because its `locationData` matches that of
  // the node that becomes `StringWithInterpolations`, and therefore
  // `addDataToNode` attaches `STRING_START`s tokens to that node.
  DISCARDED = ['(', ')', '[', ']', '{', '}', ':', '.', '..', '...', ',', '=', '++', '--', '?', 'AS', 'AWAIT', 'CALL_START', 'CALL_END', 'DEFAULT', 'DO', 'DO_IIFE', 'ELSE', 'EXTENDS', 'EXPORT', 'FORIN', 'FOROF', 'FORFROM', 'IMPORT', 'INDENT', 'INDEX_SOAK', 'INTERPOLATION_START', 'INTERPOLATION_END', 'LEADING_WHEN', 'OUTDENT', 'PARAM_END', 'REGEX_START', 'REGEX_END', 'RETURN', 'STRING_END', 'THROW', 'UNARY', 'YIELD'].concat(IMPLICIT_UNSPACED_CALL.concat(IMPLICIT_END.concat(CALL_CLOSERS.concat(CONTROL_IN_IMPLICIT))));

  // Tokens that, when appearing at the end of a line, suppress a following TERMINATOR/INDENT token
  exports.UNFINISHED = UNFINISHED = ['\\', '.', '?.', '?::', 'UNARY', 'DO', 'DO_IIFE', 'MATH', 'UNARY_MATH', '+', '-', '**', 'SHIFT', 'RELATION', 'COMPARE', '&', '^', '|', '&&', '||', 'BIN?', 'EXTENDS'];
}).call(void 0);
}),
/* --- node_modules/coffeescript/lib/coffeescript/scope.js --- */
"node_modules/coffeescript/lib/coffeescript/scope.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

// Generated by CoffeeScript 2.7.0
(function () {
  // The **Scope** class regulates lexical scoping within CoffeeScript. As you
  // generate code, you create a tree of scopes in the same shape as the nested
  // function bodies. Each scope knows about the variables declared within it,
  // and has a reference to its parent enclosing scope. In this way, we know which
  // variables are new and need to be declared with `var`, and which are shared
  // with external scopes.
  var Scope,
    indexOf = [].indexOf;
  exports.Scope = Scope = class Scope {
    // Initialize a scope with its parent, for lookups up the chain,
    // as well as a reference to the **Block** node it belongs to, which is
    // where it should declare its variables, a reference to the function that
    // it belongs to, and a list of variables referenced in the source code
    // and therefore should be avoided when generating variables. Also track comments
    // that should be output as part of variable declarations.
    constructor(parent, expressions, method, referencedVars) {
      var ref, ref1;
      this.parent = parent;
      this.expressions = expressions;
      this.method = method;
      this.referencedVars = referencedVars;
      this.variables = [{
        name: 'arguments',
        type: 'arguments'
      }];
      this.comments = {};
      this.positions = {};
      if (!this.parent) {
        this.utilities = {};
      }
      // The `@root` is the top-level **Scope** object for a given file.
      this.root = (ref = (ref1 = this.parent) != null ? ref1.root : void 0) != null ? ref : this;
    }

    // Adds a new variable or overrides an existing one.
    add(name, type, immediate) {
      if (this.shared && !immediate) {
        return this.parent.add(name, type, immediate);
      }
      if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
        return this.variables[this.positions[name]].type = type;
      } else {
        return this.positions[name] = this.variables.push({
          name,
          type
        }) - 1;
      }
    }

    // When `super` is called, we need to find the name of the current method we're
    // in, so that we know how to invoke the same method of the parent class. This
    // can get complicated if super is being called from an inner function.
    // `namedMethod` will walk up the scope tree until it either finds the first
    // function object that has a name filled in, or bottoms out.
    namedMethod() {
      var ref;
      if (((ref = this.method) != null ? ref.name : void 0) || !this.parent) {
        return this.method;
      }
      return this.parent.namedMethod();
    }

    // Look up a variable name in lexical scope, and declare it if it does not
    // already exist.
    find(name, type = 'var') {
      if (this.check(name)) {
        return true;
      }
      this.add(name, type);
      return false;
    }

    // Reserve a variable name as originating from a function parameter for this
    // scope. No `var` required for internal references.
    parameter(name) {
      if (this.shared && this.parent.check(name, true)) {
        return;
      }
      return this.add(name, 'param');
    }

    // Just check to see if a variable has already been declared, without reserving,
    // walks up to the root scope.
    check(name) {
      var ref;
      return !!(this.type(name) || ((ref = this.parent) != null ? ref.check(name) : void 0));
    }

    // Generate a temporary variable name at the given index.
    temporary(name, index, single = false) {
      var diff, endCode, letter, newCode, num, startCode;
      if (single) {
        startCode = name.charCodeAt(0);
        endCode = 'z'.charCodeAt(0);
        diff = endCode - startCode;
        newCode = startCode + index % (diff + 1);
        letter = String.fromCharCode(newCode);
        num = Math.floor(index / (diff + 1));
        return `${letter}${num || ''}`;
      } else {
        return `${name}${index || ''}`;
      }
    }

    // Gets the type of a variable.
    type(name) {
      var i, len, ref, v;
      ref = this.variables;
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        if (v.name === name) {
          return v.type;
        }
      }
      return null;
    }

    // If we need to store an intermediate result, find an available name for a
    // compiler-generated variable. `_var`, `_var2`, and so on...
    freeVariable(name, options = {}) {
      var index, ref, temp;
      index = 0;
      while (true) {
        temp = this.temporary(name, index, options.single);
        if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) >= 0)) {
          break;
        }
        index++;
      }
      if ((ref = options.reserve) != null ? ref : true) {
        this.add(temp, 'var', true);
      }
      return temp;
    }

    // Ensure that an assignment is made at the top of this scope
    // (or at the top-level scope, if requested).
    assign(name, value) {
      this.add(name, {
        value,
        assigned: true
      }, true);
      return this.hasAssignments = true;
    }

    // Does this scope have any declared variables?
    hasDeclarations() {
      return !!this.declaredVariables().length;
    }

    // Return the list of variables first declared in this scope.
    declaredVariables() {
      var v;
      return function () {
        var i, len, ref, results;
        ref = this.variables;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          v = ref[i];
          if (v.type === 'var') {
            results.push(v.name);
          }
        }
        return results;
      }.call(this).sort();
    }

    // Return the list of assignments that are supposed to be made at the top
    // of this scope.
    assignedVariables() {
      var i, len, ref, results, v;
      ref = this.variables;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        if (v.type.assigned) {
          results.push(`${v.name} = ${v.type.value}`);
        }
      }
      return results;
    }
  };
}).call(void 0);
}),
/* --- node_modules/yaml/dist/compose/compose-collection.js --- */
"node_modules/yaml/dist/compose/compose-collection.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var resolveBlockMap = _kame_require_("node_modules/yaml/dist/compose/resolve-block-map.js");
var resolveBlockSeq = _kame_require_("node_modules/yaml/dist/compose/resolve-block-seq.js");
var resolveFlowCollection = _kame_require_("node_modules/yaml/dist/compose/resolve-flow-collection.js");
function composeCollection(CN, ctx, token, tagToken, onError) {
  var _tag;
  let coll;
  switch (token.type) {
    case 'block-map':
      {
        coll = resolveBlockMap.resolveBlockMap(CN, ctx, token, onError);
        break;
      }
    case 'block-seq':
      {
        coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError);
        break;
      }
    case 'flow-collection':
      {
        coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError);
        break;
      }
  }
  if (!tagToken) return coll;
  const tagName = ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
  if (!tagName) return coll;
  // Cast needed due to: https://github.com/Microsoft/TypeScript/issues/3841
  const Coll = coll.constructor;
  if (tagName === '!' || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = Node.isMap(coll) ? 'map' : 'seq';
  let tag = ctx.schema.tags.find(t => t.collection === expType && t.tag === tagName);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, {
        default: false
      }));
      tag = kt;
    } else {
      onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options);
  const node = Node.isNode(res) ? res : new Scalar.Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if ((_tag = tag) !== null && _tag !== void 0 && _tag.format) node.format = tag.format;
  return node;
}
exports.composeCollection = composeCollection;
}),
/* --- node_modules/yaml/dist/compose/compose-scalar.js --- */
"node_modules/yaml/dist/compose/compose-scalar.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var resolveBlockScalar = _kame_require_("node_modules/yaml/dist/compose/resolve-block-scalar.js");
var resolveFlowScalar = _kame_require_("node_modules/yaml/dist/compose/resolve-flow-scalar.js");
function composeScalar(ctx, token, tagToken, onError) {
  const {
    value,
    type,
    comment,
    range
  } = token.type === 'block-scalar' ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === 'scalar' ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[Node.SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
    scalar = Node.isScalar(res) ? res : new Scalar.Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
    scalar = new Scalar.Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type) scalar.type = type;
  if (tagName) scalar.tag = tagName;
  if (tag.format) scalar.format = tag.format;
  if (comment) scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
  if (tagName === '!') return schema[Node.SCALAR]; // non-specific tag
  const matchWithTest = [];
  for (const tag of schema.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test) matchWithTest.push(tag);else return tag;
    }
  }
  for (const tag of matchWithTest) {
    var _tag$test;
    if ((_tag$test = tag.test) !== null && _tag$test !== void 0 && _tag$test.test(value)) return tag;
  }
  const kt = schema.knownTags[tagName];
  if (kt && !kt.collection) {
    // Ensure that the known tag is available for stringifying,
    // but does not get used by default.
    schema.tags.push(Object.assign({}, kt, {
      default: false,
      test: undefined
    }));
    return kt;
  }
  onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
  return schema[Node.SCALAR];
}
function findScalarTagByTest({
  directives,
  schema
}, value, token, onError) {
  const tag = schema.tags.find(tag => {
    var _tag$test2;
    return tag.default && ((_tag$test2 = tag.test) === null || _tag$test2 === void 0 ? void 0 : _tag$test2.test(value));
  }) || schema[Node.SCALAR];
  if (schema.compat) {
    const compat = schema.compat.find(tag => {
      var _tag$test3;
      return tag.default && ((_tag$test3 = tag.test) === null || _tag$test3 === void 0 ? void 0 : _tag$test3.test(value));
    }) ?? schema[Node.SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, 'TAG_RESOLVE_FAILED', msg, true);
    }
  }
  return tag;
}
exports.composeScalar = composeScalar;
}),
/* --- node_modules/yaml/dist/compose/util-empty-scalar-position.js --- */
"node_modules/yaml/dist/compose/util-empty-scalar-position.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null) pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case 'space':
        case 'comment':
        case 'newline':
          offset -= st.source.length;
          continue;
      }
      // Technically, an empty scalar is immediately after the last non-empty
      // node, but it's more useful to place it after any whitespace.
      st = before[++i];
      while (((_st = st) === null || _st === void 0 ? void 0 : _st.type) === 'space') {
        var _st;
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}
exports.emptyScalarPosition = emptyScalarPosition;
}),
/* --- node_modules/yaml/dist/stringify/foldFlowLines.js --- */
"node_modules/yaml/dist/stringify/foldFlowLines.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', {
  indentAtStart,
  lineWidth = 80,
  minContentWidth = 20,
  onFold,
  onOverflow
} = {}) {
  if (!lineWidth || lineWidth < 0) return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep) return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === 'number') {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;
  }
  let split = undefined;
  let prev = undefined;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1) end = i + endStep;
  }
  for (let ch; ch = text[i += 1];) {
    if (mode === FOLD_QUOTED && ch === '\\') {
      escStart = i;
      switch (text[i + 1]) {
        case 'x':
          i += 3;
          break;
        case 'u':
          i += 5;
          break;
        case 'U':
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === '\n') {
      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = undefined;
    } else {
      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
        // space surrounded by non-space can be replaced with newline + indent
        const next = text[i + 1];
        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = undefined;
        } else if (mode === FOLD_QUOTED) {
          // white-space collected at end may stretch past lineWidth
          while (prev === ' ' || prev === '\t') {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          // Account for newline escape, but don't break preceding escape
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          // Bail out if lineWidth & minContentWidth are shorter than an escape string
          if (escapedFolds[j]) return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = undefined;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow) onOverflow();
  if (folds.length === 0) return text;
  if (onFold) onFold();
  let res = text.slice(0, folds[0]);
  for (let i = 0; i < folds.length; ++i) {
    const fold = folds[i];
    const end = folds[i + 1] || text.length;
    if (fold === 0) res = `\n${indent}${text.slice(0, end)}`;else {
      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
      res += `\n${indent}${text.slice(fold + 1, end)}`;
    }
  }
  return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === ' ' || ch === '\t') {
    do {
      ch = text[i += 1];
    } while (ch && ch !== '\n');
    ch = text[i + 1];
  }
  return i;
}
exports.FOLD_BLOCK = FOLD_BLOCK;
exports.FOLD_FLOW = FOLD_FLOW;
exports.FOLD_QUOTED = FOLD_QUOTED;
exports.foldFlowLines = foldFlowLines;
}),
/* --- node_modules/yaml/dist/stringify/stringifyNumber.js --- */
"node_modules/yaml/dist/stringify/stringifyNumber.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

function stringifyNumber({
  format,
  minFractionDigits,
  tag,
  value
}) {
  if (typeof value === 'bigint') return String(value);
  const num = typeof value === 'number' ? value : Number(value);
  if (!isFinite(num)) return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
    let i = n.indexOf('.');
    if (i < 0) {
      i = n.length;
      n += '.';
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0) n += '0';
  }
  return n;
}
exports.stringifyNumber = stringifyNumber;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/bool.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/bool.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
function boolStringify({
  value,
  source
}, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source)) return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
  identify: value => value === true,
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar.Scalar(true),
  stringify: boolStringify
};
const falseTag = {
  identify: value => value === false,
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar.Scalar(false),
  stringify: boolStringify
};
exports.falseTag = falseTag;
exports.trueTag = trueTag;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/float.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/float.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Scalar = _kame_require_("node_modules/yaml/dist/nodes/Scalar.js");
var stringifyNumber = _kame_require_("node_modules/yaml/dist/stringify/stringifyNumber.js");
const floatNaN = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: str => str.slice(-3).toLowerCase() === 'nan' ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str.replace(/_/g, '')),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
  }
};
const float = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
    const dot = str.indexOf('.');
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, '');
      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber.stringifyNumber
};
exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;
}),
/* --- node_modules/yaml/dist/schema/yaml-1.1/int.js --- */
"node_modules/yaml/dist/schema/yaml-1.1/int.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var stringifyNumber = _kame_require_("node_modules/yaml/dist/stringify/stringifyNumber.js");
const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, {
  intAsBigInt
}) {
  const sign = str[0];
  if (sign === '-' || sign === '+') offset += 1;
  str = str.substring(offset).replace(/_/g, '');
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n = BigInt(str);
    return sign === '-' ? BigInt(-1) * n : n;
  }
  const n = parseInt(str, radix);
  return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
  const {
    value
  } = node;
  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber.stringifyNumber(node);
}
const intBin = {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'BIN',
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
  stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
  stringify: node => intStringify(node, 8, '0')
};
const int = {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber.stringifyNumber
};
const intHex = {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: node => intStringify(node, 16, '0x')
};
exports.int = int;
exports.intBin = intBin;
exports.intHex = intHex;
exports.intOct = intOct;
}),
/* --- node_modules/sucrase/dist/parser/tokenizer/readWordTree.js --- */
"node_modules/sucrase/dist/parser/tokenizer/readWordTree.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Generated file, do not edit! Run "yarn generate" to re-generate this file.
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");

// prettier-ignore
const READ_WORD_TREE = new Int32Array([
// ""
-1, 27, 783, 918, 1755, 2376, 2862, 3483, -1, 3699, -1, 4617, 4752, 4833, 5130, 5508, 5940, -1, 6480, 6939, 7749, 8181, 8343, 8505, -1, 8721, -1,
// "a"
-1, -1, 54, 243, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 432, -1, -1, -1, 675, -1, -1, -1,
// "ab"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1,
// "abs"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1,
// "abst"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 135, -1, -1, -1, -1, -1, -1, -1, -1,
// "abstr"
-1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "abstra"
-1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "abstrac"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1,
// "abstract"
_keywords.ContextualKeyword._abstract << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ac"
-1, -1, -1, 270, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "acc"
-1, -1, -1, -1, -1, 297, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "acce"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 324, -1, -1, -1, -1, -1, -1, -1,
// "acces"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 351, -1, -1, -1, -1, -1, -1, -1,
// "access"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 378, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "accesso"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 405, -1, -1, -1, -1, -1, -1, -1, -1,
// "accessor"
_keywords.ContextualKeyword._accessor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "as"
_keywords.ContextualKeyword._as << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 459, -1, -1, -1, -1, -1, 594, -1,
// "ass"
-1, -1, -1, -1, -1, 486, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "asse"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 513, -1, -1, -1, -1, -1, -1, -1, -1,
// "asser"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 540, -1, -1, -1, -1, -1, -1,
// "assert"
_keywords.ContextualKeyword._assert << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 567, -1, -1, -1, -1, -1, -1, -1,
// "asserts"
_keywords.ContextualKeyword._asserts << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "asy"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 621, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "asyn"
-1, -1, -1, 648, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "async"
_keywords.ContextualKeyword._async << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "aw"
-1, 702, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "awa"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 729, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "awai"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 756, -1, -1, -1, -1, -1, -1,
// "await"
_keywords.ContextualKeyword._await << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "b"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 810, -1, -1, -1, -1, -1, -1, -1, -1,
// "br"
-1, -1, -1, -1, -1, 837, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "bre"
-1, 864, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "brea"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 891, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "break"
(_types.TokenType._break << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "c"
-1, 945, -1, -1, -1, -1, -1, -1, 1107, -1, -1, -1, 1242, -1, -1, 1350, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ca"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 972, 1026, -1, -1, -1, -1, -1, -1,
// "cas"
-1, -1, -1, -1, -1, 999, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "case"
(_types.TokenType._case << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "cat"
-1, -1, -1, 1053, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "catc"
-1, -1, -1, -1, -1, -1, -1, -1, 1080, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "catch"
(_types.TokenType._catch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ch"
-1, -1, -1, -1, -1, 1134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "che"
-1, -1, -1, 1161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "chec"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1188, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "check"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1215, -1, -1, -1, -1, -1, -1, -1,
// "checks"
_keywords.ContextualKeyword._checks << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "cl"
-1, 1269, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "cla"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1296, -1, -1, -1, -1, -1, -1, -1,
// "clas"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1323, -1, -1, -1, -1, -1, -1, -1,
// "class"
(_types.TokenType._class << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "co"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1377, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "con"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1404, 1620, -1, -1, -1, -1, -1, -1,
// "cons"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1431, -1, -1, -1, -1, -1, -1,
// "const"
(_types.TokenType._const << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1458, -1, -1, -1, -1, -1, -1, -1, -1,
// "constr"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1485, -1, -1, -1, -1, -1,
// "constru"
-1, -1, -1, 1512, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "construc"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1539, -1, -1, -1, -1, -1, -1,
// "construct"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1566, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "constructo"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1593, -1, -1, -1, -1, -1, -1, -1, -1,
// "constructor"
_keywords.ContextualKeyword._constructor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "cont"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 1647, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "conti"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1674, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "contin"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1701, -1, -1, -1, -1, -1,
// "continu"
-1, -1, -1, -1, -1, 1728, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "continue"
(_types.TokenType._continue << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "d"
-1, -1, -1, -1, -1, 1782, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2349, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "de"
-1, -1, 1809, 1971, -1, -1, 2106, -1, -1, -1, -1, -1, 2241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "deb"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1836, -1, -1, -1, -1, -1,
// "debu"
-1, -1, -1, -1, -1, -1, -1, 1863, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "debug"
-1, -1, -1, -1, -1, -1, -1, 1890, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "debugg"
-1, -1, -1, -1, -1, 1917, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "debugge"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1944, -1, -1, -1, -1, -1, -1, -1, -1,
// "debugger"
(_types.TokenType._debugger << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "dec"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1998, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "decl"
-1, 2025, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "decla"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2052, -1, -1, -1, -1, -1, -1, -1, -1,
// "declar"
-1, -1, -1, -1, -1, 2079, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "declare"
_keywords.ContextualKeyword._declare << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "def"
-1, 2133, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "defa"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2160, -1, -1, -1, -1, -1,
// "defau"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "defaul"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2214, -1, -1, -1, -1, -1, -1,
// "default"
(_types.TokenType._default << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "del"
-1, -1, -1, -1, -1, 2268, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "dele"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2295, -1, -1, -1, -1, -1, -1,
// "delet"
-1, -1, -1, -1, -1, 2322, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "delete"
(_types.TokenType._delete << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "do"
(_types.TokenType._do << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "e"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2403, -1, 2484, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2565, -1, -1,
// "el"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2430, -1, -1, -1, -1, -1, -1, -1,
// "els"
-1, -1, -1, -1, -1, 2457, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "else"
(_types.TokenType._else << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "en"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2511, -1, -1, -1, -1, -1,
// "enu"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2538, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "enum"
_keywords.ContextualKeyword._enum << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ex"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2592, -1, -1, -1, 2727, -1, -1, -1, -1, -1, -1,
// "exp"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2619, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "expo"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2646, -1, -1, -1, -1, -1, -1, -1, -1,
// "expor"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2673, -1, -1, -1, -1, -1, -1,
// "export"
(_types.TokenType._export << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2700, -1, -1, -1, -1, -1, -1, -1,
// "exports"
_keywords.ContextualKeyword._exports << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ext"
-1, -1, -1, -1, -1, 2754, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "exte"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2781, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "exten"
-1, -1, -1, -1, 2808, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "extend"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2835, -1, -1, -1, -1, -1, -1, -1,
// "extends"
(_types.TokenType._extends << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "f"
-1, 2889, -1, -1, -1, -1, -1, -1, -1, 2997, -1, -1, -1, -1, -1, 3159, -1, -1, 3213, -1, -1, 3294, -1, -1, -1, -1, -1,
// "fa"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2916, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fal"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2943, -1, -1, -1, -1, -1, -1, -1,
// "fals"
-1, -1, -1, -1, -1, 2970, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "false"
(_types.TokenType._false << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3024, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fin"
-1, 3051, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fina"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3078, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "final"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3105, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "finall"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3132, -1,
// "finally"
(_types.TokenType._finally << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fo"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3186, -1, -1, -1, -1, -1, -1, -1, -1,
// "for"
(_types.TokenType._for << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fr"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fro"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3267, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "from"
_keywords.ContextualKeyword._from << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fu"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3321, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "fun"
-1, -1, -1, 3348, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "func"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3375, -1, -1, -1, -1, -1, -1,
// "funct"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 3402, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "functi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3429, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "functio"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3456, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "function"
(_types.TokenType._function << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "g"
-1, -1, -1, -1, -1, 3510, -1, -1, -1, -1, -1, -1, 3564, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ge"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3537, -1, -1, -1, -1, -1, -1,
// "get"
_keywords.ContextualKeyword._get << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "gl"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3591, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "glo"
-1, -1, 3618, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "glob"
-1, 3645, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "globa"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3672, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "global"
_keywords.ContextualKeyword._global << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "i"
-1, -1, -1, -1, -1, -1, 3726, -1, -1, -1, -1, -1, -1, 3753, 4077, -1, -1, -1, -1, 4590, -1, -1, -1, -1, -1, -1, -1,
// "if"
(_types.TokenType._if << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "im"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3780, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "imp"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3807, -1, -1, 3996, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "impl"
-1, -1, -1, -1, -1, 3834, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "imple"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3861, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "implem"
-1, -1, -1, -1, -1, 3888, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "impleme"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3915, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "implemen"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3942, -1, -1, -1, -1, -1, -1,
// "implement"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3969, -1, -1, -1, -1, -1, -1, -1,
// "implements"
_keywords.ContextualKeyword._implements << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "impo"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4023, -1, -1, -1, -1, -1, -1, -1, -1,
// "impor"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4050, -1, -1, -1, -1, -1, -1,
// "import"
(_types.TokenType._import << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "in"
(_types.TokenType._in << 1) + 1, -1, -1, -1, -1, -1, 4104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4185, 4401, -1, -1, -1, -1, -1, -1,
// "inf"
-1, -1, -1, -1, -1, 4131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "infe"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4158, -1, -1, -1, -1, -1, -1, -1, -1,
// "infer"
_keywords.ContextualKeyword._infer << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ins"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4212, -1, -1, -1, -1, -1, -1,
// "inst"
-1, 4239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "insta"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "instan"
-1, -1, -1, 4293, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "instanc"
-1, -1, -1, -1, -1, 4320, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "instance"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4347, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "instanceo"
-1, -1, -1, -1, -1, -1, 4374, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "instanceof"
(_types.TokenType._instanceof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "int"
-1, -1, -1, -1, -1, 4428, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "inte"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4455, -1, -1, -1, -1, -1, -1, -1, -1,
// "inter"
-1, -1, -1, -1, -1, -1, 4482, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "interf"
-1, 4509, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "interfa"
-1, -1, -1, 4536, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "interfac"
-1, -1, -1, -1, -1, 4563, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "interface"
_keywords.ContextualKeyword._interface << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "is"
_keywords.ContextualKeyword._is << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "k"
-1, -1, -1, -1, -1, 4644, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ke"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4671, -1,
// "key"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4698, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "keyo"
-1, -1, -1, -1, -1, -1, 4725, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "keyof"
_keywords.ContextualKeyword._keyof << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "l"
-1, -1, -1, -1, -1, 4779, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "le"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4806, -1, -1, -1, -1, -1, -1,
// "let"
(_types.TokenType._let << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "m"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 4860, -1, -1, -1, -1, -1, 4995, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "mi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4887, -1, -1,
// "mix"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 4914, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "mixi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4941, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "mixin"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4968, -1, -1, -1, -1, -1, -1, -1,
// "mixins"
_keywords.ContextualKeyword._mixins << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "mo"
-1, -1, -1, -1, 5022, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "mod"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5049, -1, -1, -1, -1, -1,
// "modu"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5076, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "modul"
-1, -1, -1, -1, -1, 5103, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "module"
_keywords.ContextualKeyword._module << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "n"
-1, 5157, -1, -1, -1, 5373, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5427, -1, -1, -1, -1, -1,
// "na"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "nam"
-1, -1, -1, -1, -1, 5211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "name"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5238, -1, -1, -1, -1, -1, -1, -1,
// "names"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "namesp"
-1, 5292, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "namespa"
-1, -1, -1, 5319, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "namespac"
-1, -1, -1, -1, -1, 5346, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "namespace"
_keywords.ContextualKeyword._namespace << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ne"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5400, -1, -1, -1,
// "new"
(_types.TokenType._new << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "nu"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5454, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "nul"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5481, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "null"
(_types.TokenType._null << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "o"
-1, -1, -1, -1, -1, -1, 5535, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5562, -1, -1, -1, -1, 5697, 5751, -1, -1, -1, -1,
// "of"
_keywords.ContextualKeyword._of << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "op"
-1, 5589, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "opa"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5616, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "opaq"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5643, -1, -1, -1, -1, -1,
// "opaqu"
-1, -1, -1, -1, -1, 5670, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "opaque"
_keywords.ContextualKeyword._opaque << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ou"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5724, -1, -1, -1, -1, -1, -1,
// "out"
_keywords.ContextualKeyword._out << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ov"
-1, -1, -1, -1, -1, 5778, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ove"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5805, -1, -1, -1, -1, -1, -1, -1, -1,
// "over"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5832, -1, -1, -1, -1, -1, -1, -1, -1,
// "overr"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 5859, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "overri"
-1, -1, -1, -1, 5886, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "overrid"
-1, -1, -1, -1, -1, 5913, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "override"
_keywords.ContextualKeyword._override << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "p"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5967, -1, -1, 6345, -1, -1, -1, -1, -1,
// "pr"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 5994, -1, -1, -1, -1, -1, 6129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "pri"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6021, -1, -1, -1, -1,
// "priv"
-1, 6048, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "priva"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6075, -1, -1, -1, -1, -1, -1,
// "privat"
-1, -1, -1, -1, -1, 6102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "private"
_keywords.ContextualKeyword._private << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "pro"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6156, -1, -1, -1, -1, -1, -1,
// "prot"
-1, -1, -1, -1, -1, 6183, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6318, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "prote"
-1, -1, -1, 6210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "protec"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6237, -1, -1, -1, -1, -1, -1,
// "protect"
-1, -1, -1, -1, -1, 6264, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "protecte"
-1, -1, -1, -1, 6291, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "protected"
_keywords.ContextualKeyword._protected << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "proto"
_keywords.ContextualKeyword._proto << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "pu"
-1, -1, 6372, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "pub"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6399, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "publ"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 6426, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "publi"
-1, -1, -1, 6453, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "public"
_keywords.ContextualKeyword._public << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "r"
-1, -1, -1, -1, -1, 6507, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "re"
-1, 6534, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6696, -1, -1, 6831, -1, -1, -1, -1, -1, -1,
// "rea"
-1, -1, -1, -1, 6561, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "read"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6588, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "reado"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6615, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "readon"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6642, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "readonl"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6669, -1,
// "readonly"
_keywords.ContextualKeyword._readonly << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "req"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6723, -1, -1, -1, -1, -1,
// "requ"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 6750, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "requi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6777, -1, -1, -1, -1, -1, -1, -1, -1,
// "requir"
-1, -1, -1, -1, -1, 6804, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "require"
_keywords.ContextualKeyword._require << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ret"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6858, -1, -1, -1, -1, -1,
// "retu"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6885, -1, -1, -1, -1, -1, -1, -1, -1,
// "retur"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6912, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "return"
(_types.TokenType._return << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "s"
-1, 6966, -1, -1, -1, 7182, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7236, 7371, -1, 7479, -1, 7614, -1,
// "sa"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6993, -1, -1, -1, -1, -1, -1,
// "sat"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 7020, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "sati"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7047, -1, -1, -1, -1, -1, -1, -1,
// "satis"
-1, -1, -1, -1, -1, -1, 7074, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "satisf"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 7101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "satisfi"
-1, -1, -1, -1, -1, 7128, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "satisfie"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7155, -1, -1, -1, -1, -1, -1, -1,
// "satisfies"
_keywords.ContextualKeyword._satisfies << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "se"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7209, -1, -1, -1, -1, -1, -1,
// "set"
_keywords.ContextualKeyword._set << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "st"
-1, 7263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "sta"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7290, -1, -1, -1, -1, -1, -1,
// "stat"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 7317, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "stati"
-1, -1, -1, 7344, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "static"
_keywords.ContextualKeyword._static << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "su"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7398, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "sup"
-1, -1, -1, -1, -1, 7425, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "supe"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7452, -1, -1, -1, -1, -1, -1, -1, -1,
// "super"
(_types.TokenType._super << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "sw"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 7506, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "swi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7533, -1, -1, -1, -1, -1, -1,
// "swit"
-1, -1, -1, 7560, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "switc"
-1, -1, -1, -1, -1, -1, -1, -1, 7587, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "switch"
(_types.TokenType._switch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "sy"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7641, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "sym"
-1, -1, 7668, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "symb"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7695, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "symbo"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7722, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "symbol"
_keywords.ContextualKeyword._symbol << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "t"
-1, -1, -1, -1, -1, -1, -1, -1, 7776, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7938, -1, -1, -1, -1, -1, -1, 8046, -1,
// "th"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 7803, -1, -1, -1, -1, -1, -1, -1, -1, 7857, -1, -1, -1, -1, -1, -1, -1, -1,
// "thi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7830, -1, -1, -1, -1, -1, -1, -1,
// "this"
(_types.TokenType._this << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "thr"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7884, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "thro"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7911, -1, -1, -1,
// "throw"
(_types.TokenType._throw << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "tr"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7965, -1, -1, -1, 8019, -1,
// "tru"
-1, -1, -1, -1, -1, 7992, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "true"
(_types.TokenType._true << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "try"
(_types.TokenType._try << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "ty"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8073, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "typ"
-1, -1, -1, -1, -1, 8100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "type"
_keywords.ContextualKeyword._type << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "typeo"
-1, -1, -1, -1, -1, -1, 8154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "typeof"
(_types.TokenType._typeof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "u"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8208, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "un"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 8235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "uni"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8262, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "uniq"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8289, -1, -1, -1, -1, -1,
// "uniqu"
-1, -1, -1, -1, -1, 8316, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "unique"
_keywords.ContextualKeyword._unique << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "v"
-1, 8370, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8424, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "va"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8397, -1, -1, -1, -1, -1, -1, -1, -1,
// "var"
(_types.TokenType._var << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "vo"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 8451, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "voi"
-1, -1, -1, -1, 8478, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "void"
(_types.TokenType._void << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "w"
-1, -1, -1, -1, -1, -1, -1, -1, 8532, 8640, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "wh"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 8559, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "whi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8586, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "whil"
-1, -1, -1, -1, -1, 8613, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "while"
(_types.TokenType._while << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "wi"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8667, -1, -1, -1, -1, -1, -1,
// "wit"
-1, -1, -1, -1, -1, -1, -1, -1, 8694, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "with"
(_types.TokenType._with << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "y"
-1, -1, -1, -1, -1, -1, -1, -1, -1, 8748, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "yi"
-1, -1, -1, -1, -1, 8775, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "yie"
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8802, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "yiel"
-1, -1, -1, -1, 8829, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
// "yield"
(_types.TokenType._yield << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);
exports.READ_WORD_TREE = READ_WORD_TREE;
}),
/* --- node_modules/sucrase/dist/parser/plugins/flow.js --- */
"node_modules/sucrase/dist/parser/plugins/flow.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
}); /* eslint max-len: 0 */

var _index = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _expression = _kame_require_("node_modules/sucrase/dist/parser/traverser/expression.js");
var _statement = _kame_require_("node_modules/sucrase/dist/parser/traverser/statement.js");
var _util = _kame_require_("node_modules/sucrase/dist/parser/traverser/util.js");
function isMaybeDefaultImport(lookahead) {
  return (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from;
}
function flowParseTypeInitialiser(tok) {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, tok || _types.TokenType.colon);
  flowParseType();
  _index.popTypeContext.call(void 0, oldIsType);
}
function flowParsePredicate() {
  _util.expect.call(void 0, _types.TokenType.modulo);
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._checks);
  if (_index.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseExpression.call(void 0);
    _util.expect.call(void 0, _types.TokenType.parenR);
  }
}
function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.colon);
  if (_index.match.call(void 0, _types.TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.modulo)) {
      flowParsePredicate();
    }
  }
  _index.popTypeContext.call(void 0, oldIsType);
}
function flowParseDeclareClass() {
  _index.next.call(void 0);
  flowParseInterfaceish( /* isClass */true);
}
function flowParseDeclareFunction() {
  _index.next.call(void 0);
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  _util.expect.call(void 0, _types.TokenType.parenL);
  flowParseFunctionTypeParams();
  _util.expect.call(void 0, _types.TokenType.parenR);
  flowParseTypeAndPredicateInitialiser();
  _util.semicolon.call(void 0);
}
function flowParseDeclare() {
  if (_index.match.call(void 0, _types.TokenType._class)) {
    flowParseDeclareClass();
  } else if (_index.match.call(void 0, _types.TokenType._function)) {
    flowParseDeclareFunction();
  } else if (_index.match.call(void 0, _types.TokenType._var)) {
    flowParseDeclareVariable();
  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._module)) {
    if (_index.eat.call(void 0, _types.TokenType.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (_index.match.call(void 0, _types.TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    _util.unexpected.call(void 0);
  }
}
function flowParseDeclareVariable() {
  _index.next.call(void 0);
  flowParseTypeAnnotatableIdentifier();
  _util.semicolon.call(void 0);
}
function flowParseDeclareModule() {
  if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0);
  } else {
    _expression.parseIdentifier.call(void 0);
  }
  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.match.call(void 0, _types.TokenType._import)) {
      _index.next.call(void 0);
      _statement.parseImport.call(void 0);
    } else {
      _util.unexpected.call(void 0);
    }
  }
  _util.expect.call(void 0, _types.TokenType.braceR);
}
function flowParseDeclareExportDeclaration() {
  _util.expect.call(void 0, _types.TokenType._export);
  if (_index.eat.call(void 0, _types.TokenType._default)) {
    if (_index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      _util.semicolon.call(void 0);
    }
  } else if (_index.match.call(void 0, _types.TokenType._var) ||
  // declare export var ...
  _index.match.call(void 0, _types.TokenType._function) ||
  // declare export function ...
  _index.match.call(void 0, _types.TokenType._class) ||
  // declare export class ...
  _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (_index.match.call(void 0, _types.TokenType.star) ||
  // declare export * from ''
  _index.match.call(void 0, _types.TokenType.braceL) ||
  // declare export {} ...
  _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) ||
  // declare export interface ...
  _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) ||
  // declare export type ...
  _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    _statement.parseExport.call(void 0);
  } else {
    _util.unexpected.call(void 0);
  }
}
function flowParseDeclareModuleExports() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._exports);
  flowParseTypeAnnotation();
  _util.semicolon.call(void 0);
}
function flowParseDeclareTypeAlias() {
  _index.next.call(void 0);
  flowParseTypeAlias();
}
function flowParseDeclareOpaqueType() {
  _index.next.call(void 0);
  flowParseOpaqueType(true);
}
function flowParseDeclareInterface() {
  _index.next.call(void 0);
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && _index.eat.call(void 0, _types.TokenType.comma));
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._mixins)) {
    _index.next.call(void 0);
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
    _index.next.call(void 0);
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }
  flowParseObjectType(isClass, false, isClass);
}
function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}
function flowParseInterface() {
  flowParseInterfaceish();
}
function flowParseRestrictedIdentifier() {
  _expression.parseIdentifier.call(void 0);
}
function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  flowParseTypeInitialiser(_types.TokenType.eq);
  _util.semicolon.call(void 0);
}
function flowParseOpaqueType(declare) {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
  flowParseRestrictedIdentifier();
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeInitialiser(_types.TokenType.colon);
  }
  if (!declare) {
    flowParseTypeInitialiser(_types.TokenType.eq);
  }
  _util.semicolon.call(void 0);
}
function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    flowParseType();
  }
}
function flowParseTypeParameterDeclaration() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {
    _index.next.call(void 0);
  } else {
    _util.unexpected.call(void 0);
  }
  do {
    flowParseTypeParameter();
    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  } while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error);
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
}
exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;
function flowParseTypeParameterInstantiation() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.lessThan);
  while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
    flowParseType();
    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
}
function flowParseInterfaceType() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._interface);
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }
  flowParseObjectType(false, false, false);
}
function flowParseObjectPropertyKey() {
  if (_index.match.call(void 0, _types.TokenType.num) || _index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0);
  } else {
    _expression.parseIdentifier.call(void 0);
  }
}
function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (_index.lookaheadType.call(void 0) === _types.TokenType.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
  flowParseTypeInitialiser();
}
function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  _util.expect.call(void 0, _types.TokenType.bracketR);
  _util.expect.call(void 0, _types.TokenType.bracketR);
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    _index.eat.call(void 0, _types.TokenType.question);
    flowParseTypeInitialiser();
  }
}
function flowParseObjectTypeMethodish() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  _util.expect.call(void 0, _types.TokenType.parenL);
  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();
    if (!_index.match.call(void 0, _types.TokenType.parenR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  _util.expect.call(void 0, _types.TokenType.parenR);
  flowParseTypeInitialiser();
}
function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}
function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && _index.match.call(void 0, _types.TokenType.braceBarL)) {
    _util.expect.call(void 0, _types.TokenType.braceBarL);
    endDelim = _types.TokenType.braceBarR;
  } else {
    _util.expect.call(void 0, _types.TokenType.braceL);
    endDelim = _types.TokenType.braceR;
  }
  while (!_index.match.call(void 0, endDelim) && !_base.state.error) {
    if (allowProto && _util.isContextual.call(void 0, _keywords.ContextualKeyword._proto)) {
      const lookahead = _index.lookaheadType.call(void 0);
      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        _index.next.call(void 0);
        allowStatic = false;
      }
    }
    if (allowStatic && _util.isContextual.call(void 0, _keywords.ContextualKeyword._static)) {
      const lookahead = _index.lookaheadType.call(void 0);
      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        _index.next.call(void 0);
      }
    }
    flowParseVariance();
    if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
      if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) {
        const lookahead = _index.lookaheadType.call(void 0);
        if (lookahead === _types.TokenType.name || lookahead === _types.TokenType.string || lookahead === _types.TokenType.num) {
          _index.next.call(void 0);
        }
      }
      flowParseObjectTypeProperty();
    }
    flowObjectTypeSemicolon();
  }
  _util.expect.call(void 0, endDelim);
}
function flowParseObjectTypeProperty() {
  if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
    _util.expect.call(void 0, _types.TokenType.ellipsis);
    if (!_index.eat.call(void 0, _types.TokenType.comma)) {
      _index.eat.call(void 0, _types.TokenType.semi);
    }
    // Explicit inexact object syntax.
    if (_index.match.call(void 0, _types.TokenType.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      _index.eat.call(void 0, _types.TokenType.question);
      flowParseTypeInitialiser();
    }
  }
}
function flowObjectTypeSemicolon() {
  if (!_index.eat.call(void 0, _types.TokenType.semi) && !_index.eat.call(void 0, _types.TokenType.comma) && !_index.match.call(void 0, _types.TokenType.braceR) && !_index.match.call(void 0, _types.TokenType.braceBarR)) {
    _util.unexpected.call(void 0);
  }
}
function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    _expression.parseIdentifier.call(void 0);
  }
  while (_index.eat.call(void 0, _types.TokenType.dot)) {
    _expression.parseIdentifier.call(void 0);
  }
}
function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}
function flowParseTypeofType() {
  _util.expect.call(void 0, _types.TokenType._typeof);
  flowParsePrimaryType();
}
function flowParseTupleType() {
  _util.expect.call(void 0, _types.TokenType.bracketL);
  // We allow trailing commas
  while (_base.state.pos < _base.input.length && !_index.match.call(void 0, _types.TokenType.bracketR)) {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.bracketR)) {
      break;
    }
    _util.expect.call(void 0, _types.TokenType.comma);
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
}
function flowParseFunctionTypeParam() {
  const lookahead = _index.lookaheadType.call(void 0);
  if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {
    _expression.parseIdentifier.call(void 0);
    _index.eat.call(void 0, _types.TokenType.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}
function flowParseFunctionTypeParams() {
  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();
    if (!_index.match.call(void 0, _types.TokenType.parenR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
  switch (_base.state.type) {
    case _types.TokenType.name:
      {
        if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
          flowParseInterfaceType();
          return;
        }
        _expression.parseIdentifier.call(void 0);
        flowParseGenericType();
        return;
      }
    case _types.TokenType.braceL:
      flowParseObjectType(false, false, false);
      return;
    case _types.TokenType.braceBarL:
      flowParseObjectType(false, true, false);
      return;
    case _types.TokenType.bracketL:
      flowParseTupleType();
      return;
    case _types.TokenType.lessThan:
      flowParseTypeParameterDeclaration();
      _util.expect.call(void 0, _types.TokenType.parenL);
      flowParseFunctionTypeParams();
      _util.expect.call(void 0, _types.TokenType.parenR);
      _util.expect.call(void 0, _types.TokenType.arrow);
      flowParseType();
      return;
    case _types.TokenType.parenL:
      _index.next.call(void 0);

      // Check to see if this is actually a grouped type
      if (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis)) {
        if (_index.match.call(void 0, _types.TokenType.name)) {
          const token = _index.lookaheadType.call(void 0);
          isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;
        } else {
          isGroupedType = true;
        }
      }
      if (isGroupedType) {
        _base.state.noAnonFunctionType = false;
        flowParseType();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (_base.state.noAnonFunctionType || !(_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.parenR) && _index.lookaheadType.call(void 0) === _types.TokenType.arrow)) {
          _util.expect.call(void 0, _types.TokenType.parenR);
          return;
        } else {
          // Eat a comma if there is one
          _index.eat.call(void 0, _types.TokenType.comma);
        }
      }
      flowParseFunctionTypeParams();
      _util.expect.call(void 0, _types.TokenType.parenR);
      _util.expect.call(void 0, _types.TokenType.arrow);
      flowParseType();
      return;
    case _types.TokenType.minus:
      _index.next.call(void 0);
      _expression.parseLiteral.call(void 0);
      return;
    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType._true:
    case _types.TokenType._false:
    case _types.TokenType._null:
    case _types.TokenType._this:
    case _types.TokenType._void:
    case _types.TokenType.star:
      _index.next.call(void 0);
      return;
    default:
      if (_base.state.type === _types.TokenType._typeof) {
        flowParseTypeofType();
        return;
      } else if (_base.state.type & _types.TokenType.IS_KEYWORD) {
        _index.next.call(void 0);
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
        return;
      }
  }
  _util.unexpected.call(void 0);
}
function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!_util.canInsertSemicolon.call(void 0) && (_index.match.call(void 0, _types.TokenType.bracketL) || _index.match.call(void 0, _types.TokenType.questionDot))) {
    _index.eat.call(void 0, _types.TokenType.questionDot);
    _util.expect.call(void 0, _types.TokenType.bracketL);
    if (_index.eat.call(void 0, _types.TokenType.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      _util.expect.call(void 0, _types.TokenType.bracketR);
    }
  }
}
function flowParsePrefixType() {
  if (_index.eat.call(void 0, _types.TokenType.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}
function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!_base.state.noAnonFunctionType && _index.eat.call(void 0, _types.TokenType.arrow)) {
    flowParseType();
  }
}
function flowParseIntersectionType() {
  _index.eat.call(void 0, _types.TokenType.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}
function flowParseUnionType() {
  _index.eat.call(void 0, _types.TokenType.bitwiseOR);
  flowParseIntersectionType();
  while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {
    flowParseIntersectionType();
  }
}
function flowParseType() {
  flowParseUnionType();
}
function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}
exports.flowParseTypeAnnotation = flowParseTypeAnnotation;
function flowParseTypeAnnotatableIdentifier() {
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}
function flowParseVariance() {
  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
    _index.next.call(void 0);
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
  }
}
exports.flowParseVariance = flowParseVariance;

// ==================================
// Overrides
// ==================================

function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }
  _expression.parseFunctionBody.call(void 0, false, funcContextId);
}
exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;
function flowParseSubscript(startTokenIndex, noCalls, stopState) {
  if (_index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0) === _types.TokenType.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }
    _index.next.call(void 0);
    flowParseTypeParameterInstantiation();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0);
    return;
  } else if (!noCalls && _index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    flowParseTypeParameterInstantiation();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0);
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }
  _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
}
exports.flowParseSubscript = flowParseSubscript;
function flowStartParseNewArguments() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    flowParseTypeParameterInstantiation();
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
}
exports.flowStartParseNewArguments = flowStartParseNewArguments;

// interfaces
function flowTryParseStatement() {
  if (_index.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._interface) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    _index.next.call(void 0);
    flowParseInterface();
    _index.popTypeContext.call(void 0, oldIsType);
    return true;
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}
exports.flowTryParseStatement = flowTryParseStatement;
function flowTryParseExportDefaultExpression() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}
exports.flowTryParseExportDefaultExpression = flowTryParseExportDefaultExpression;

// declares, interfaces and type aliases
function flowParseIdentifierStatement(contextualKeyword) {
  if (contextualKeyword === _keywords.ContextualKeyword._declare) {
    if (_index.match.call(void 0, _types.TokenType._class) || _index.match.call(void 0, _types.TokenType.name) || _index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._var) || _index.match.call(void 0, _types.TokenType._export)) {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      flowParseDeclare();
      _index.popTypeContext.call(void 0, oldIsType);
    }
  } else if (_index.match.call(void 0, _types.TokenType.name)) {
    if (contextualKeyword === _keywords.ContextualKeyword._interface) {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      flowParseInterface();
      _index.popTypeContext.call(void 0, oldIsType);
    } else if (contextualKeyword === _keywords.ContextualKeyword._type) {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      flowParseTypeAlias();
      _index.popTypeContext.call(void 0, oldIsType);
    } else if (contextualKeyword === _keywords.ContextualKeyword._opaque) {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      flowParseOpaqueType(false);
      _index.popTypeContext.call(void 0, oldIsType);
    }
  }
  _util.semicolon.call(void 0);
}
exports.flowParseIdentifierStatement = flowParseIdentifierStatement;

// export type
function flowShouldParseExportDeclaration() {
  return _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._enum);
}
exports.flowShouldParseExportDeclaration = flowShouldParseExportDeclaration;
function flowShouldDisallowExportDefaultSpecifier() {
  return _index.match.call(void 0, _types.TokenType.name) && (_base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.contextualKeyword === _keywords.ContextualKeyword._interface || _base.state.contextualKeyword === _keywords.ContextualKeyword._opaque || _base.state.contextualKeyword === _keywords.ContextualKeyword._enum);
}
exports.flowShouldDisallowExportDefaultSpecifier = flowShouldDisallowExportDefaultSpecifier;
function flowParseExportDeclaration() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    _index.next.call(void 0);
    if (_index.match.call(void 0, _types.TokenType.braceL)) {
      // export type { foo, bar };
      _statement.parseExportSpecifiers.call(void 0);
      _statement.parseExportFrom.call(void 0);
    } else {
      // export type Foo = Bar;
      flowParseTypeAlias();
    }
    _index.popTypeContext.call(void 0, oldIsType);
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    _index.next.call(void 0);
    // export opaque type Foo = Bar;
    flowParseOpaqueType(false);
    _index.popTypeContext.call(void 0, oldIsType);
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    _index.next.call(void 0);
    flowParseInterface();
    _index.popTypeContext.call(void 0, oldIsType);
  } else {
    _statement.parseStatement.call(void 0, true);
  }
}
exports.flowParseExportDeclaration = flowParseExportDeclaration;
function flowShouldParseExportStar() {
  return _index.match.call(void 0, _types.TokenType.star) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) && _index.lookaheadType.call(void 0) === _types.TokenType.star;
}
exports.flowShouldParseExportStar = flowShouldParseExportStar;
function flowParseExportStar() {
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 2);
    _statement.baseParseExportStar.call(void 0);
    _index.popTypeContext.call(void 0, oldIsType);
  } else {
    _statement.baseParseExportStar.call(void 0);
  }
}
exports.flowParseExportStar = flowParseExportStar;

// parse a the super class type parameters and implements
function flowAfterParseClassSuper(hasSuper) {
  if (hasSuper && _index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    _index.next.call(void 0);
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
    do {
      flowParseRestrictedIdentifier();
      if (_index.match.call(void 0, _types.TokenType.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
    } while (_index.eat.call(void 0, _types.TokenType.comma));
    _index.popTypeContext.call(void 0, oldIsType);
  }
}
exports.flowAfterParseClassSuper = flowAfterParseClassSuper;

// parse type parameters for object method shorthand
function flowStartParseObjPropValue() {
  // method shorthand
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
    if (!_index.match.call(void 0, _types.TokenType.parenL)) _util.unexpected.call(void 0);
  }
}
exports.flowStartParseObjPropValue = flowStartParseObjPropValue;
function flowParseAssignableListItemTypes() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _index.eat.call(void 0, _types.TokenType.question);
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
  _index.popTypeContext.call(void 0, oldIsType);
}
exports.flowParseAssignableListItemTypes = flowParseAssignableListItemTypes;

// parse typeof and type imports
function flowStartParseImportSpecifiers() {
  if (_index.match.call(void 0, _types.TokenType._typeof) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    const lh = _index.lookaheadTypeAndKeyword.call(void 0);
    if (isMaybeDefaultImport(lh) || lh.type === _types.TokenType.braceL || lh.type === _types.TokenType.star) {
      _index.next.call(void 0);
    }
  }
}
exports.flowStartParseImportSpecifiers = flowStartParseImportSpecifiers;

// parse import-type/typeof shorthand
function flowParseImportSpecifier() {
  const isTypeKeyword = _base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.type === _types.TokenType._typeof;
  if (isTypeKeyword) {
    _index.next.call(void 0);
  } else {
    _expression.parseIdentifier.call(void 0);
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as) && !_util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    _expression.parseIdentifier.call(void 0);
    if (isTypeKeyword && !_index.match.call(void 0, _types.TokenType.name) && !(_base.state.type & _types.TokenType.IS_KEYWORD)) {
      // `import {type as ,` or `import {type as }`
    } else {
      // `import {type as foo`
      _expression.parseIdentifier.call(void 0);
    }
  } else {
    if (isTypeKeyword && (_index.match.call(void 0, _types.TokenType.name) || !!(_base.state.type & _types.TokenType.IS_KEYWORD))) {
      // `import {type foo`
      _expression.parseIdentifier.call(void 0);
    }
    if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
      _expression.parseIdentifier.call(void 0);
    }
  }
}
exports.flowParseImportSpecifier = flowParseImportSpecifier;

// parse function type parameters - function foo<T>() {}
function flowStartParseFunctionParams() {
  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
  // anyway, so don't try to propagate that information.
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    flowParseTypeParameterDeclaration();
    _index.popTypeContext.call(void 0, oldIsType);
  }
}
exports.flowStartParseFunctionParams = flowStartParseFunctionParams;

// parse flow type annotations on variable declarator heads - let foo: string = bar
function flowAfterParseVarHead() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}
exports.flowAfterParseVarHead = flowAfterParseVarHead;

// parse the return type of an async arrow function - let foo = (async (): number => {});
function flowStartParseAsyncArrowFromCallExpression() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;
  }
}
exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;

// We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method
function flowParseMaybeAssign(noIn, isWithinParens) {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
      _base.state.type = _types.TokenType.typeParameterStart;
    } else {
      return wasArrow;
    }
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    flowParseTypeParameterDeclaration();
    _index.popTypeContext.call(void 0, oldIsType);
    wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    if (wasArrow) {
      return true;
    }
    _util.unexpected.call(void 0);
  }
  return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
}
exports.flowParseMaybeAssign = flowParseMaybeAssign;

// handle return types for arrow functions
function flowParseArrow() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    const snapshot = _base.state.snapshot();
    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAndPredicateInitialiser();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;
    if (_util.canInsertSemicolon.call(void 0)) _util.unexpected.call(void 0);
    if (!_index.match.call(void 0, _types.TokenType.arrow)) _util.unexpected.call(void 0);
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
    _index.popTypeContext.call(void 0, oldIsType);
  }
  return _index.eat.call(void 0, _types.TokenType.arrow);
}
exports.flowParseArrow = flowParseArrow;
function flowParseSubscripts(startTokenIndex, noCalls = false) {
  if (_base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async && _index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    const wasArrow = parseAsyncArrowWithTypeParameters();
    if (wasArrow && !_base.state.error) {
      return;
    }
    _base.state.restoreFromSnapshot(snapshot);
  }
  _expression.baseParseSubscripts.call(void 0, startTokenIndex, noCalls);
}
exports.flowParseSubscripts = flowParseSubscripts;

// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters() {
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  _statement.parseFunctionParams.call(void 0);
  if (!_expression.parseArrow.call(void 0)) {
    return false;
  }
  _expression.parseArrowExpression.call(void 0, startTokenIndex);
  return true;
}
function flowParseEnumDeclaration() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
  _expression.parseIdentifier.call(void 0);
  flowParseEnumBody();
}
function flowParseEnumBody() {
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._of)) {
    _index.next.call(void 0);
  }
  _util.expect.call(void 0, _types.TokenType.braceL);
  flowParseEnumMembers();
  _util.expect.call(void 0, _types.TokenType.braceR);
}
function flowParseEnumMembers() {
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
      break;
    }
    flowParseEnumMember();
    if (!_index.match.call(void 0, _types.TokenType.braceR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
}
function flowParseEnumMember() {
  _expression.parseIdentifier.call(void 0);
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    // Flow enum values are always just one token (a string, number, or boolean literal).
    _index.next.call(void 0);
  }
}
}),
/* --- node_modules/sucrase/dist/parser/plugins/typescript.js --- */
"node_modules/sucrase/dist/parser/plugins/typescript.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _index = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _expression = _kame_require_("node_modules/sucrase/dist/parser/traverser/expression.js");
var _lval = _kame_require_("node_modules/sucrase/dist/parser/traverser/lval.js");
var _statement = _kame_require_("node_modules/sucrase/dist/parser/traverser/statement.js");
var _util = _kame_require_("node_modules/sucrase/dist/parser/traverser/util.js");
var _jsx = _kame_require_("node_modules/sucrase/dist/parser/plugins/jsx/index.js");
function tsIsIdentifier() {
  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
  // See https://github.com/Microsoft/TypeScript/issues/15008
  return _index.match.call(void 0, _types.TokenType.name);
}
function isLiteralPropertyName() {
  return _index.match.call(void 0, _types.TokenType.name) || Boolean(_base.state.type & _types.TokenType.IS_KEYWORD) || _index.match.call(void 0, _types.TokenType.string) || _index.match.call(void 0, _types.TokenType.num) || _index.match.call(void 0, _types.TokenType.bigint) || _index.match.call(void 0, _types.TokenType.decimal);
}
function tsNextTokenCanFollowModifier() {
  // Note: TypeScript's implementation is much more complicated because
  // more things are considered modifiers there.
  // This implementation only handles modifiers not handled by babylon itself. And "static".
  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
  const snapshot = _base.state.snapshot();
  _index.next.call(void 0);
  const canFollowModifier = (_index.match.call(void 0, _types.TokenType.bracketL) || _index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.star) || _index.match.call(void 0, _types.TokenType.ellipsis) || _index.match.call(void 0, _types.TokenType.hash) || isLiteralPropertyName()) && !_util.hasPrecedingLineBreak.call(void 0);
  if (canFollowModifier) {
    return true;
  } else {
    _base.state.restoreFromSnapshot(snapshot);
    return false;
  }
}
function tsParseModifiers(allowedModifiers) {
  while (true) {
    const modifier = tsParseModifier(allowedModifiers);
    if (modifier === null) {
      break;
    }
  }
}
exports.tsParseModifiers = tsParseModifiers;

/** Parses a modifier matching one the given modifier names. */
function tsParseModifier(allowedModifiers) {
  if (!_index.match.call(void 0, _types.TokenType.name)) {
    return null;
  }
  const modifier = _base.state.contextualKeyword;
  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {
    switch (modifier) {
      case _keywords.ContextualKeyword._readonly:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._readonly;
        break;
      case _keywords.ContextualKeyword._abstract:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
        break;
      case _keywords.ContextualKeyword._static:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
        break;
      case _keywords.ContextualKeyword._public:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._public;
        break;
      case _keywords.ContextualKeyword._private:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._private;
        break;
      case _keywords.ContextualKeyword._protected:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._protected;
        break;
      case _keywords.ContextualKeyword._override:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._override;
        break;
      case _keywords.ContextualKeyword._declare:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
        break;
      default:
        break;
    }
    return modifier;
  }
  return null;
}
exports.tsParseModifier = tsParseModifier;
function tsParseEntityName() {
  _expression.parseIdentifier.call(void 0);
  while (_index.eat.call(void 0, _types.TokenType.dot)) {
    _expression.parseIdentifier.call(void 0);
  }
}
function tsParseTypeReference() {
  tsParseEntityName();
  if (!_util.hasPrecedingLineBreak.call(void 0) && _index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseThisTypePredicate() {
  _index.next.call(void 0);
  tsParseTypeAnnotation();
}
function tsParseThisTypeNode() {
  _index.next.call(void 0);
}
function tsParseTypeQuery() {
  _util.expect.call(void 0, _types.TokenType._typeof);
  if (_index.match.call(void 0, _types.TokenType._import)) {
    tsParseImportType();
  } else {
    tsParseEntityName();
  }
  if (!_util.hasPrecedingLineBreak.call(void 0) && _index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseImportType() {
  _util.expect.call(void 0, _types.TokenType._import);
  _util.expect.call(void 0, _types.TokenType.parenL);
  _util.expect.call(void 0, _types.TokenType.string);
  _util.expect.call(void 0, _types.TokenType.parenR);
  if (_index.eat.call(void 0, _types.TokenType.dot)) {
    tsParseEntityName();
  }
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseTypeParameter() {
  const hadIn = _index.eat.call(void 0, _types.TokenType._in);
  const hadOut = _util.eatContextual.call(void 0, _keywords.ContextualKeyword._out);
  if ((hadIn || hadOut) && !_index.match.call(void 0, _types.TokenType.name)) {
    // The "in" or "out" keyword must have actually been the type parameter
    // name, so set it as the name.
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
  } else {
    _expression.parseIdentifier.call(void 0);
  }
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    tsParseType();
  }
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    tsParseType();
  }
}
function tsTryParseTypeParameters() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeParameters();
  }
}
exports.tsTryParseTypeParameters = tsTryParseTypeParameters;
function tsParseTypeParameters() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {
    _index.next.call(void 0);
  } else {
    _util.unexpected.call(void 0);
  }
  while (!_index.eat.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
    tsParseTypeParameter();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
  _index.popTypeContext.call(void 0, oldIsType);
}

// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
// but here it's always false, because this is only used for types.
function tsFillSignature(returnToken) {
  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
  const returnTokenRequired = returnToken === _types.TokenType.arrow;
  tsTryParseTypeParameters();
  _util.expect.call(void 0, _types.TokenType.parenL);
  // Create a scope even though we're doing type parsing so we don't accidentally
  // treat params as top-level bindings.
  _base.state.scopeDepth++;
  tsParseBindingListForSignature(false /* isBlockScope */);
  _base.state.scopeDepth--;
  if (returnTokenRequired) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  } else if (_index.match.call(void 0, returnToken)) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  }
}
function tsParseBindingListForSignature(isBlockScope) {
  _lval.parseBindingList.call(void 0, _types.TokenType.parenR, isBlockScope);
}
function tsParseTypeMemberSemicolon() {
  if (!_index.eat.call(void 0, _types.TokenType.comma)) {
    _util.semicolon.call(void 0);
  }
}
function tsParseSignatureMember() {
  tsFillSignature(_types.TokenType.colon);
  tsParseTypeMemberSemicolon();
}
function tsIsUnambiguouslyIndexSignature() {
  const snapshot = _base.state.snapshot();
  _index.next.call(void 0); // Skip '{'
  const isIndexSignature = _index.eat.call(void 0, _types.TokenType.name) && _index.match.call(void 0, _types.TokenType.colon);
  _base.state.restoreFromSnapshot(snapshot);
  return isIndexSignature;
}
function tsTryParseIndexSignature() {
  if (!(_index.match.call(void 0, _types.TokenType.bracketL) && tsIsUnambiguouslyIndexSignature())) {
    return false;
  }
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.bracketL);
  _expression.parseIdentifier.call(void 0);
  tsParseTypeAnnotation();
  _util.expect.call(void 0, _types.TokenType.bracketR);
  tsTryParseTypeAnnotation();
  tsParseTypeMemberSemicolon();
  _index.popTypeContext.call(void 0, oldIsType);
  return true;
}
function tsParsePropertyOrMethodSignature(isReadonly) {
  _index.eat.call(void 0, _types.TokenType.question);
  if (!isReadonly && (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan))) {
    tsFillSignature(_types.TokenType.colon);
    tsParseTypeMemberSemicolon();
  } else {
    tsTryParseTypeAnnotation();
    tsParseTypeMemberSemicolon();
  }
}
function tsParseTypeMember() {
  if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
    // call signature
    tsParseSignatureMember();
    return;
  }
  if (_index.match.call(void 0, _types.TokenType._new)) {
    _index.next.call(void 0);
    if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
      // constructor signature
      tsParseSignatureMember();
    } else {
      tsParsePropertyOrMethodSignature(false);
    }
    return;
  }
  const readonly = !!tsParseModifier([_keywords.ContextualKeyword._readonly]);
  const found = tsTryParseIndexSignature();
  if (found) {
    return;
  }
  if ((_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) && tsNextTokenCanFollowModifier()) {
    // This is a getter/setter on a type. The tsNextTokenCanFollowModifier
    // function already called next() for us, so continue parsing the name.
  }
  _expression.parsePropertyName.call(void 0, -1 /* Types don't need context IDs. */);
  tsParsePropertyOrMethodSignature(readonly);
}
function tsParseTypeLiteral() {
  tsParseObjectTypeMembers();
}
function tsParseObjectTypeMembers() {
  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    tsParseTypeMember();
  }
}
function tsLookaheadIsStartOfMappedType() {
  const snapshot = _base.state.snapshot();
  const isStartOfMappedType = tsIsStartOfMappedType();
  _base.state.restoreFromSnapshot(snapshot);
  return isStartOfMappedType;
}
function tsIsStartOfMappedType() {
  _index.next.call(void 0);
  if (_index.eat.call(void 0, _types.TokenType.plus) || _index.eat.call(void 0, _types.TokenType.minus)) {
    return _util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly);
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly)) {
    _index.next.call(void 0);
  }
  if (!_index.match.call(void 0, _types.TokenType.bracketL)) {
    return false;
  }
  _index.next.call(void 0);
  if (!tsIsIdentifier()) {
    return false;
  }
  _index.next.call(void 0);
  return _index.match.call(void 0, _types.TokenType._in);
}
function tsParseMappedTypeParameter() {
  _expression.parseIdentifier.call(void 0);
  _util.expect.call(void 0, _types.TokenType._in);
  tsParseType();
}
function tsParseMappedType() {
  _util.expect.call(void 0, _types.TokenType.braceL);
  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
    _index.next.call(void 0);
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._readonly);
  } else {
    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._readonly);
  }
  _util.expect.call(void 0, _types.TokenType.bracketL);
  tsParseMappedTypeParameter();
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    tsParseType();
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
    _index.next.call(void 0);
    _util.expect.call(void 0, _types.TokenType.question);
  } else {
    _index.eat.call(void 0, _types.TokenType.question);
  }
  tsTryParseType();
  _util.semicolon.call(void 0);
  _util.expect.call(void 0, _types.TokenType.braceR);
}
function tsParseTupleType() {
  _util.expect.call(void 0, _types.TokenType.bracketL);
  while (!_index.eat.call(void 0, _types.TokenType.bracketR) && !_base.state.error) {
    // Do not validate presence of either none or only labeled elements
    tsParseTupleElementType();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
}
function tsParseTupleElementType() {
  // parses `...TsType[]`
  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    tsParseType();
  } else {
    // parses `TsType?`
    tsParseType();
    _index.eat.call(void 0, _types.TokenType.question);
  }

  // The type we parsed above was actually a label
  if (_index.eat.call(void 0, _types.TokenType.colon)) {
    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here
    tsParseType();
  }
}
function tsParseParenthesizedType() {
  _util.expect.call(void 0, _types.TokenType.parenL);
  tsParseType();
  _util.expect.call(void 0, _types.TokenType.parenR);
}
function tsParseTemplateLiteralType() {
  // Finish `, read quasi
  _index.nextTemplateToken.call(void 0);
  // Finish quasi, read ${
  _index.nextTemplateToken.call(void 0);
  while (!_index.match.call(void 0, _types.TokenType.backQuote) && !_base.state.error) {
    _util.expect.call(void 0, _types.TokenType.dollarBraceL);
    tsParseType();
    // Finish }, read quasi
    _index.nextTemplateToken.call(void 0);
    // Finish quasi, read either ${ or `
    _index.nextTemplateToken.call(void 0);
  }
  _index.next.call(void 0);
}
var FunctionType;
(function (FunctionType) {
  const TSFunctionType = 0;
  FunctionType[FunctionType["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
  const TSConstructorType = TSFunctionType + 1;
  FunctionType[FunctionType["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
  const TSAbstractConstructorType = TSConstructorType + 1;
  FunctionType[FunctionType["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
})(FunctionType || (FunctionType = {}));
function tsParseFunctionOrConstructorType(type) {
  if (type === FunctionType.TSAbstractConstructorType) {
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._abstract);
  }
  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {
    _util.expect.call(void 0, _types.TokenType._new);
  }
  const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
  _base.state.inDisallowConditionalTypesContext = false;
  tsFillSignature(_types.TokenType.arrow);
  _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
}
function tsParseNonArrayType() {
  switch (_base.state.type) {
    case _types.TokenType.name:
      tsParseTypeReference();
      return;
    case _types.TokenType._void:
    case _types.TokenType._null:
      _index.next.call(void 0);
      return;
    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType.bigint:
    case _types.TokenType.decimal:
    case _types.TokenType._true:
    case _types.TokenType._false:
      _expression.parseLiteral.call(void 0);
      return;
    case _types.TokenType.minus:
      _index.next.call(void 0);
      _expression.parseLiteral.call(void 0);
      return;
    case _types.TokenType._this:
      {
        tsParseThisTypeNode();
        if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._is) && !_util.hasPrecedingLineBreak.call(void 0)) {
          tsParseThisTypePredicate();
        }
        return;
      }
    case _types.TokenType._typeof:
      tsParseTypeQuery();
      return;
    case _types.TokenType._import:
      tsParseImportType();
      return;
    case _types.TokenType.braceL:
      if (tsLookaheadIsStartOfMappedType()) {
        tsParseMappedType();
      } else {
        tsParseTypeLiteral();
      }
      return;
    case _types.TokenType.bracketL:
      tsParseTupleType();
      return;
    case _types.TokenType.parenL:
      tsParseParenthesizedType();
      return;
    case _types.TokenType.backQuote:
      tsParseTemplateLiteralType();
      return;
    default:
      if (_base.state.type & _types.TokenType.IS_KEYWORD) {
        _index.next.call(void 0);
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
        return;
      }
      break;
  }
  _util.unexpected.call(void 0);
}
function tsParseArrayTypeOrHigher() {
  tsParseNonArrayType();
  while (!_util.hasPrecedingLineBreak.call(void 0) && _index.eat.call(void 0, _types.TokenType.bracketL)) {
    if (!_index.eat.call(void 0, _types.TokenType.bracketR)) {
      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.
      tsParseType();
      _util.expect.call(void 0, _types.TokenType.bracketR);
    }
  }
}
function tsParseInferType() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._infer);
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType._extends)) {
    // Infer type constraints introduce an ambiguity about whether the "extends"
    // is a constraint for this infer type or is another conditional type.
    const snapshot = _base.state.snapshot();
    _util.expect.call(void 0, _types.TokenType._extends);
    const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
    _base.state.inDisallowConditionalTypesContext = true;
    tsParseType();
    _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    if (_base.state.error || !_base.state.inDisallowConditionalTypesContext && _index.match.call(void 0, _types.TokenType.question)) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
}
function tsParseTypeOperatorOrHigher() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._keyof) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._unique) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly)) {
    _index.next.call(void 0);
    tsParseTypeOperatorOrHigher();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._infer)) {
    tsParseInferType();
  } else {
    const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
    _base.state.inDisallowConditionalTypesContext = false;
    tsParseArrayTypeOrHigher();
    _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  }
}
function tsParseIntersectionTypeOrHigher() {
  _index.eat.call(void 0, _types.TokenType.bitwiseAND);
  tsParseTypeOperatorOrHigher();
  if (_index.match.call(void 0, _types.TokenType.bitwiseAND)) {
    while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {
      tsParseTypeOperatorOrHigher();
    }
  }
}
function tsParseUnionTypeOrHigher() {
  _index.eat.call(void 0, _types.TokenType.bitwiseOR);
  tsParseIntersectionTypeOrHigher();
  if (_index.match.call(void 0, _types.TokenType.bitwiseOR)) {
    while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {
      tsParseIntersectionTypeOrHigher();
    }
  }
}
function tsIsStartOfFunctionType() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    return true;
  }
  return _index.match.call(void 0, _types.TokenType.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();
}
function tsSkipParameterStart() {
  if (_index.match.call(void 0, _types.TokenType.name) || _index.match.call(void 0, _types.TokenType._this)) {
    _index.next.call(void 0);
    return true;
  }
  // If this is a possible array/object destructure, walk to the matching bracket/brace.
  // The next token after will tell us definitively whether this is a function param.
  if (_index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.bracketL)) {
    let depth = 1;
    _index.next.call(void 0);
    while (depth > 0 && !_base.state.error) {
      if (_index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.bracketL)) {
        depth++;
      } else if (_index.match.call(void 0, _types.TokenType.braceR) || _index.match.call(void 0, _types.TokenType.bracketR)) {
        depth--;
      }
      _index.next.call(void 0);
    }
    return true;
  }
  return false;
}
function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
  const snapshot = _base.state.snapshot();
  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();
  _base.state.restoreFromSnapshot(snapshot);
  return isUnambiguouslyStartOfFunctionType;
}
function tsIsUnambiguouslyStartOfFunctionType() {
  _index.next.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.parenR) || _index.match.call(void 0, _types.TokenType.ellipsis)) {
    // ( )
    // ( ...
    return true;
  }
  if (tsSkipParameterStart()) {
    if (_index.match.call(void 0, _types.TokenType.colon) || _index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.question) || _index.match.call(void 0, _types.TokenType.eq)) {
      // ( xxx :
      // ( xxx ,
      // ( xxx ?
      // ( xxx =
      return true;
    }
    if (_index.match.call(void 0, _types.TokenType.parenR)) {
      _index.next.call(void 0);
      if (_index.match.call(void 0, _types.TokenType.arrow)) {
        // ( xxx ) =>
        return true;
      }
    }
  }
  return false;
}
function tsParseTypeOrTypePredicateAnnotation(returnToken) {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, returnToken);
  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();
  if (!finishedReturn) {
    tsParseType();
  }
  _index.popTypeContext.call(void 0, oldIsType);
}
function tsTryParseTypeOrTypePredicateAnnotation() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
  }
}
function tsTryParseTypeAnnotation() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    tsParseTypeAnnotation();
  }
}
exports.tsTryParseTypeAnnotation = tsTryParseTypeAnnotation;
function tsTryParseType() {
  if (_index.eat.call(void 0, _types.TokenType.colon)) {
    tsParseType();
  }
}

/**
 * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,
 * `asserts this is T`.
 *
 * Returns true if we parsed the return type, false if there's still a type to be parsed.
 */
function tsParseTypePredicateOrAssertsPrefix() {
  const snapshot = _base.state.snapshot();
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._asserts)) {
    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-
    // defined type guard on the `asserts` variable) or just a type called `asserts`.
    _index.next.call(void 0);
    if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._is)) {
      // If we see `asserts is`, then this must be of the form `asserts is T`, since
      // `asserts is is T` isn't valid.
      tsParseType();
      return true;
    } else if (tsIsIdentifier() || _index.match.call(void 0, _types.TokenType._this)) {
      _index.next.call(void 0);
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._is)) {
        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.
        tsParseType();
      }
      return true;
    } else {
      // Regular type, so bail out and start type parsing from scratch.
      _base.state.restoreFromSnapshot(snapshot);
      return false;
    }
  } else if (tsIsIdentifier() || _index.match.call(void 0, _types.TokenType._this)) {
    // This is a regular identifier, which may or may not have "is" after it.
    _index.next.call(void 0);
    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._is) && !_util.hasPrecedingLineBreak.call(void 0)) {
      _index.next.call(void 0);
      tsParseType();
      return true;
    } else {
      // Regular type, so bail out and start type parsing from scratch.
      _base.state.restoreFromSnapshot(snapshot);
      return false;
    }
  }
  return false;
}
function tsParseTypeAnnotation() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.colon);
  tsParseType();
  _index.popTypeContext.call(void 0, oldIsType);
}
exports.tsParseTypeAnnotation = tsParseTypeAnnotation;
function tsParseType() {
  tsParseNonConditionalType();
  if (_base.state.inDisallowConditionalTypesContext || _util.hasPrecedingLineBreak.call(void 0) || !_index.eat.call(void 0, _types.TokenType._extends)) {
    return;
  }
  // extends type
  const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
  _base.state.inDisallowConditionalTypesContext = true;
  tsParseNonConditionalType();
  _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  _util.expect.call(void 0, _types.TokenType.question);
  // true type
  tsParseType();
  _util.expect.call(void 0, _types.TokenType.colon);
  // false type
  tsParseType();
}
exports.tsParseType = tsParseType;
function isAbstractConstructorSignature() {
  return _util.isContextual.call(void 0, _keywords.ContextualKeyword._abstract) && _index.lookaheadType.call(void 0) === _types.TokenType._new;
}
function tsParseNonConditionalType() {
  if (tsIsStartOfFunctionType()) {
    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
    return;
  }
  if (_index.match.call(void 0, _types.TokenType._new)) {
    // As in `new () => Date`
    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
    return;
  } else if (isAbstractConstructorSignature()) {
    // As in `abstract new () => Date`
    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);
    return;
  }
  tsParseUnionTypeOrHigher();
}
exports.tsParseNonConditionalType = tsParseNonConditionalType;
function tsParseTypeAssertion() {
  const oldIsType = _index.pushTypeContext.call(void 0, 1);
  tsParseType();
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
  _expression.parseMaybeUnary.call(void 0);
}
exports.tsParseTypeAssertion = tsParseTypeAssertion;
function tsTryParseJSXTypeArgument() {
  if (_index.eat.call(void 0, _types.TokenType.jsxTagStart)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.typeParameterStart;
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
      tsParseType();
      _index.eat.call(void 0, _types.TokenType.comma);
    }
    // Process >, but the one after needs to be parsed JSX-style.
    _jsx.nextJSXTagToken.call(void 0);
    _index.popTypeContext.call(void 0, oldIsType);
  }
}
exports.tsTryParseJSXTypeArgument = tsTryParseJSXTypeArgument;
function tsParseHeritageClause() {
  while (!_index.match.call(void 0, _types.TokenType.braceL) && !_base.state.error) {
    tsParseExpressionWithTypeArguments();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
}
function tsParseExpressionWithTypeArguments() {
  // Note: TS uses parseLeftHandSideExpressionOrHigher,
  // then has grammar errors later if it's not an EntityName.
  tsParseEntityName();
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseInterfaceDeclaration() {
  _lval.parseBindingIdentifier.call(void 0, false);
  tsTryParseTypeParameters();
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    tsParseHeritageClause();
  }
  tsParseObjectTypeMembers();
}
function tsParseTypeAliasDeclaration() {
  _lval.parseBindingIdentifier.call(void 0, false);
  tsTryParseTypeParameters();
  _util.expect.call(void 0, _types.TokenType.eq);
  tsParseType();
  _util.semicolon.call(void 0);
}
function tsParseEnumMember() {
  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
  if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseLiteral.call(void 0);
  } else {
    _expression.parseIdentifier.call(void 0);
  }
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    const eqIndex = _base.state.tokens.length - 1;
    _expression.parseMaybeAssign.call(void 0);
    _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
  }
}
function tsParseEnumDeclaration() {
  _lval.parseBindingIdentifier.call(void 0, false);
  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    tsParseEnumMember();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
}
function tsParseModuleBlock() {
  _util.expect.call(void 0, _types.TokenType.braceL);
  _statement.parseBlockBody.call(void 0, /* end */_types.TokenType.braceR);
}
function tsParseModuleOrNamespaceDeclaration() {
  _lval.parseBindingIdentifier.call(void 0, false);
  if (_index.eat.call(void 0, _types.TokenType.dot)) {
    tsParseModuleOrNamespaceDeclaration();
  } else {
    tsParseModuleBlock();
  }
}
function tsParseAmbientExternalModuleDeclaration() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._global)) {
    _expression.parseIdentifier.call(void 0);
  } else if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0);
  } else {
    _util.unexpected.call(void 0);
  }
  if (_index.match.call(void 0, _types.TokenType.braceL)) {
    tsParseModuleBlock();
  } else {
    _util.semicolon.call(void 0);
  }
}
function tsParseImportEqualsDeclaration() {
  _lval.parseImportedIdentifier.call(void 0);
  _util.expect.call(void 0, _types.TokenType.eq);
  tsParseModuleReference();
  _util.semicolon.call(void 0);
}
exports.tsParseImportEqualsDeclaration = tsParseImportEqualsDeclaration;
function tsIsExternalModuleReference() {
  return _util.isContextual.call(void 0, _keywords.ContextualKeyword._require) && _index.lookaheadType.call(void 0) === _types.TokenType.parenL;
}
function tsParseModuleReference() {
  if (tsIsExternalModuleReference()) {
    tsParseExternalModuleReference();
  } else {
    tsParseEntityName();
  }
}
function tsParseExternalModuleReference() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._require);
  _util.expect.call(void 0, _types.TokenType.parenL);
  if (!_index.match.call(void 0, _types.TokenType.string)) {
    _util.unexpected.call(void 0);
  }
  _expression.parseLiteral.call(void 0);
  _util.expect.call(void 0, _types.TokenType.parenR);
}

// Utilities

// Returns true if a statement matched.
function tsTryParseDeclare() {
  if (_util.isLineTerminator.call(void 0)) {
    return false;
  }
  switch (_base.state.type) {
    case _types.TokenType._function:
      {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        _index.next.call(void 0);
        // We don't need to precisely get the function start here, since it's only used to mark
        // the function as a type if it's bodiless, and it's already a type here.
        const functionStart = _base.state.start;
        _statement.parseFunction.call(void 0, functionStart, /* isStatement */true);
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
    case _types.TokenType._class:
      {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        _statement.parseClass.call(void 0, /* isStatement */true, /* optionalId */false);
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
    case _types.TokenType._const:
      {
        if (_index.match.call(void 0, _types.TokenType._const) && _util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
          const oldIsType = _index.pushTypeContext.call(void 0, 1);
          // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.
          _util.expect.call(void 0, _types.TokenType._const);
          _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
          _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
          tsParseEnumDeclaration();
          _index.popTypeContext.call(void 0, oldIsType);
          return true;
        }
      }
    // falls through
    case _types.TokenType._var:
    case _types.TokenType._let:
      {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        _statement.parseVarStatement.call(void 0, _base.state.type);
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
    case _types.TokenType.name:
      {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        const contextualKeyword = _base.state.contextualKeyword;
        let matched = false;
        if (contextualKeyword === _keywords.ContextualKeyword._global) {
          tsParseAmbientExternalModuleDeclaration();
          matched = true;
        } else {
          matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */true);
        }
        _index.popTypeContext.call(void 0, oldIsType);
        return matched;
      }
    default:
      return false;
  }
}

// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
// Returns true if it matched a declaration.
function tsTryParseExportDeclaration() {
  return tsParseDeclaration(_base.state.contextualKeyword, /* isBeforeToken */true);
}

// Returns true if it matched a statement.
function tsParseExpressionStatement(contextualKeyword) {
  switch (contextualKeyword) {
    case _keywords.ContextualKeyword._declare:
      {
        const declareTokenIndex = _base.state.tokens.length - 1;
        const matched = tsTryParseDeclare();
        if (matched) {
          _base.state.tokens[declareTokenIndex].type = _types.TokenType._declare;
          return true;
        }
        break;
      }
    case _keywords.ContextualKeyword._global:
      // `global { }` (with no `declare`) may appear inside an ambient module declaration.
      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
      if (_index.match.call(void 0, _types.TokenType.braceL)) {
        tsParseModuleBlock();
        return true;
      }
      break;
    default:
      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */false);
  }
  return false;
}

/**
 * Common code for parsing a declaration.
 *
 * isBeforeToken indicates that the current parser state is at the contextual
 * keyword (and that it is not yet emitted) rather than reading the token after
 * it. When isBeforeToken is true, we may be preceded by an `export` token and
 * should include that token in a type context we create, e.g. to handle
 * `export interface` or `export type`. (This is a bit of a hack and should be
 * cleaned up at some point.)
 *
 * Returns true if it matched a declaration.
 */
function tsParseDeclaration(contextualKeyword, isBeforeToken) {
  switch (contextualKeyword) {
    case _keywords.ContextualKeyword._abstract:
      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType._class)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
        _statement.parseClass.call(void 0, /* isStatement */true, /* optionalId */false);
        return true;
      }
      break;
    case _keywords.ContextualKeyword._enum:
      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
        tsParseEnumDeclaration();
        return true;
      }
      break;
    case _keywords.ContextualKeyword._interface:
      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {
        // `next` is true in "export" and "declare" contexts, so we want to remove that token
        // as well.
        const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
        tsParseInterfaceDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
      break;
    case _keywords.ContextualKeyword._module:
      if (tsCheckLineTerminator(isBeforeToken)) {
        if (_index.match.call(void 0, _types.TokenType.string)) {
          const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
          tsParseAmbientExternalModuleDeclaration();
          _index.popTypeContext.call(void 0, oldIsType);
          return true;
        } else if (_index.match.call(void 0, _types.TokenType.name)) {
          const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
          tsParseModuleOrNamespaceDeclaration();
          _index.popTypeContext.call(void 0, oldIsType);
          return true;
        }
      }
      break;
    case _keywords.ContextualKeyword._namespace:
      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {
        const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
        tsParseModuleOrNamespaceDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
      break;
    case _keywords.ContextualKeyword._type:
      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {
        const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
        tsParseTypeAliasDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
      break;
    default:
      break;
  }
  return false;
}
function tsCheckLineTerminator(isBeforeToken) {
  if (isBeforeToken) {
    // Babel checks hasFollowingLineBreak here and returns false, but this
    // doesn't actually come up, e.g. `export interface` can never be on its own
    // line in valid code.
    _index.next.call(void 0);
    return true;
  } else {
    return !_util.isLineTerminator.call(void 0);
  }
}

// Returns true if there was a generic async arrow function.
function tsTryParseGenericAsyncArrowFunction() {
  const snapshot = _base.state.snapshot();
  tsParseTypeParameters();
  _statement.parseFunctionParams.call(void 0);
  tsTryParseTypeOrTypePredicateAnnotation();
  _util.expect.call(void 0, _types.TokenType.arrow);
  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);
    return false;
  }
  _expression.parseFunctionBody.call(void 0, true);
  return true;
}

/**
 * If necessary, hack the tokenizer state so that this bitshift was actually a
 * less-than token, then keep parsing. This should only be used in situations
 * where we restore from snapshot on error (which reverts this change) or
 * where bitshift would be illegal anyway (e.g. in a class "extends" clause).
 *
 * This hack is useful to handle situations like foo<<T>() => void>() where
 * there can legitimately be two open-angle-brackets in a row in TS. This
 * situation is very obscure and (as of this writing) is handled by Babel but
 * not TypeScript itself, so it may be fine in the future to remove this case.
 */
function tsParseTypeArgumentsWithPossibleBitshift() {
  if (_base.state.type === _types.TokenType.bitShiftL) {
    _base.state.pos -= 1;
    _index.finishToken.call(void 0, _types.TokenType.lessThan);
  }
  tsParseTypeArguments();
}
function tsParseTypeArguments() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.lessThan);
  while (!_index.eat.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
    tsParseType();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
  _index.popTypeContext.call(void 0, oldIsType);
}
function tsIsDeclarationStart() {
  if (_index.match.call(void 0, _types.TokenType.name)) {
    switch (_base.state.contextualKeyword) {
      case _keywords.ContextualKeyword._abstract:
      case _keywords.ContextualKeyword._declare:
      case _keywords.ContextualKeyword._enum:
      case _keywords.ContextualKeyword._interface:
      case _keywords.ContextualKeyword._module:
      case _keywords.ContextualKeyword._namespace:
      case _keywords.ContextualKeyword._type:
        return true;
      default:
        break;
    }
  }
  return false;
}
exports.tsIsDeclarationStart = tsIsDeclarationStart;

// ======================================================
// OVERRIDES
// ======================================================

function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
  }

  // The original code checked the node type to make sure this function type allows a missing
  // body, but we skip that to avoid sending around the node type. We instead just use the
  // allowExpressionBody boolean to make sure it's not an arrow function.
  if (!_index.match.call(void 0, _types.TokenType.braceL) && _util.isLineTerminator.call(void 0)) {
    // Retroactively mark the function declaration as a type.
    let i = _base.state.tokens.length - 1;
    while (i >= 0 && (_base.state.tokens[i].start >= functionStart || _base.state.tokens[i].type === _types.TokenType._default || _base.state.tokens[i].type === _types.TokenType._export)) {
      _base.state.tokens[i].isType = true;
      i--;
    }
    return;
  }
  _expression.parseFunctionBody.call(void 0, false, funcContextId);
}
exports.tsParseFunctionBodyAndFinish = tsParseFunctionBodyAndFinish;
function tsParseSubscript(startTokenIndex, noCalls, stopState) {
  if (!_util.hasPrecedingLineBreak.call(void 0) && _index.eat.call(void 0, _types.TokenType.bang)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.nonNullAssertion;
    return;
  }
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL)) {
    // There are number of things we are going to "maybe" parse, like type arguments on
    // tagged template expressions. If any of them fail, walk it back and continue.
    const snapshot = _base.state.snapshot();
    if (!noCalls && _expression.atPossibleAsync.call(void 0)) {
      // Almost certainly this is a generic async function `async <T>() => ...
      // But it might be a call with a type argument `async<T>();`
      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
      if (asyncArrowFn) {
        return;
      }
    }
    tsParseTypeArgumentsWithPossibleBitshift();
    if (!noCalls && _index.eat.call(void 0, _types.TokenType.parenL)) {
      // With f<T>(), the subscriptStartIndex marker is on the ( token.
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      _expression.parseCallExpressionArguments.call(void 0);
    } else if (_index.match.call(void 0, _types.TokenType.backQuote)) {
      // Tagged template with a type argument.
      _expression.parseTemplate.call(void 0);
    } else if (
    // The remaining possible case is an instantiation expression, e.g.
    // Array<number> . Check for a few cases that would disqualify it and
    // cause us to bail out.
    // a<b>>c is not (a<b>)>c, but a<(b>>c)
    _base.state.type === _types.TokenType.greaterThan ||
    // a<b>c is (a<b)>c
    _base.state.type !== _types.TokenType.parenL && Boolean(_base.state.type & _types.TokenType.IS_EXPRESSION_START) && !_util.hasPrecedingLineBreak.call(void 0)) {
      // Bail out. We have something like a<b>c, which is not an expression with
      // type arguments but an (a < b) > c comparison.
      _util.unexpected.call(void 0);
    }
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  } else if (!noCalls && _index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0) === _types.TokenType.lessThan) {
    // If we see f?.<, then this must be an optional call with a type argument.
    _index.next.call(void 0);
    _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
    // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    tsParseTypeArguments();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0);
  }
  _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
}
exports.tsParseSubscript = tsParseSubscript;
function tsTryParseExport() {
  if (_index.eat.call(void 0, _types.TokenType._import)) {
    // One of these cases:
    // export import A = B;
    // export import type A = require("A");
    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type) && _index.lookaheadType.call(void 0) !== _types.TokenType.eq) {
      // Eat a `type` token, unless it's actually an identifier name.
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
    }
    tsParseImportEqualsDeclaration();
    return true;
  } else if (_index.eat.call(void 0, _types.TokenType.eq)) {
    // `export = x;`
    _expression.parseExpression.call(void 0);
    _util.semicolon.call(void 0);
    return true;
  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    // `export as namespace A;`
    // See `parseNamespaceExportDeclaration` in TypeScript's own parser
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._namespace);
    _expression.parseIdentifier.call(void 0);
    _util.semicolon.call(void 0);
    return true;
  } else {
    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type) && _index.lookaheadType.call(void 0) === _types.TokenType.braceL) {
      _index.next.call(void 0);
    }
    return false;
  }
}
exports.tsTryParseExport = tsTryParseExport;

/**
 * Parse a TS import specifier, which may be prefixed with "type" and may be of
 * the form `foo as bar`.
 *
 * The number of identifier-like tokens we see happens to be enough to uniquely
 * identify the form, so simply count the number of identifiers rather than
 * matching the words `type` or `as`. This is particularly important because
 * `type` and `as` could each actually be plain identifiers rather than
 * keywords.
 */
function tsParseImportSpecifier() {
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
    // import {foo}
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
    return;
  }
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
    // import {type foo}
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
    _base.state.tokens[_base.state.tokens.length - 2].isType = true;
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
    return;
  }
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
    // import {foo as bar}
    _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
    return;
  }
  _expression.parseIdentifier.call(void 0);
  // import {type foo as bar}
  _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
  _base.state.tokens[_base.state.tokens.length - 4].isType = true;
  _base.state.tokens[_base.state.tokens.length - 3].isType = true;
  _base.state.tokens[_base.state.tokens.length - 2].isType = true;
  _base.state.tokens[_base.state.tokens.length - 1].isType = true;
}
exports.tsParseImportSpecifier = tsParseImportSpecifier;

/**
 * Just like named import specifiers, export specifiers can have from 1 to 4
 * tokens, inclusive, and the number of tokens determines the role of each token.
 */
function tsParseExportSpecifier() {
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
    // export {foo}
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;
    return;
  }
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
    // export {type foo}
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;
    _base.state.tokens[_base.state.tokens.length - 2].isType = true;
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
    return;
  }
  _expression.parseIdentifier.call(void 0);
  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {
    // export {foo as bar}
    _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;
    return;
  }
  _expression.parseIdentifier.call(void 0);
  // export {type foo as bar}
  _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;
  _base.state.tokens[_base.state.tokens.length - 4].isType = true;
  _base.state.tokens[_base.state.tokens.length - 3].isType = true;
  _base.state.tokens[_base.state.tokens.length - 2].isType = true;
  _base.state.tokens[_base.state.tokens.length - 1].isType = true;
}
exports.tsParseExportSpecifier = tsParseExportSpecifier;
function tsTryParseExportDefaultExpression() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._abstract) && _index.lookaheadType.call(void 0) === _types.TokenType._class) {
    _base.state.type = _types.TokenType._abstract;
    _index.next.call(void 0); // Skip "abstract"
    _statement.parseClass.call(void 0, true, true);
    return true;
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    // Make sure "export default" are considered type tokens so the whole thing is removed.
    const oldIsType = _index.pushTypeContext.call(void 0, 2);
    tsParseDeclaration(_keywords.ContextualKeyword._interface, true);
    _index.popTypeContext.call(void 0, oldIsType);
    return true;
  }
  return false;
}
exports.tsTryParseExportDefaultExpression = tsTryParseExportDefaultExpression;
function tsTryParseStatementContent() {
  if (_base.state.type === _types.TokenType._const) {
    const ahead = _index.lookaheadTypeAndKeyword.call(void 0);
    if (ahead.type === _types.TokenType.name && ahead.contextualKeyword === _keywords.ContextualKeyword._enum) {
      _util.expect.call(void 0, _types.TokenType._const);
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
      tsParseEnumDeclaration();
      return true;
    }
  }
  return false;
}
exports.tsTryParseStatementContent = tsTryParseStatementContent;
function tsTryParseClassMemberWithIsStatic(isStatic) {
  const memberStartIndexAfterStatic = _base.state.tokens.length;
  tsParseModifiers([_keywords.ContextualKeyword._abstract, _keywords.ContextualKeyword._readonly, _keywords.ContextualKeyword._declare, _keywords.ContextualKeyword._static, _keywords.ContextualKeyword._override]);
  const modifiersEndIndex = _base.state.tokens.length;
  const found = tsTryParseIndexSignature();
  if (found) {
    // Index signatures are type declarations, so set the modifier tokens as
    // type tokens. Most tokens could be assumed to be type tokens, but `static`
    // is ambiguous unless we set it explicitly here.
    const memberStartIndex = isStatic ? memberStartIndexAfterStatic - 1 : memberStartIndexAfterStatic;
    for (let i = memberStartIndex; i < modifiersEndIndex; i++) {
      _base.state.tokens[i].isType = true;
    }
    return true;
  }
  return false;
}
exports.tsTryParseClassMemberWithIsStatic = tsTryParseClassMemberWithIsStatic;

// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`
// is that e.g. `type()` is valid JS, so we must try parsing that first.
// If it's really a type, we will parse `type` as the statement, and can correct it here
// by parsing the rest.
function tsParseIdentifierStatement(contextualKeyword) {
  const matched = tsParseExpressionStatement(contextualKeyword);
  if (!matched) {
    _util.semicolon.call(void 0);
  }
}
exports.tsParseIdentifierStatement = tsParseIdentifierStatement;
function tsParseExportDeclaration() {
  // "export declare" is equivalent to just "export".
  const isDeclare = _util.eatContextual.call(void 0, _keywords.ContextualKeyword._declare);
  if (isDeclare) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
  }
  let matchedDeclaration = false;
  if (_index.match.call(void 0, _types.TokenType.name)) {
    if (isDeclare) {
      const oldIsType = _index.pushTypeContext.call(void 0, 2);
      matchedDeclaration = tsTryParseExportDeclaration();
      _index.popTypeContext.call(void 0, oldIsType);
    } else {
      matchedDeclaration = tsTryParseExportDeclaration();
    }
  }
  if (!matchedDeclaration) {
    if (isDeclare) {
      const oldIsType = _index.pushTypeContext.call(void 0, 2);
      _statement.parseStatement.call(void 0, true);
      _index.popTypeContext.call(void 0, oldIsType);
    } else {
      _statement.parseStatement.call(void 0, true);
    }
  }
}
exports.tsParseExportDeclaration = tsParseExportDeclaration;
function tsAfterParseClassSuper(hasSuper) {
  if (hasSuper && (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL))) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    tsParseHeritageClause();
    _index.popTypeContext.call(void 0, oldIsType);
  }
}
exports.tsAfterParseClassSuper = tsAfterParseClassSuper;
function tsStartParseObjPropValue() {
  tsTryParseTypeParameters();
}
exports.tsStartParseObjPropValue = tsStartParseObjPropValue;
function tsStartParseFunctionParams() {
  tsTryParseTypeParameters();
}
exports.tsStartParseFunctionParams = tsStartParseFunctionParams;

// `let x: number;`
function tsAfterParseVarHead() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  if (!_util.hasPrecedingLineBreak.call(void 0)) {
    _index.eat.call(void 0, _types.TokenType.bang);
  }
  tsTryParseTypeAnnotation();
  _index.popTypeContext.call(void 0, oldIsType);
}
exports.tsAfterParseVarHead = tsAfterParseVarHead;

// parse the return type of an async arrow function - let foo = (async (): number => {});
function tsStartParseAsyncArrowFromCallExpression() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    tsParseTypeAnnotation();
  }
}
exports.tsStartParseAsyncArrowFromCallExpression = tsStartParseAsyncArrowFromCallExpression;

// Returns true if the expression was an arrow function.
function tsParseMaybeAssign(noIn, isWithinParens) {
  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.
  if (_base.isJSXEnabled) {
    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
  } else {
    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
  }
}
exports.tsParseMaybeAssign = tsParseMaybeAssign;
function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
  if (!_index.match.call(void 0, _types.TokenType.lessThan)) {
    return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  }

  // Prefer to parse JSX if possible. But may be an arrow fn.
  const snapshot = _base.state.snapshot();
  let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }

  // Otherwise, try as type-parameterized arrow function.
  _base.state.type = _types.TokenType.typeParameterStart;
  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
  tsParseTypeParameters();
  wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  if (!wasArrow) {
    _util.unexpected.call(void 0);
  }
  return wasArrow;
}
exports.tsParseMaybeAssignWithJSX = tsParseMaybeAssignWithJSX;
function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
  if (!_index.match.call(void 0, _types.TokenType.lessThan)) {
    return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  }
  const snapshot = _base.state.snapshot();
  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
  tsParseTypeParameters();
  const wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  if (!wasArrow) {
    _util.unexpected.call(void 0);
  }
  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }

  // Try parsing a type cast instead of an arrow function.
  // This will start with a type assertion (via parseMaybeUnary).
  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.
  return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
}
exports.tsParseMaybeAssignWithoutJSX = tsParseMaybeAssignWithoutJSX;
function tsParseArrow() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    // This is different from how the TS parser does it.
    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.
    const snapshot = _base.state.snapshot();
    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
    if (_util.canInsertSemicolon.call(void 0)) _util.unexpected.call(void 0);
    if (!_index.match.call(void 0, _types.TokenType.arrow)) _util.unexpected.call(void 0);
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
  return _index.eat.call(void 0, _types.TokenType.arrow);
}
exports.tsParseArrow = tsParseArrow;

// Allow type annotations inside of a parameter list.
function tsParseAssignableListItemTypes() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _index.eat.call(void 0, _types.TokenType.question);
  tsTryParseTypeAnnotation();
  _index.popTypeContext.call(void 0, oldIsType);
}
exports.tsParseAssignableListItemTypes = tsParseAssignableListItemTypes;
function tsParseMaybeDecoratorArguments() {
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL)) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }
  _statement.baseParseMaybeDecoratorArguments.call(void 0);
}
exports.tsParseMaybeDecoratorArguments = tsParseMaybeDecoratorArguments;
}),
/* --- node_modules/sucrase/dist/parser/traverser/expression.js --- */
"node_modules/sucrase/dist/parser/traverser/expression.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
}); /* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var _flow = _kame_require_("node_modules/sucrase/dist/parser/plugins/flow.js");
var _index = _kame_require_("node_modules/sucrase/dist/parser/plugins/jsx/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/plugins/types.js");
var _typescript = _kame_require_("node_modules/sucrase/dist/parser/plugins/typescript.js");
var _index3 = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _state = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/state.js");
var _types3 = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _identifier = _kame_require_("node_modules/sucrase/dist/parser/util/identifier.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _lval = _kame_require_("node_modules/sucrase/dist/parser/traverser/lval.js");
var _statement = _kame_require_("node_modules/sucrase/dist/parser/traverser/statement.js");
var _util = _kame_require_("node_modules/sucrase/dist/parser/traverser/util.js");
class StopState {
  constructor(stop) {
    this.stop = stop;
  }
}
exports.StopState = StopState;

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
function parseExpression(noIn = false) {
  parseMaybeAssign(noIn);
  if (_index3.match.call(void 0, _types3.TokenType.comma)) {
    while (_index3.eat.call(void 0, _types3.TokenType.comma)) {
      parseMaybeAssign(noIn);
    }
  }
}
exports.parseExpression = parseExpression;

/**
 * noIn is used when parsing a for loop so that we don't interpret a following "in" as the binary
 * operatior.
 * isWithinParens is used to indicate that we're parsing something that might be a comma expression
 * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).
 * In these cases, we should allow : and ?: after the initial "left" part.
 */
function parseMaybeAssign(noIn = false, isWithinParens = false) {
  if (_base.isTypeScriptEnabled) {
    return _typescript.tsParseMaybeAssign.call(void 0, noIn, isWithinParens);
  } else if (_base.isFlowEnabled) {
    return _flow.flowParseMaybeAssign.call(void 0, noIn, isWithinParens);
  } else {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
}
exports.parseMaybeAssign = parseMaybeAssign;

// Parse an assignment expression. This includes applications of
// operators like `+=`.
// Returns true if the expression was an arrow function.
function baseParseMaybeAssign(noIn, isWithinParens) {
  if (_index3.match.call(void 0, _types3.TokenType._yield)) {
    parseYield();
    return false;
  }
  if (_index3.match.call(void 0, _types3.TokenType.parenL) || _index3.match.call(void 0, _types3.TokenType.name) || _index3.match.call(void 0, _types3.TokenType._yield)) {
    _base.state.potentialArrowAt = _base.state.start;
  }
  const wasArrow = parseMaybeConditional(noIn);
  if (isWithinParens) {
    parseParenItem();
  }
  if (_base.state.type & _types3.TokenType.IS_ASSIGN) {
    _index3.next.call(void 0);
    parseMaybeAssign(noIn);
    return false;
  }
  return wasArrow;
}
exports.baseParseMaybeAssign = baseParseMaybeAssign;

// Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.
function parseMaybeConditional(noIn) {
  const wasArrow = parseExprOps(noIn);
  if (wasArrow) {
    return true;
  }
  parseConditional(noIn);
  return false;
}
function parseConditional(noIn) {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    _types.typedParseConditional.call(void 0, noIn);
  } else {
    baseParseConditional(noIn);
  }
}
function baseParseConditional(noIn) {
  if (_index3.eat.call(void 0, _types3.TokenType.question)) {
    parseMaybeAssign();
    _util.expect.call(void 0, _types3.TokenType.colon);
    parseMaybeAssign(noIn);
  }
}
exports.baseParseConditional = baseParseConditional;

// Start the precedence parser.
// Returns true if this was an arrow function
function parseExprOps(noIn) {
  const startTokenIndex = _base.state.tokens.length;
  const wasArrow = parseMaybeUnary();
  if (wasArrow) {
    return true;
  }
  parseExprOp(startTokenIndex, -1, noIn);
  return false;
}

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
function parseExprOp(startTokenIndex, minPrec, noIn) {
  if (_base.isTypeScriptEnabled && (_types3.TokenType._in & _types3.TokenType.PRECEDENCE_MASK) > minPrec && !_util.hasPrecedingLineBreak.call(void 0) && (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as) || _util.eatContextual.call(void 0, _keywords.ContextualKeyword._satisfies))) {
    const oldIsType = _index3.pushTypeContext.call(void 0, 1);
    _typescript.tsParseType.call(void 0);
    _index3.popTypeContext.call(void 0, oldIsType);
    _index3.rescan_gt.call(void 0);
    parseExprOp(startTokenIndex, minPrec, noIn);
    return;
  }
  const prec = _base.state.type & _types3.TokenType.PRECEDENCE_MASK;
  if (prec > 0 && (!noIn || !_index3.match.call(void 0, _types3.TokenType._in))) {
    if (prec > minPrec) {
      const op = _base.state.type;
      _index3.next.call(void 0);
      if (op === _types3.TokenType.nullishCoalescing) {
        _base.state.tokens[_base.state.tokens.length - 1].nullishStartIndex = startTokenIndex;
      }
      const rhsStartTokenIndex = _base.state.tokens.length;
      parseMaybeUnary();
      // Extend the right operand of this operator if possible.
      parseExprOp(rhsStartTokenIndex, op & _types3.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
      if (op === _types3.TokenType.nullishCoalescing) {
        _base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;
        _base.state.tokens[_base.state.tokens.length - 1].numNullishCoalesceEnds++;
      }
      // Continue with any future operator holding this expression as the left operand.
      parseExprOp(startTokenIndex, minPrec, noIn);
    }
  }
}

// Parse unary operators, both prefix and postfix.
// Returns true if this was an arrow function.
function parseMaybeUnary() {
  if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && _index3.eat.call(void 0, _types3.TokenType.lessThan)) {
    _typescript.tsParseTypeAssertion.call(void 0);
    return false;
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._module) && _index3.lookaheadCharCode.call(void 0) === _charcodes.charCodes.leftCurlyBrace && !_util.hasFollowingLineBreak.call(void 0)) {
    parseModuleExpression();
    return false;
  }
  if (_base.state.type & _types3.TokenType.IS_PREFIX) {
    _index3.next.call(void 0);
    parseMaybeUnary();
    return false;
  }
  const wasArrow = parseExprSubscripts();
  if (wasArrow) {
    return true;
  }
  while (_base.state.type & _types3.TokenType.IS_POSTFIX && !_util.canInsertSemicolon.call(void 0)) {
    // The tokenizer calls everything a preincrement, so make it a postincrement when
    // we see it in that context.
    if (_base.state.type === _types3.TokenType.preIncDec) {
      _base.state.type = _types3.TokenType.postIncDec;
    }
    _index3.next.call(void 0);
  }
  return false;
}
exports.parseMaybeUnary = parseMaybeUnary;

// Parse call, dot, and `[]`-subscript expressions.
// Returns true if this was an arrow function.
function parseExprSubscripts() {
  const startTokenIndex = _base.state.tokens.length;
  const wasArrow = parseExprAtom();
  if (wasArrow) {
    return true;
  }
  parseSubscripts(startTokenIndex);
  // If there was any optional chain operation, the start token would be marked
  // as such, so also mark the end now.
  if (_base.state.tokens.length > startTokenIndex && _base.state.tokens[startTokenIndex].isOptionalChainStart) {
    _base.state.tokens[_base.state.tokens.length - 1].isOptionalChainEnd = true;
  }
  return false;
}
exports.parseExprSubscripts = parseExprSubscripts;
function parseSubscripts(startTokenIndex, noCalls = false) {
  if (_base.isFlowEnabled) {
    _flow.flowParseSubscripts.call(void 0, startTokenIndex, noCalls);
  } else {
    baseParseSubscripts(startTokenIndex, noCalls);
  }
}
function baseParseSubscripts(startTokenIndex, noCalls = false) {
  const stopState = new StopState(false);
  do {
    parseSubscript(startTokenIndex, noCalls, stopState);
  } while (!stopState.stop && !_base.state.error);
}
exports.baseParseSubscripts = baseParseSubscripts;
function parseSubscript(startTokenIndex, noCalls, stopState) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
  } else {
    baseParseSubscript(startTokenIndex, noCalls, stopState);
  }
}

/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */
function baseParseSubscript(startTokenIndex, noCalls, stopState) {
  if (!noCalls && _index3.eat.call(void 0, _types3.TokenType.doubleColon)) {
    parseNoCallExpr();
    stopState.stop = true;
    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want
    // to revisit this in the future when fully supporting bind syntax.
    parseSubscripts(startTokenIndex, noCalls);
  } else if (_index3.match.call(void 0, _types3.TokenType.questionDot)) {
    _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
    if (noCalls && _index3.lookaheadType.call(void 0) === _types3.TokenType.parenL) {
      stopState.stop = true;
      return;
    }
    _index3.next.call(void 0);
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
      parseExpression();
      _util.expect.call(void 0, _types3.TokenType.bracketR);
    } else if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
      parseCallExpressionArguments();
    } else {
      parseMaybePrivateName();
    }
  } else if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseMaybePrivateName();
  } else if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseExpression();
    _util.expect.call(void 0, _types3.TokenType.bracketR);
  } else if (!noCalls && _index3.match.call(void 0, _types3.TokenType.parenL)) {
    if (atPossibleAsync()) {
      // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
      const snapshot = _base.state.snapshot();
      const asyncStartTokenIndex = _base.state.tokens.length;
      _index3.next.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = _base.getNextContextId.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
      if (shouldParseAsyncArrow()) {
        // We hit an arrow, so backtrack and start again parsing function parameters.
        _base.state.restoreFromSnapshot(snapshot);
        stopState.stop = true;
        _base.state.scopeDepth++;
        _statement.parseFunctionParams.call(void 0);
        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
      }
    } else {
      _index3.next.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = _base.getNextContextId.call(void 0);
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
    }
  } else if (_index3.match.call(void 0, _types3.TokenType.backQuote)) {
    // Tagged template expression.
    parseTemplate();
  } else {
    stopState.stop = true;
  }
}
exports.baseParseSubscript = baseParseSubscript;
function atPossibleAsync() {
  // This was made less strict than the original version to avoid passing around nodes, but it
  // should be safe to have rare false positives here.
  return _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async && !_util.canInsertSemicolon.call(void 0);
}
exports.atPossibleAsync = atPossibleAsync;
function parseCallExpressionArguments() {
  let first = true;
  while (!_index3.eat.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, _types3.TokenType.parenR)) {
        break;
      }
    }
    parseExprListItem(false);
  }
}
exports.parseCallExpressionArguments = parseCallExpressionArguments;
function shouldParseAsyncArrow() {
  return _index3.match.call(void 0, _types3.TokenType.colon) || _index3.match.call(void 0, _types3.TokenType.arrow);
}
function parseAsyncArrowFromCallExpression(startTokenIndex) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsStartParseAsyncArrowFromCallExpression.call(void 0);
  } else if (_base.isFlowEnabled) {
    _flow.flowStartParseAsyncArrowFromCallExpression.call(void 0);
  }
  _util.expect.call(void 0, _types3.TokenType.arrow);
  parseArrowExpression(startTokenIndex);
}

// Parse a no-call expression (like argument of `new` or `::` operators).

function parseNoCallExpr() {
  const startTokenIndex = _base.state.tokens.length;
  parseExprAtom();
  parseSubscripts(startTokenIndex, true);
}

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
// Returns true if the parsed expression was an arrow function.
function parseExprAtom() {
  if (_index3.eat.call(void 0, _types3.TokenType.modulo)) {
    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed
    // naturally.
    parseIdentifier();
    return false;
  }
  if (_index3.match.call(void 0, _types3.TokenType.jsxText) || _index3.match.call(void 0, _types3.TokenType.jsxEmptyText)) {
    parseLiteral();
    return false;
  } else if (_index3.match.call(void 0, _types3.TokenType.lessThan) && _base.isJSXEnabled) {
    _base.state.type = _types3.TokenType.jsxTagStart;
    _index.jsxParseElement.call(void 0);
    _index3.next.call(void 0);
    return false;
  }
  const canBeArrow = _base.state.potentialArrowAt === _base.state.start;
  switch (_base.state.type) {
    case _types3.TokenType.slash:
    case _types3.TokenType.assign:
      _index3.retokenizeSlashAsRegex.call(void 0);
    // Fall through.

    case _types3.TokenType._super:
    case _types3.TokenType._this:
    case _types3.TokenType.regexp:
    case _types3.TokenType.num:
    case _types3.TokenType.bigint:
    case _types3.TokenType.decimal:
    case _types3.TokenType.string:
    case _types3.TokenType._null:
    case _types3.TokenType._true:
    case _types3.TokenType._false:
      _index3.next.call(void 0);
      return false;
    case _types3.TokenType._import:
      _index3.next.call(void 0);
      if (_index3.match.call(void 0, _types3.TokenType.dot)) {
        // import.meta
        _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
        _index3.next.call(void 0);
        parseIdentifier();
      }
      return false;
    case _types3.TokenType.name:
      {
        const startTokenIndex = _base.state.tokens.length;
        const functionStart = _base.state.start;
        const contextualKeyword = _base.state.contextualKeyword;
        parseIdentifier();
        if (contextualKeyword === _keywords.ContextualKeyword._await) {
          parseAwait();
          return false;
        } else if (contextualKeyword === _keywords.ContextualKeyword._async && _index3.match.call(void 0, _types3.TokenType._function) && !_util.canInsertSemicolon.call(void 0)) {
          _index3.next.call(void 0);
          _statement.parseFunction.call(void 0, functionStart, false);
          return false;
        } else if (canBeArrow && contextualKeyword === _keywords.ContextualKeyword._async && !_util.canInsertSemicolon.call(void 0) && _index3.match.call(void 0, _types3.TokenType.name)) {
          _base.state.scopeDepth++;
          _lval.parseBindingIdentifier.call(void 0, false);
          _util.expect.call(void 0, _types3.TokenType.arrow);
          // let foo = async bar => {};
          parseArrowExpression(startTokenIndex);
          return true;
        } else if (_index3.match.call(void 0, _types3.TokenType._do) && !_util.canInsertSemicolon.call(void 0)) {
          _index3.next.call(void 0);
          _statement.parseBlock.call(void 0);
          return false;
        }
        if (canBeArrow && !_util.canInsertSemicolon.call(void 0) && _index3.match.call(void 0, _types3.TokenType.arrow)) {
          _base.state.scopeDepth++;
          _lval.markPriorBindingIdentifier.call(void 0, false);
          _util.expect.call(void 0, _types3.TokenType.arrow);
          parseArrowExpression(startTokenIndex);
          return true;
        }
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.Access;
        return false;
      }
    case _types3.TokenType._do:
      {
        _index3.next.call(void 0);
        _statement.parseBlock.call(void 0);
        return false;
      }
    case _types3.TokenType.parenL:
      {
        const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
        return wasArrow;
      }
    case _types3.TokenType.bracketL:
      _index3.next.call(void 0);
      parseExprList(_types3.TokenType.bracketR, true);
      return false;
    case _types3.TokenType.braceL:
      parseObj(false, false);
      return false;
    case _types3.TokenType._function:
      parseFunctionExpression();
      return false;
    case _types3.TokenType.at:
      _statement.parseDecorators.call(void 0);
    // Fall through.

    case _types3.TokenType._class:
      _statement.parseClass.call(void 0, false);
      return false;
    case _types3.TokenType._new:
      parseNew();
      return false;
    case _types3.TokenType.backQuote:
      parseTemplate();
      return false;
    case _types3.TokenType.doubleColon:
      {
        _index3.next.call(void 0);
        parseNoCallExpr();
        return false;
      }
    case _types3.TokenType.hash:
      {
        const code = _index3.lookaheadCharCode.call(void 0);
        if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash) {
          parseMaybePrivateName();
        } else {
          _index3.next.call(void 0);
        }
        // Smart pipeline topic reference.
        return false;
      }
    default:
      _util.unexpected.call(void 0);
      return false;
  }
}
exports.parseExprAtom = parseExprAtom;
function parseMaybePrivateName() {
  _index3.eat.call(void 0, _types3.TokenType.hash);
  parseIdentifier();
}
function parseFunctionExpression() {
  const functionStart = _base.state.start;
  parseIdentifier();
  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    // function.sent
    parseIdentifier();
  }
  _statement.parseFunction.call(void 0, functionStart, false);
}
function parseLiteral() {
  _index3.next.call(void 0);
}
exports.parseLiteral = parseLiteral;
function parseParenExpression() {
  _util.expect.call(void 0, _types3.TokenType.parenL);
  parseExpression();
  _util.expect.call(void 0, _types3.TokenType.parenR);
}
exports.parseParenExpression = parseParenExpression;

// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
  // start over as a parameter list.
  const snapshot = _base.state.snapshot();
  const startTokenIndex = _base.state.tokens.length;
  _util.expect.call(void 0, _types3.TokenType.parenL);
  let first = true;
  while (!_index3.match.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.match.call(void 0, _types3.TokenType.parenR)) {
        break;
      }
    }
    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
      _lval.parseRest.call(void 0, false /* isBlockScope */);
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }
  _util.expect.call(void 0, _types3.TokenType.parenR);
  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      // It was an arrow function this whole time, so start over and parse it as params so that we
      // get proper token annotations.
      _base.state.restoreFromSnapshot(snapshot);
      _base.state.scopeDepth++;
      // Don't specify a context ID because arrow functions don't need a context ID.
      _statement.parseFunctionParams.call(void 0);
      parseArrow();
      parseArrowExpression(startTokenIndex);
      if (_base.state.error) {
        // Nevermind! This must have been something that looks very much like an
        // arrow function but where its "parameter list" isn't actually a valid
        // parameter list. Force non-arrow parsing.
        // See https://github.com/alangpierce/sucrase/issues/666 for an example.
        _base.state.restoreFromSnapshot(snapshot);
        parseParenAndDistinguishExpression(false);
        return false;
      }
      return true;
    }
  }
  return false;
}
function shouldParseArrow() {
  return _index3.match.call(void 0, _types3.TokenType.colon) || !_util.canInsertSemicolon.call(void 0);
}

// Returns whether there was an arrow token.
function parseArrow() {
  if (_base.isTypeScriptEnabled) {
    return _typescript.tsParseArrow.call(void 0);
  } else if (_base.isFlowEnabled) {
    return _flow.flowParseArrow.call(void 0);
  } else {
    return _index3.eat.call(void 0, _types3.TokenType.arrow);
  }
}
exports.parseArrow = parseArrow;
function parseParenItem() {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    _types.typedParseParenItem.call(void 0);
  }
}

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
  _util.expect.call(void 0, _types3.TokenType._new);
  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    // new.target
    parseIdentifier();
    return;
  }
  parseNewCallee();
  if (_base.isFlowEnabled) {
    _flow.flowStartParseNewArguments.call(void 0);
  }
  if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
    parseExprList(_types3.TokenType.parenR);
  }
}
function parseNewCallee() {
  parseNoCallExpr();
  _index3.eat.call(void 0, _types3.TokenType.questionDot);
}
function parseTemplate() {
  // Finish `, read quasi
  _index3.nextTemplateToken.call(void 0);
  // Finish quasi, read ${
  _index3.nextTemplateToken.call(void 0);
  while (!_index3.match.call(void 0, _types3.TokenType.backQuote) && !_base.state.error) {
    _util.expect.call(void 0, _types3.TokenType.dollarBraceL);
    parseExpression();
    // Finish }, read quasi
    _index3.nextTemplateToken.call(void 0);
    // Finish quasi, read either ${ or `
    _index3.nextTemplateToken.call(void 0);
  }
  _index3.next.call(void 0);
}
exports.parseTemplate = parseTemplate;

// Parse an object literal or binding pattern.
function parseObj(isPattern, isBlockScope) {
  // Attach a context ID to the object open and close brace and each object key.
  const contextId = _base.getNextContextId.call(void 0);
  let first = true;
  _index3.next.call(void 0);
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  while (!_index3.eat.call(void 0, _types3.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {
        break;
      }
    }
    let isGenerator = false;
    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
      const previousIndex = _base.state.tokens.length;
      _lval.parseSpread.call(void 0);
      if (isPattern) {
        // Mark role when the only thing being spread over is an identifier.
        if (_base.state.tokens.length === previousIndex + 2) {
          _lval.markPriorBindingIdentifier.call(void 0, isBlockScope);
        }
        if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {
          break;
        }
      }
      continue;
    }
    if (!isPattern) {
      isGenerator = _index3.eat.call(void 0, _types3.TokenType.star);
    }
    if (!isPattern && _util.isContextual.call(void 0, _keywords.ContextualKeyword._async)) {
      if (isGenerator) _util.unexpected.call(void 0);
      parseIdentifier();
      if (_index3.match.call(void 0, _types3.TokenType.colon) || _index3.match.call(void 0, _types3.TokenType.parenL) || _index3.match.call(void 0, _types3.TokenType.braceR) || _index3.match.call(void 0, _types3.TokenType.eq) || _index3.match.call(void 0, _types3.TokenType.comma)) {
        // This is a key called "async" rather than an async function.
      } else {
        if (_index3.match.call(void 0, _types3.TokenType.star)) {
          _index3.next.call(void 0);
          isGenerator = true;
        }
        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }
    parseObjPropValue(isPattern, isBlockScope, contextId);
  }
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
}
exports.parseObj = parseObj;
function isGetterOrSetterMethod(isPattern) {
  // We go off of the next and don't bother checking if the node key is actually "get" or "set".
  // This lets us avoid generating a node, and should only make the validation worse.
  return !isPattern && (_index3.match.call(void 0, _types3.TokenType.string) ||
  // get "string"() {}
  _index3.match.call(void 0, _types3.TokenType.num) ||
  // get 1() {}
  _index3.match.call(void 0, _types3.TokenType.bracketL) ||
  // get ["string"]() {}
  _index3.match.call(void 0, _types3.TokenType.name) ||
  // get foo() {}
  !!(_base.state.type & _types3.TokenType.IS_KEYWORD)) // get debugger() {}
  ;
}

// Returns true if this was a method.
function parseObjectMethod(isPattern, objectContextId) {
  // We don't need to worry about modifiers because object methods can't have optional bodies, so
  // the start will never be used.
  const functionStart = _base.state.start;
  if (_index3.match.call(void 0, _types3.TokenType.parenL)) {
    if (isPattern) _util.unexpected.call(void 0);
    parseMethod(functionStart, /* isConstructor */false);
    return true;
  }
  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(functionStart, /* isConstructor */false);
    return true;
  }
  return false;
}
function parseObjectProperty(isPattern, isBlockScope) {
  if (_index3.eat.call(void 0, _types3.TokenType.colon)) {
    if (isPattern) {
      _lval.parseMaybeDefault.call(void 0, isBlockScope);
    } else {
      parseMaybeAssign(false);
    }
    return;
  }

  // Since there's no colon, we assume this is an object shorthand.

  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
  // transform it on access, so mark it as a normal object shorthand.
  let identifierRole;
  if (isPattern) {
    if (_base.state.scopeDepth === 0) {
      identifierRole = _index3.IdentifierRole.ObjectShorthandTopLevelDeclaration;
    } else if (isBlockScope) {
      identifierRole = _index3.IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    } else {
      identifierRole = _index3.IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
  } else {
    identifierRole = _index3.IdentifierRole.ObjectShorthand;
  }
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;

  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow
  // parsing as if there's a default value.
  _lval.parseMaybeDefault.call(void 0, isBlockScope, true);
}
function parseObjPropValue(isPattern, isBlockScope, objectContextId) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsStartParseObjPropValue.call(void 0);
  } else if (_base.isFlowEnabled) {
    _flow.flowStartParseObjPropValue.call(void 0);
  }
  const wasMethod = parseObjectMethod(isPattern, objectContextId);
  if (!wasMethod) {
    parseObjectProperty(isPattern, isBlockScope);
  }
}
function parsePropertyName(objectContextId) {
  if (_base.isFlowEnabled) {
    _flow.flowParseVariance.call(void 0);
  }
  if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
    parseMaybeAssign();
    _util.expect.call(void 0, _types3.TokenType.bracketR);
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  } else {
    if (_index3.match.call(void 0, _types3.TokenType.num) || _index3.match.call(void 0, _types3.TokenType.string) || _index3.match.call(void 0, _types3.TokenType.bigint) || _index3.match.call(void 0, _types3.TokenType.decimal)) {
      parseExprAtom();
    } else {
      parseMaybePrivateName();
    }
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.ObjectKey;
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  }
}
exports.parsePropertyName = parsePropertyName;

// Parse object or class method.
function parseMethod(functionStart, isConstructor) {
  const funcContextId = _base.getNextContextId.call(void 0);
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  const allowModifiers = isConstructor; // For TypeScript parameter properties
  _statement.parseFunctionParams.call(void 0, allowModifiers, funcContextId);
  parseFunctionBodyAndFinish(functionStart, funcContextId);
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
  _base.state.scopeDepth--;
}
exports.parseMethod = parseMethod;

// Parse arrow function expression.
// If the parameters are provided, they will be converted to an
// assignable list.
function parseArrowExpression(startTokenIndex) {
  parseFunctionBody(true);
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
  _base.state.scopeDepth--;
}
exports.parseArrowExpression = parseArrowExpression;
function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseFunctionBodyAndFinish.call(void 0, functionStart, funcContextId);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseFunctionBodyAndFinish.call(void 0, funcContextId);
  } else {
    parseFunctionBody(false, funcContextId);
  }
}
exports.parseFunctionBodyAndFinish = parseFunctionBodyAndFinish;
function parseFunctionBody(allowExpression, funcContextId = 0) {
  const isExpression = allowExpression && !_index3.match.call(void 0, _types3.TokenType.braceL);
  if (isExpression) {
    parseMaybeAssign();
  } else {
    _statement.parseBlock.call(void 0, true /* isFunctionScope */, funcContextId);
  }
}
exports.parseFunctionBody = parseFunctionBody;

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

function parseExprList(close, allowEmpty = false) {
  let first = true;
  while (!_index3.eat.call(void 0, close) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, close)) break;
    }
    parseExprListItem(allowEmpty);
  }
}
function parseExprListItem(allowEmpty) {
  if (allowEmpty && _index3.match.call(void 0, _types3.TokenType.comma)) {
    // Empty item; nothing more to parse for this item.
  } else if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
    _lval.parseSpread.call(void 0);
    parseParenItem();
  } else if (_index3.match.call(void 0, _types3.TokenType.question)) {
    // Partial function application proposal.
    _index3.next.call(void 0);
  } else {
    parseMaybeAssign(false, true);
  }
}

// Parse the next token as an identifier.
function parseIdentifier() {
  _index3.next.call(void 0);
  _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
}
exports.parseIdentifier = parseIdentifier;

// Parses await expression inside async function.
function parseAwait() {
  parseMaybeUnary();
}

// Parses yield expression inside generator.
function parseYield() {
  _index3.next.call(void 0);
  if (!_index3.match.call(void 0, _types3.TokenType.semi) && !_util.canInsertSemicolon.call(void 0)) {
    _index3.eat.call(void 0, _types3.TokenType.star);
    parseMaybeAssign();
  }
}

// https://github.com/tc39/proposal-js-module-blocks
function parseModuleExpression() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._module);
  _util.expect.call(void 0, _types3.TokenType.braceL);
  // For now, just call parseBlockBody to parse the block. In the future when we
  // implement full support, we'll want to emit scopes and possibly other
  // information.
  _statement.parseBlockBody.call(void 0, _types3.TokenType.braceR);
}
}),
/* --- node_modules/sucrase/dist/parser/traverser/lval.js --- */
"node_modules/sucrase/dist/parser/traverser/lval.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _flow = _kame_require_("node_modules/sucrase/dist/parser/plugins/flow.js");
var _typescript = _kame_require_("node_modules/sucrase/dist/parser/plugins/typescript.js");
var _index = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _keywords = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/keywords.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _expression = _kame_require_("node_modules/sucrase/dist/parser/traverser/expression.js");
var _util = _kame_require_("node_modules/sucrase/dist/parser/traverser/util.js");
function parseSpread() {
  _index.next.call(void 0);
  _expression.parseMaybeAssign.call(void 0, false);
}
exports.parseSpread = parseSpread;
function parseRest(isBlockScope) {
  _index.next.call(void 0);
  parseBindingAtom(isBlockScope);
}
exports.parseRest = parseRest;
function parseBindingIdentifier(isBlockScope) {
  _expression.parseIdentifier.call(void 0);
  markPriorBindingIdentifier(isBlockScope);
}
exports.parseBindingIdentifier = parseBindingIdentifier;
function parseImportedIdentifier() {
  _expression.parseIdentifier.call(void 0);
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
}
exports.parseImportedIdentifier = parseImportedIdentifier;
function markPriorBindingIdentifier(isBlockScope) {
  let identifierRole;
  if (_base.state.scopeDepth === 0) {
    identifierRole = _index.IdentifierRole.TopLevelDeclaration;
  } else if (isBlockScope) {
    identifierRole = _index.IdentifierRole.BlockScopedDeclaration;
  } else {
    identifierRole = _index.IdentifierRole.FunctionScopedDeclaration;
  }
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
}
exports.markPriorBindingIdentifier = markPriorBindingIdentifier;

// Parses lvalue (assignable) atom.
function parseBindingAtom(isBlockScope) {
  switch (_base.state.type) {
    case _types.TokenType._this:
      {
        // In TypeScript, "this" may be the name of a parameter, so allow it.
        const oldIsType = _index.pushTypeContext.call(void 0, 0);
        _index.next.call(void 0);
        _index.popTypeContext.call(void 0, oldIsType);
        return;
      }
    case _types.TokenType._yield:
    case _types.TokenType.name:
      {
        _base.state.type = _types.TokenType.name;
        parseBindingIdentifier(isBlockScope);
        return;
      }
    case _types.TokenType.bracketL:
      {
        _index.next.call(void 0);
        parseBindingList(_types.TokenType.bracketR, isBlockScope, true /* allowEmpty */);
        return;
      }
    case _types.TokenType.braceL:
      _expression.parseObj.call(void 0, true, isBlockScope);
      return;
    default:
      _util.unexpected.call(void 0);
  }
}
exports.parseBindingAtom = parseBindingAtom;
function parseBindingList(close, isBlockScope, allowEmpty = false, allowModifiers = false, contextId = 0) {
  let first = true;
  let hasRemovedComma = false;
  const firstItemTokenIndex = _base.state.tokens.length;
  while (!_index.eat.call(void 0, close) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types.TokenType.comma);
      _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
      // After a "this" type in TypeScript, we need to set the following comma (if any) to also be
      // a type token so that it will be removed.
      if (!hasRemovedComma && _base.state.tokens[firstItemTokenIndex].isType) {
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
        hasRemovedComma = true;
      }
    }
    if (allowEmpty && _index.match.call(void 0, _types.TokenType.comma)) {
      // Empty item; nothing further to parse for this item.
    } else if (_index.eat.call(void 0, close)) {
      break;
    } else if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
      parseRest(isBlockScope);
      parseAssignableListItemTypes();
      // Support rest element trailing commas allowed by TypeScript <2.9.
      _index.eat.call(void 0, _types.TokenType.comma);
      _util.expect.call(void 0, close);
      break;
    } else {
      parseAssignableListItem(allowModifiers, isBlockScope);
    }
  }
}
exports.parseBindingList = parseBindingList;
function parseAssignableListItem(allowModifiers, isBlockScope) {
  if (allowModifiers) {
    _typescript.tsParseModifiers.call(void 0, [_keywords.ContextualKeyword._public, _keywords.ContextualKeyword._protected, _keywords.ContextualKeyword._private, _keywords.ContextualKeyword._readonly, _keywords.ContextualKeyword._override]);
  }
  parseMaybeDefault(isBlockScope);
  parseAssignableListItemTypes();
  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);
}

function parseAssignableListItemTypes() {
  if (_base.isFlowEnabled) {
    _flow.flowParseAssignableListItemTypes.call(void 0);
  } else if (_base.isTypeScriptEnabled) {
    _typescript.tsParseAssignableListItemTypes.call(void 0);
  }
}

// Parses assignment pattern around given atom if possible.
function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
  if (!leftAlreadyParsed) {
    parseBindingAtom(isBlockScope);
  }
  if (!_index.eat.call(void 0, _types.TokenType.eq)) {
    return;
  }
  const eqIndex = _base.state.tokens.length - 1;
  _expression.parseMaybeAssign.call(void 0);
  _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
}
exports.parseMaybeDefault = parseMaybeDefault;
}),
/* --- node_modules/yaml/dist/compose/resolve-block-map.js --- */
"node_modules/yaml/dist/compose/resolve-block-map.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Pair = _kame_require_("node_modules/yaml/dist/nodes/Pair.js");
var YAMLMap = _kame_require_("node_modules/yaml/dist/nodes/YAMLMap.js");
var resolveProps = _kame_require_("node_modules/yaml/dist/compose/resolve-props.js");
var utilContainsNewline = _kame_require_("node_modules/yaml/dist/compose/util-contains-newline.js");
var utilFlowIndentCheck = _kame_require_("node_modules/yaml/dist/compose/util-flow-indent-check.js");
var utilMapIncludes = _kame_require_("node_modules/yaml/dist/compose/util-map-includes.js");
const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({
  composeNode,
  composeEmptyNode
}, ctx, bm, onError) {
  const map = new YAMLMap.YAMLMap(ctx.schema);
  if (ctx.atRoot) ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    var _keyProps$found;
    const {
      start,
      key,
      sep,
      value
    } = collItem;
    // key properties
    const keyProps = resolveProps.resolveProps(start, {
      indicator: 'explicit-key-ind',
      next: key ?? (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === 'block-seq') onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');else if ('indent' in key && key.indent !== bm.indent) onError(offset, 'BAD_INDENT', startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map.comment) map.comment += '\n' + keyProps.comment;else map.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {
        onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
      }
    } else if (((_keyProps$found = keyProps.found) === null || _keyProps$found === void 0 ? void 0 : _keyProps$found.indent) !== bm.indent) {
      onError(offset, 'BAD_INDENT', startColMsg);
    }
    // key value
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
    if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
    // value properties
    const valueProps = resolveProps.resolveProps(sep ?? [], {
      indicator: 'map-value-ind',
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === 'block-scalar'
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value === null || value === void 0 ? void 0 : value.type) === 'block-map' && !valueProps.hasNewline) onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
      }
      // value value
      const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair.Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
      map.items.push(pair);
    } else {
      // key with no value
      if (implicitKey) onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
      if (valueProps.comment) {
        if (keyNode.comment) keyNode.comment += '\n' + valueProps.comment;else keyNode.comment = valueProps.comment;
      }
      const pair = new Pair.Pair(keyNode);
      if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
      map.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset) onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
  map.range = [bm.offset, offset, commentEnd ?? offset];
  return map;
}
exports.resolveBlockMap = resolveBlockMap;
}),
/* --- node_modules/yaml/dist/compose/resolve-block-seq.js --- */
"node_modules/yaml/dist/compose/resolve-block-seq.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var YAMLSeq = _kame_require_("node_modules/yaml/dist/nodes/YAMLSeq.js");
var resolveProps = _kame_require_("node_modules/yaml/dist/compose/resolve-props.js");
var utilFlowIndentCheck = _kame_require_("node_modules/yaml/dist/compose/util-flow-indent-check.js");
function resolveBlockSeq({
  composeNode,
  composeEmptyNode
}, ctx, bs, onError) {
  const seq = new YAMLSeq.YAMLSeq(ctx.schema);
  if (ctx.atRoot) ctx.atRoot = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const {
    start,
    value
  } of bs.items) {
    const props = resolveProps.resolveProps(start, {
      indicator: 'seq-item-ind',
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === 'block-seq') onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');else onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
      } else {
        commentEnd = props.end;
        if (props.comment) seq.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq.items.push(node);
  }
  seq.range = [bs.offset, offset, commentEnd ?? offset];
  return seq;
}
exports.resolveBlockSeq = resolveBlockSeq;
}),
/* --- node_modules/yaml/dist/compose/resolve-flow-collection.js --- */
"node_modules/yaml/dist/compose/resolve-flow-collection.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
var Pair = _kame_require_("node_modules/yaml/dist/nodes/Pair.js");
var YAMLMap = _kame_require_("node_modules/yaml/dist/nodes/YAMLMap.js");
var YAMLSeq = _kame_require_("node_modules/yaml/dist/nodes/YAMLSeq.js");
var resolveEnd = _kame_require_("node_modules/yaml/dist/compose/resolve-end.js");
var resolveProps = _kame_require_("node_modules/yaml/dist/compose/resolve-props.js");
var utilContainsNewline = _kame_require_("node_modules/yaml/dist/compose/util-contains-newline.js");
var utilMapIncludes = _kame_require_("node_modules/yaml/dist/compose/util-map-includes.js");
const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = token => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({
  composeNode,
  composeEmptyNode
}, ctx, fc, onError) {
  const isMap = fc.start.source === '{';
  const fcName = isMap ? 'flow map' : 'flow sequence';
  const coll = isMap ? new YAMLMap.YAMLMap(ctx.schema) : new YAMLSeq.YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot) ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const {
      start,
      key,
      sep,
      value
    } = collItem;
    const props = resolveProps.resolveProps(start, {
      flow: fcName,
      indicator: 'explicit-key-ind',
      next: key ?? (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma) onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);else if (i < fc.items.length - 1) onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment) coll.comment += '\n' + props.comment;else coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key)) onError(key,
      // checked by containsNewline()
      'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
    }
    if (i === 0) {
      if (props.comma) onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma) onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = '';
        loop: for (const st of start) {
          switch (st.type) {
            case 'comma':
            case 'space':
              break;
            case 'comment':
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (Node.isPair(prev)) prev = prev.value ?? prev.key;
          if (prev.comment) prev.comment += '\n' + prevItemComment;else prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap && !sep && !props.found) {
      // item is a value in a seq
      //  key & sep are empty, start does not include ? or :
      const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value)) onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
    } else {
      // item is a key+value pair
      // key value
      const keyStart = props.end;
      const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
      if (isBlock(key)) onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
      // value properties
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        flow: fcName,
        indicator: 'map-value-ind',
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap && !props.found && ctx.options.strict) {
          if (sep) for (const st of sep) {
            if (st === valueProps.found) break;
            if (st.type === 'newline') {
              onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
              break;
            }
          }
          if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
        }
      } else if (value) {
        if ('source' in value && value.source && value.source[0] === ':') onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);else onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
      }
      // value value
      const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value)) onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment) keyNode.comment += '\n' + valueProps.comment;else keyNode.comment = valueProps.comment;
      }
      const pair = new Pair.Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
      if (isMap) {
        const map = coll;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        map.items.push(pair);
      } else {
        const map = new YAMLMap.YAMLMap(ctx.schema);
        map.flow = true;
        map.items.push(pair);
        coll.items.push(map);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap ? '}' : ']';
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length;else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
    if (ce && ce.source.length !== 1) ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment) coll.comment += '\n' + end.comment;else coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
exports.resolveFlowCollection = resolveFlowCollection;
}),
/* --- node_modules/sucrase/dist/parser/plugins/jsx/index.js --- */
"node_modules/sucrase/dist/parser/plugins/jsx/index.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _index = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _expression = _kame_require_("node_modules/sucrase/dist/parser/traverser/expression.js");
var _util = _kame_require_("node_modules/sucrase/dist/parser/traverser/util.js");
var _charcodes = _kame_require_("node_modules/sucrase/dist/parser/util/charcodes.js");
var _identifier = _kame_require_("node_modules/sucrase/dist/parser/util/identifier.js");
var _typescript = _kame_require_("node_modules/sucrase/dist/parser/plugins/typescript.js");

/**
 * Read token with JSX contents.
 *
 * In addition to detecting jsxTagStart and also regular tokens that might be
 * part of an expression, this code detects the start and end of text ranges
 * within JSX children. In order to properly count the number of children, we
 * distinguish jsxText from jsxEmptyText, which is a text range that simplifies
 * to the empty string after JSX whitespace trimming.
 *
 * It turns out that a JSX text range will simplify to the empty string if and
 * only if both of these conditions hold:
 * - The range consists entirely of whitespace characters (only counting space,
 *   tab, \r, and \n).
 * - The range has at least one newline.
 * This can be proven by analyzing any implementation of whitespace trimming,
 * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.
 */
function jsxReadToken() {
  let sawNewline = false;
  let sawNonWhitespace = false;
  while (true) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated JSX contents");
      return;
    }
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (ch === _charcodes.charCodes.lessThan || ch === _charcodes.charCodes.leftCurlyBrace) {
      if (_base.state.pos === _base.state.start) {
        if (ch === _charcodes.charCodes.lessThan) {
          _base.state.pos++;
          _index.finishToken.call(void 0, _types.TokenType.jsxTagStart);
          return;
        }
        _index.getTokenFromCode.call(void 0, ch);
        return;
      }
      if (sawNewline && !sawNonWhitespace) {
        _index.finishToken.call(void 0, _types.TokenType.jsxEmptyText);
      } else {
        _index.finishToken.call(void 0, _types.TokenType.jsxText);
      }
      return;
    }

    // This is part of JSX text.
    if (ch === _charcodes.charCodes.lineFeed) {
      sawNewline = true;
    } else if (ch !== _charcodes.charCodes.space && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.tab) {
      sawNonWhitespace = true;
    }
    _base.state.pos++;
  }
}
function jsxReadString(quote) {
  _base.state.pos++;
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated string constant");
      return;
    }
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (ch === quote) {
      _base.state.pos++;
      break;
    }
    _base.state.pos++;
  }
  _index.finishToken.call(void 0, _types.TokenType.string);
}

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can't contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

function jsxReadWord() {
  let ch;
  do {
    if (_base.state.pos > _base.input.length) {
      _util.unexpected.call(void 0, "Unexpectedly reached the end of input.");
      return;
    }
    ch = _base.input.charCodeAt(++_base.state.pos);
  } while (_identifier.IS_IDENTIFIER_CHAR[ch] || ch === _charcodes.charCodes.dash);
  _index.finishToken.call(void 0, _types.TokenType.jsxName);
}

// Parse next token as JSX identifier
function jsxParseIdentifier() {
  nextJSXTagToken();
}

// Parse namespaced identifier.
function jsxParseNamespacedName(identifierRole) {
  jsxParseIdentifier();
  if (!_index.eat.call(void 0, _types.TokenType.colon)) {
    // Plain identifier, so this is an access.
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
    return;
  }
  // Process the second half of the namespaced name.
  jsxParseIdentifier();
}

// Parses element name in any form - namespaced, member
// or single identifier.
function jsxParseElementName() {
  jsxParseNamespacedName(_index.IdentifierRole.Access);
  while (_index.match.call(void 0, _types.TokenType.dot)) {
    nextJSXTagToken();
    jsxParseIdentifier();
  }
}

// Parses any type of JSX attribute value.
function jsxParseAttributeValue() {
  switch (_base.state.type) {
    case _types.TokenType.braceL:
      _index.next.call(void 0);
      _expression.parseExpression.call(void 0);
      nextJSXTagToken();
      return;
    case _types.TokenType.jsxTagStart:
      jsxParseElement();
      nextJSXTagToken();
      return;
    case _types.TokenType.string:
      nextJSXTagToken();
      return;
    default:
      _util.unexpected.call(void 0, "JSX value should be either an expression or a quoted JSX text");
  }
}

// Parse JSX spread child, after already processing the {
// Does not parse the closing }
function jsxParseSpreadChild() {
  _util.expect.call(void 0, _types.TokenType.ellipsis);
  _expression.parseExpression.call(void 0);
}

// Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.
function jsxParseOpeningElement(initialTokenIndex) {
  if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {
    // This is an open-fragment.
    return false;
  }
  jsxParseElementName();
  if (_base.isTypeScriptEnabled) {
    _typescript.tsTryParseJSXTypeArgument.call(void 0);
  }
  let hasSeenPropSpread = false;
  while (!_index.match.call(void 0, _types.TokenType.slash) && !_index.match.call(void 0, _types.TokenType.jsxTagEnd) && !_base.state.error) {
    if (_index.eat.call(void 0, _types.TokenType.braceL)) {
      hasSeenPropSpread = true;
      _util.expect.call(void 0, _types.TokenType.ellipsis);
      _expression.parseMaybeAssign.call(void 0);
      // }
      nextJSXTagToken();
      continue;
    }
    if (hasSeenPropSpread && _base.state.end - _base.state.start === 3 && _base.input.charCodeAt(_base.state.start) === _charcodes.charCodes.lowercaseK && _base.input.charCodeAt(_base.state.start + 1) === _charcodes.charCodes.lowercaseE && _base.input.charCodeAt(_base.state.start + 2) === _charcodes.charCodes.lowercaseY) {
      _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.KeyAfterPropSpread;
    }
    jsxParseNamespacedName(_index.IdentifierRole.ObjectKey);
    if (_index.match.call(void 0, _types.TokenType.eq)) {
      nextJSXTagToken();
      jsxParseAttributeValue();
    }
  }
  const isSelfClosing = _index.match.call(void 0, _types.TokenType.slash);
  if (isSelfClosing) {
    // /
    nextJSXTagToken();
  }
  return isSelfClosing;
}

// Parses JSX closing tag starting after "</".
// Does not parse the last token.
function jsxParseClosingElement() {
  if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {
    // Fragment syntax, so we immediately have a tag end.
    return;
  }
  jsxParseElementName();
}

// Parses entire JSX element, including its opening tag
// (starting after "<"), attributes, contents and closing tag.
// Does not parse the last token.
function jsxParseElementAt() {
  const initialTokenIndex = _base.state.tokens.length - 1;
  _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.NoChildren;
  let numExplicitChildren = 0;
  const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);
  if (!isSelfClosing) {
    nextJSXExprToken();
    while (true) {
      switch (_base.state.type) {
        case _types.TokenType.jsxTagStart:
          nextJSXTagToken();
          if (_index.match.call(void 0, _types.TokenType.slash)) {
            nextJSXTagToken();
            jsxParseClosingElement();
            // Key after prop spread takes precedence over number of children,
            // since it means we switch to createElement, which doesn't care
            // about number of children.
            if (_base.state.tokens[initialTokenIndex].jsxRole !== _index.JSXRole.KeyAfterPropSpread) {
              if (numExplicitChildren === 1) {
                _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.OneChild;
              } else if (numExplicitChildren > 1) {
                _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.StaticChildren;
              }
            }
            return;
          }
          numExplicitChildren++;
          jsxParseElementAt();
          nextJSXExprToken();
          break;
        case _types.TokenType.jsxText:
          numExplicitChildren++;
          nextJSXExprToken();
          break;
        case _types.TokenType.jsxEmptyText:
          nextJSXExprToken();
          break;
        case _types.TokenType.braceL:
          _index.next.call(void 0);
          if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
            jsxParseSpreadChild();
            nextJSXExprToken();
            // Spread children are a mechanism to explicitly mark children as
            // static, so count it as 2 children to satisfy the "more than one
            // child" condition.
            numExplicitChildren += 2;
          } else {
            // If we see {}, this is an empty pseudo-expression that doesn't
            // count as a child.
            if (!_index.match.call(void 0, _types.TokenType.braceR)) {
              numExplicitChildren++;
              _expression.parseExpression.call(void 0);
            }
            nextJSXExprToken();
          }
          break;

        // istanbul ignore next - should never happen
        default:
          _util.unexpected.call(void 0);
          return;
      }
    }
  }
}

// Parses entire JSX element from current position.
// Does not parse the last token.
function jsxParseElement() {
  nextJSXTagToken();
  jsxParseElementAt();
}
exports.jsxParseElement = jsxParseElement;

// ==================================
// Overrides
// ==================================

function nextJSXTagToken() {
  _base.state.tokens.push(new (0, _index.Token)());
  _index.skipSpace.call(void 0);
  _base.state.start = _base.state.pos;
  const code = _base.input.charCodeAt(_base.state.pos);
  if (_identifier.IS_IDENTIFIER_START[code]) {
    jsxReadWord();
  } else if (code === _charcodes.charCodes.quotationMark || code === _charcodes.charCodes.apostrophe) {
    jsxReadString(code);
  } else {
    // The following tokens are just one character each.
    ++_base.state.pos;
    switch (code) {
      case _charcodes.charCodes.greaterThan:
        _index.finishToken.call(void 0, _types.TokenType.jsxTagEnd);
        break;
      case _charcodes.charCodes.lessThan:
        _index.finishToken.call(void 0, _types.TokenType.jsxTagStart);
        break;
      case _charcodes.charCodes.slash:
        _index.finishToken.call(void 0, _types.TokenType.slash);
        break;
      case _charcodes.charCodes.equalsTo:
        _index.finishToken.call(void 0, _types.TokenType.eq);
        break;
      case _charcodes.charCodes.leftCurlyBrace:
        _index.finishToken.call(void 0, _types.TokenType.braceL);
        break;
      case _charcodes.charCodes.dot:
        _index.finishToken.call(void 0, _types.TokenType.dot);
        break;
      case _charcodes.charCodes.colon:
        _index.finishToken.call(void 0, _types.TokenType.colon);
        break;
      default:
        _util.unexpected.call(void 0);
    }
  }
}
exports.nextJSXTagToken = nextJSXTagToken;
function nextJSXExprToken() {
  _base.state.tokens.push(new (0, _index.Token)());
  _base.state.start = _base.state.pos;
  jsxReadToken();
}
}),
/* --- node_modules/sucrase/dist/parser/plugins/types.js --- */
"node_modules/sucrase/dist/parser/plugins/types.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _index = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/index.js");
var _types = _kame_require_("node_modules/sucrase/dist/parser/tokenizer/types.js");
var _base = _kame_require_("node_modules/sucrase/dist/parser/traverser/base.js");
var _expression = _kame_require_("node_modules/sucrase/dist/parser/traverser/expression.js");
var _flow = _kame_require_("node_modules/sucrase/dist/parser/plugins/flow.js");
var _typescript = _kame_require_("node_modules/sucrase/dist/parser/plugins/typescript.js");

/**
 * Common parser code for TypeScript and Flow.
 */

// An apparent conditional expression could actually be an optional parameter in an arrow function.
function typedParseConditional(noIn) {
  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called
  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional
  // parameters without type annotations, i.e. ?, and ?) .
  if (_index.match.call(void 0, _types.TokenType.question)) {
    const nextType = _index.lookaheadType.call(void 0);
    if (nextType === _types.TokenType.colon || nextType === _types.TokenType.comma || nextType === _types.TokenType.parenR) {
      return;
    }
  }
  _expression.baseParseConditional.call(void 0, noIn);
}
exports.typedParseConditional = typedParseConditional;

// Note: These "type casts" are *not* valid TS expressions.
// But we parse them here and change them when completing the arrow function.
function typedParseParenItem() {
  _index.eatTypeToken.call(void 0, _types.TokenType.question);
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    if (_base.isTypeScriptEnabled) {
      _typescript.tsParseTypeAnnotation.call(void 0);
    } else if (_base.isFlowEnabled) {
      _flow.flowParseTypeAnnotation.call(void 0);
    }
  }
}
exports.typedParseParenItem = typedParseParenItem;
}),
/* --- node_modules/yaml/dist/compose/util-contains-newline.js --- */
"node_modules/yaml/dist/compose/util-contains-newline.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

function containsNewline(key) {
  if (!key) return null;
  switch (key.type) {
    case 'alias':
    case 'scalar':
    case 'double-quoted-scalar':
    case 'single-quoted-scalar':
      if (key.source.includes('\n')) return true;
      if (key.end) for (const st of key.end) if (st.type === 'newline') return true;
      return false;
    case 'flow-collection':
      for (const it of key.items) {
        for (const st of it.start) if (st.type === 'newline') return true;
        if (it.sep) for (const st of it.sep) if (st.type === 'newline') return true;
        if (containsNewline(it.key) || containsNewline(it.value)) return true;
      }
      return false;
    default:
      return true;
  }
}
exports.containsNewline = containsNewline;
}),
/* --- node_modules/yaml/dist/compose/util-flow-indent-check.js --- */
"node_modules/yaml/dist/compose/util-flow-indent-check.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var utilContainsNewline = _kame_require_("node_modules/yaml/dist/compose/util-contains-newline.js");
function flowIndentCheck(indent, fc, onError) {
  if ((fc === null || fc === void 0 ? void 0 : fc.type) === 'flow-collection') {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === ']' || end.source === '}') && utilContainsNewline.containsNewline(fc)) {
      const msg = 'Flow end indicator should be more indented than parent';
      onError(end, 'BAD_INDENT', msg, true);
    }
  }
}
exports.flowIndentCheck = flowIndentCheck;
}),
/* --- node_modules/yaml/dist/compose/util-map-includes.js --- */
"node_modules/yaml/dist/compose/util-map-includes.js": (function (exports, _kame_require_, module, __filename, __dirname, _kame_dynamic_import_) {
'use strict';

var Node = _kame_require_("node_modules/yaml/dist/nodes/Node.js");
function mapIncludes(ctx, items, search) {
  const {
    uniqueKeys
  } = ctx.options;
  if (uniqueKeys === false) return false;
  const isEqual = typeof uniqueKeys === 'function' ? uniqueKeys : (a, b) => a === b || Node.isScalar(a) && Node.isScalar(b) && a.value === b.value && !(a.value === '<<' && ctx.schema.merge);
  return items.some(pair => isEqual(pair.key, search));
}
exports.mapIncludes = mapIncludes;
})
/* --- end of modules --- */};

var __kame__ = {
	basedir: typeof __dirname === 'string' ? __dirname : "",
	cache: {},
	runModule: function runModule(name, isMain) {
		var exports = {};
		var module = {
			id: name,
			exports: exports,
		};

		__kame__.cache[name] = module;

		var _kame_require_ = function require(id) {
			if (__kame__.cache[id]) {
				return __kame__.cache[id].exports;
			} else {
				__kame__.runModule(id, false);
				return __kame__.cache[id].exports;
			}
		};
		_kame_require_.cache = __kame__.cache;

		if (isMain) {
			_kame_require_.main = module;
		}

		var __filename = __kame__.basedir + "/" + name;
		var __dirname = __kame__.basedir + "/" + name.split("/").slice(0, -1).join("/");

		

		__kame__.modules[name](exports, _kame_require_, module, __filename, __dirname );
		return module.exports;
	},
	
	modules: modules,
};



return __kame__.runModule("src/index.ts", true);
}

if (typeof exports === 'object' && typeof module !== 'undefined') {
	module.exports = factory();
} else if (typeof define === 'function' && define.amd) {
	define([], factory);
} else {
	factory()
}

})(
	typeof global !== "undefined" ? global :
	typeof window !== "undefined" ? window :
	typeof self !== "undefined" ? self :
	typeof this === "object" ? this :
	new Function("return this")()
);
